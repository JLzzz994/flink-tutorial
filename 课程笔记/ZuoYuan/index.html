<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.9">
<meta name="author" content="尚硅谷大数据讲师左元">
<title>尚硅谷Flink教程</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/* Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment @import statement to use as custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*::before,*::after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto;tab-size:4;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0;direction:ltr}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite::before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{display:table-cell;line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed;word-wrap:break-word}
:not(pre)>code.nobreak{word-wrap:normal}
:not(pre)>code.nowrap{white-space:nowrap}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:100%;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details>summary:first-of-type{cursor:pointer;display:list-item;outline:none;margin-bottom:.75em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6)}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{-webkit-border-radius:4px;border-radius:4px;word-wrap:break-word;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class="highlight"],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos{border-right:1px solid currentColor;opacity:.35;padding-right:.5em}
pre.pygments .lineno{border-right:1px solid currentColor;opacity:.35;display:inline-block;margin-right:.75em}
pre.pygments .lineno::before{content:"";margin-right:-.125em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt,.quoteblock .quoteblock{margin:0 0 1.25em;padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;text-align:left;margin-right:0}
table.tableblock{max-width:100%;border-collapse:separate}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
td.tableblock>.content>:last-child.sidebarblock{margin-bottom:0}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>thead>tr>.tableblock,table.grid-all>tbody>tr>.tableblock{border-width:0 1px 1px 0}
table.grid-all>tfoot>tr>.tableblock{border-width:1px 1px 0 0}
table.grid-cols>*>tr>.tableblock{border-width:0 1px 0 0}
table.grid-rows>thead>tr>.tableblock,table.grid-rows>tbody>tr>.tableblock{border-width:0 0 1px}
table.grid-rows>tfoot>tr>.tableblock{border-width:1px 0 0}
table.grid-all>*>tr>.tableblock:last-child,table.grid-cols>*>tr>.tableblock:last-child{border-right-width:0}
table.grid-all>tbody>tr:last-child>.tableblock,table.grid-all>thead:last-child>tr>.tableblock,table.grid-rows>tbody>tr:last-child>.tableblock,table.grid-rows>thead:last-child>tr>.tableblock{border-bottom-width:0}
table.frame-all{border-width:1px}
table.frame-sides{border-width:0 1px}
table.frame-topbot,table.frame-ends{border-width:1px 0}
table.stripes-all tr,table.stripes-odd tr:nth-of-type(odd),table.stripes-even tr:nth-of-type(even),table.stripes-hover tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{display:table-cell;line-height:1.6;background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{margin-right:.25em}
ul.inline{display:-ms-flexbox;display:-webkit-box;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media print,amzn-kf8{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
</head>
<body class="article toc2 toc-left">
<div id="header">
<h1>尚硅谷Flink教程</h1>
<div class="details">
<span id="author" class="author">尚硅谷大数据讲师左元</span><br>
<span id="email" class="email"><a href="mailto:zuoyuan@atguigu.com">zuoyuan@atguigu.com</a></span><br>
<span id="revnumber">version 1.0,</span>
<span id="revdate">2019-06-01</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_flink简介">1. Flink简介</a>
<ul class="sectlevel2">
<li><a href="#_初识flink">1.1. 初识Flink</a></li>
<li><a href="#_为什么选择flink">1.2. 为什么选择Flink</a>
<ul class="sectlevel3">
<li><a href="#_流处理欠佳的后果">1.2.1. 流处理欠佳的后果</a>
<ul class="sectlevel4">
<li><a href="#_零售业和市场营销">零售业和市场营销</a></li>
<li><a href="#_物联网">物联网</a></li>
<li><a href="#_电信业">电信业</a></li>
<li><a href="#_银行和金融业">银行和金融业</a></li>
</ul>
</li>
<li><a href="#_连续事件处理的目标">1.2.2. 连续事件处理的目标</a></li>
<li><a href="#_流处理技术的演变">1.2.3. 流处理技术的演变</a></li>
</ul>
</li>
<li><a href="#_flink的重要特点">1.3. Flink的重要特点</a>
<ul class="sectlevel3">
<li><a href="#_事件驱动型event_driven">1.3.1. 事件驱动型(Event-Driven)</a></li>
<li><a href="#_流与批的世界观">1.3.2. 流与批的世界观</a></li>
<li><a href="#_分层api">1.3.3. 分层api</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_有状态的流式处理简介">2. 有状态的流式处理简介</a>
<ul class="sectlevel2">
<li><a href="#_传统数据处理架构">2.1. 传统数据处理架构</a>
<ul class="sectlevel3">
<li><a href="#_事务处理">2.1.1. 事务处理</a></li>
<li><a href="#_分析处理">2.1.2. 分析处理</a></li>
</ul>
</li>
<li><a href="#_有状态的流式处理">2.2. 有状态的流式处理</a>
<ul class="sectlevel3">
<li><a href="#_事件驱动应用程序event_driven_applications">2.2.1. 事件驱动应用程序（Event-Driven Applications）</a></li>
<li><a href="#_数据管道data_pipelines">2.2.2. 数据管道（Data Pipelines）</a></li>
<li><a href="#_流分析">2.2.3. 流分析</a></li>
</ul>
</li>
<li><a href="#_开源流处理的演进">2.3. 开源流处理的演进</a>
<ul class="sectlevel3">
<li><a href="#_流处理的历史">2.3.1. 流处理的历史</a></li>
</ul>
</li>
<li><a href="#_flink_简介">2.4. Flink 简介</a></li>
</ul>
</li>
<li><a href="#_流处理基础">3. 流处理基础</a>
<ul class="sectlevel2">
<li><a href="#_数据流编程简介">3.1. 数据流编程简介</a>
<ul class="sectlevel3">
<li><a href="#_数据流图dataflow_graph">3.1.1. 数据流图(dataflow graph)</a></li>
<li><a href="#_数据并行和任务并行">3.1.2. 数据并行和任务并行</a></li>
<li><a href="#_数据交换策略">3.1.3. 数据交换策略</a></li>
</ul>
</li>
<li><a href="#_并行处理流数据">3.2. 并行处理流数据</a>
<ul class="sectlevel3">
<li><a href="#_延迟和吞吐量">3.2.1. 延迟和吞吐量</a></li>
<li><a href="#_延迟">3.2.2. 延迟</a></li>
<li><a href="#_吞吐量">3.2.3. 吞吐量</a></li>
<li><a href="#_延迟与吞吐量的对比">3.2.4. 延迟与吞吐量的对比</a></li>
</ul>
</li>
<li><a href="#_数据流上的操作">3.3. 数据流上的操作</a>
<ul class="sectlevel3">
<li><a href="#_数据摄入和数据吞吐量">3.3.1. 数据摄入和数据吞吐量</a></li>
<li><a href="#_转换算子">3.3.2. 转换算子</a></li>
<li><a href="#_滚动聚合">3.3.3. 滚动聚合</a></li>
<li><a href="#_窗口操作符">3.3.4. 窗口操作符</a></li>
</ul>
</li>
<li><a href="#_时间语义">3.4. 时间语义</a>
<ul class="sectlevel3">
<li><a href="#_在流处理中一分钟代表什么">3.4.1. 在流处理中一分钟代表什么？</a></li>
<li><a href="#_处理时间">3.4.2. 处理时间</a></li>
<li><a href="#_事件时间">3.4.3. 事件时间</a></li>
<li><a href="#_水位线watermarks">3.4.4. 水位线（Watermarks）</a></li>
<li><a href="#_处理时间_vs_事件时间">3.4.5. 处理时间 vs 事件时间</a></li>
</ul>
</li>
<li><a href="#_状态和持久化模型">3.5. 状态和持久化模型</a>
<ul class="sectlevel3">
<li><a href="#_任务失败">3.5.1. 任务失败</a>
<ul class="sectlevel4">
<li><a href="#_什么是任务失败">什么是任务失败？</a></li>
<li><a href="#_结果的保证">结果的保证</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#_flink快速上手">4. Flink快速上手</a>
<ul class="sectlevel2">
<li><a href="#_使用maven搭建工程">4.1. 使用Maven搭建工程</a></li>
<li><a href="#_flink部署">4.2. Flink部署</a>
<ul class="sectlevel3">
<li><a href="#_下载hadoop_free版本的flink">4.2.1. 下载Hadoop Free版本的Flink</a></li>
<li><a href="#_解压缩">4.2.2. 解压缩</a></li>
<li><a href="#_启动flink集群">4.2.3. 启动Flink集群</a></li>
<li><a href="#_在浏览器中打开flink的web_ui">4.2.4. 在浏览器中打开Flink的Web UI</a></li>
<li><a href="#_打包编写好的streamingjob程序">4.2.5. 打包编写好的StreamingJob程序</a></li>
<li><a href="#_提交打包好的程序">4.2.6. 提交打包好的程序</a></li>
<li><a href="#_在flink_web_ui查看dashboard中job的执行状态">4.2.7. 在Flink Web UI查看Dashboard中job的执行状态</a></li>
<li><a href="#_停止flink集群">4.2.8. 停止Flink集群</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_flink运行架构">5. Flink运行架构</a>
<ul class="sectlevel2">
<li><a href="#_任务调度原理">5.1. 任务调度原理</a></li>
<li><a href="#_worker与slots">5.2. Worker与Slots</a></li>
<li><a href="#_程序与数据流">5.3. 程序与数据流</a></li>
<li><a href="#_并行数据流">5.4. 并行数据流</a></li>
<li><a href="#_task与operator_chains">5.5. task与operator chains</a></li>
<li><a href="#_系统架构">5.6. 系统架构</a>
<ul class="sectlevel3">
<li><a href="#_flink运行时组件">5.6.1. Flink运行时组件</a></li>
<li><a href="#_应用部署">5.6.2. 应用部署</a></li>
<li><a href="#_任务执行">5.6.3. 任务执行</a></li>
<li><a href="#_高可用配置">5.6.4. 高可用配置</a></li>
</ul>
</li>
<li><a href="#_flink中的数据传输">5.7. Flink中的数据传输</a>
<ul class="sectlevel3">
<li><a href="#_基于信任度credit的流控制">5.7.1. 基于信任度（credit）的流控制</a></li>
<li><a href="#_任务链task_chaining">5.7.2. 任务链（Task Chaining）</a></li>
</ul>
</li>
<li><a href="#_事件时间event_time处理">5.8. 事件时间（Event-Time）处理</a>
<ul class="sectlevel3">
<li><a href="#_时间戳timestamps">5.8.1. 时间戳（Timestamps）</a></li>
<li><a href="#_水位线watermarks_2">5.8.2. 水位线(Watermarks)</a></li>
<li><a href="#_watermark的传递和事件时间">5.8.3. watermark的传递和事件时间</a></li>
<li><a href="#_时间戳的分配和水位线的产生">5.8.4. 时间戳的分配和水位线的产生</a></li>
</ul>
</li>
<li><a href="#_状态管理">5.9. 状态管理</a>
<ul class="sectlevel3">
<li><a href="#_算子状态">5.9.1. 算子状态</a>
<ul class="sectlevel4">
<li><a href="#_列表状态list_state">列表状态（List state）</a></li>
<li><a href="#_联合列表状态union_list_state">联合列表状态（Union list state）</a></li>
<li><a href="#_广播状态broadcast_state">广播状态（Broadcast state）</a></li>
</ul>
</li>
<li><a href="#_键控状态keyed_state">5.9.2. 键控状态（Keyed State）</a>
<ul class="sectlevel4">
<li><a href="#_值状态value_state">值状态（Value state）</a></li>
<li><a href="#_列表状态list_state_2">列表状态（List state）</a></li>
<li><a href="#_映射状态map_state">映射状态（Map state）</a></li>
</ul>
</li>
<li><a href="#_状态后端state_backends">5.9.3. 状态后端（State Backends）</a></li>
<li><a href="#_调整有状态算子的并行度">5.9.4. 调整有状态算子的并行度</a></li>
</ul>
</li>
<li><a href="#_检查点保存点和状态恢复">5.10. 检查点，保存点和状态恢复</a>
<ul class="sectlevel3">
<li><a href="#_一致的检查点checkpoints">5.10.1. 一致的检查点（Checkpoints）</a></li>
<li><a href="#_从一致检查点中恢复状态">5.10.2. 从一致检查点中恢复状态</a></li>
<li><a href="#_flink的检查点算法">5.10.3. Flink的检查点算法</a></li>
<li><a href="#_检查点的性能影响">5.10.4. 检查点的性能影响</a></li>
<li><a href="#_保存点savepoints">5.10.5. 保存点（Savepoints）</a>
<ul class="sectlevel4">
<li><a href="#_使用保存点">使用保存点</a></li>
<li><a href="#_从保存点启动应用程序">从保存点启动应用程序</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#_flink_datastream_api">6. Flink DataStream API</a>
<ul class="sectlevel2">
<li><a href="#_environment">6.1. Environment</a></li>
<li><a href="#_source">6.2. Source</a></li>
<li><a href="#_basic_transformations基本转换算子">6.3. Basic Transformations(基本转换算子)</a>
<ul class="sectlevel3">
<li><a href="#_map">6.3.1. map</a></li>
<li><a href="#_flatmap">6.3.2. flatMap</a></li>
<li><a href="#_filter">6.3.3. Filter</a></li>
</ul>
</li>
<li><a href="#_keyedstream_transformations键控流转换算子">6.4. KeyedStream Transformations(键控流转换算子)</a>
<ul class="sectlevel3">
<li><a href="#_keyby">6.4.1. keyBy</a></li>
<li><a href="#_rolling_aggregations">6.4.2. Rolling Aggregations</a></li>
<li><a href="#_reduce">6.4.3. Reduce</a></li>
</ul>
</li>
<li><a href="#_multistream_transformations多流转换算子">6.5. Multistream Transformations(多流转换算子)</a>
<ul class="sectlevel3">
<li><a href="#_union">6.5.1. Union</a></li>
<li><a href="#_connect_comap_and_coflatmap">6.5.2. Connect, Comap and Coflatmap</a></li>
<li><a href="#_split_and_select">6.5.3. Split and Select</a></li>
</ul>
</li>
<li><a href="#_支持的数据类型">6.6. 支持的数据类型</a>
<ul class="sectlevel3">
<li><a href="#_primitives基础数据类型">6.6.1. Primitives(基础数据类型)</a></li>
<li><a href="#_tuples">6.6.2. Tuples</a></li>
<li><a href="#_scala_case_classes">6.6.3. Scala case classes</a></li>
<li><a href="#_others">6.6.4. others</a></li>
</ul>
</li>
<li><a href="#_keyby相关用法">6.7. keyBy相关用法</a></li>
<li><a href="#_实现udf函数更细粒度的控制流">6.8. 实现UDF函数，更细粒度的控制流</a>
<ul class="sectlevel3">
<li><a href="#_function_classes">6.8.1. Function Classes</a></li>
<li><a href="#_lambda_functions">6.8.2. Lambda Functions</a></li>
<li><a href="#_rich_functions">6.8.3. Rich Functions</a></li>
</ul>
</li>
<li><a href="#_sink">6.9. Sink</a>
<ul class="sectlevel3">
<li><a href="#_elasticsearch">6.9.1. Elasticsearch</a></li>
</ul>
</li>
<li><a href="#_distribution_transformations分布式转换算子">6.10. Distribution Transformations(分布式转换算子)</a></li>
</ul>
</li>
<li><a href="#_time与window">7. Time与Window</a>
<ul class="sectlevel2">
<li><a href="#_time">7.1. Time</a></li>
<li><a href="#_window">7.2. Window</a>
<ul class="sectlevel3">
<li><a href="#_window概述">7.2.1. Window概述</a></li>
<li><a href="#_window类型">7.2.2. Window类型</a></li>
</ul>
</li>
<li><a href="#_window_api">7.3. Window API</a></li>
</ul>
</li>
<li><a href="#_event_time与window">8. Event Time与Window</a>
<ul class="sectlevel2">
<li><a href="#_configure_time_characteristic">8.1. Configure Time Characteristic</a>
<ul class="sectlevel3">
<li><a href="#_event_time的引入">8.1.1. Event Time的引入</a></li>
<li><a href="#_watermark">8.1.2. Watermark</a>
<ul class="sectlevel4">
<li><a href="#_基本概念">基本概念</a></li>
</ul>
</li>
<li><a href="#_watermark的引入">8.1.3. Watermark的引入</a></li>
</ul>
</li>
<li><a href="#_process_functionlow_level_api">8.2. Process Function(Low-Level API)</a>
<ul class="sectlevel3">
<li><a href="#_timerservice_and_timers">8.2.1. TimerService and Timers</a></li>
<li><a href="#_emitting_to_side_outputs侧输出">8.2.2. Emitting to Side Outputs(侧输出)</a></li>
<li><a href="#_coprocessfunction">8.2.3. CoProcessFunction</a></li>
</ul>
</li>
<li><a href="#_window_operators窗口操作符">8.3. Window Operators(窗口操作符)</a>
<ul class="sectlevel3">
<li><a href="#_define_window_operators定义窗口操作符">8.3.1. define window operators(定义窗口操作符)</a></li>
<li><a href="#_内置的window_assigner窗口分配器">8.3.2. 内置的window assigner(窗口分配器)</a>
<ul class="sectlevel4">
<li><a href="#_tumbling_windows滚动窗口">tumbling windows(滚动窗口)</a></li>
<li><a href="#_sliding_window滑动窗口">sliding window(滑动窗口)</a></li>
<li><a href="#_session_windows会话窗口">session windows(会话窗口)</a></li>
</ul>
</li>
<li><a href="#_applying_functions_on_windows在窗口上应用函数">8.3.3. Applying Functions on Windows(在窗口上应用函数)</a>
<ul class="sectlevel4">
<li><a href="#_reducefunction">ReduceFunction</a></li>
<li><a href="#_aggregatefunction">AggregateFunction</a></li>
<li><a href="#_processwindowfunction">ProcessWindowFunction</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_自定义窗口操作符windows_operators">8.4. 自定义窗口操作符(windows operators)</a></li>
<li><a href="#_窗口生命周期">8.5. 窗口生命周期</a></li>
<li><a href="#_窗口分配器window_assigners">8.6. 窗口分配器(window assigners)</a></li>
<li><a href="#_触发器triggers">8.7. 触发器(Triggers)</a></li>
<li><a href="#_evictors">8.8. EVICTORS</a></li>
<li><a href="#_处理迟到的元素handling_late_data">8.9. 处理迟到的元素(Handling Late Data)</a>
<ul class="sectlevel3">
<li><a href="#_抛弃迟到元素">8.9.1. 抛弃迟到元素</a></li>
<li><a href="#_重定向迟到元素">8.9.2. 重定向迟到元素</a></li>
<li><a href="#_使用迟到元素更新窗口计算结果updating_results_by_including_late_events">8.9.3. 使用迟到元素更新窗口计算结果(Updating Results by Including Late Events)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_有状态的计算">9. 有状态的计算</a>
<ul class="sectlevel2">
<li><a href="#_一致性">9.1. 一致性</a></li>
<li><a href="#_检查点_保证exactly_once">9.2. 检查点: 保证exactly-once</a></li>
<li><a href="#_stateful_operators_and_applications">9.3. Stateful Operators and Applications</a>
<ul class="sectlevel3">
<li><a href="#_实现stateful_functions">9.3.1. 实现stateful functions</a>
<ul class="sectlevel4">
<li><a href="#_在runtimecontext中声明keyed_state">在RuntimeContext中声明Keyed State</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_使用listcheckpointed接口来实现操作符的列表状态list_state">9.4. 使用ListCheckpointed接口来实现操作符的列表状态(List State)</a></li>
<li><a href="#_使用连接的广播状态using_connected_broadcast_state">9.5. 使用连接的广播状态(using connected broadcast state)</a></li>
<li><a href="#_状态存储恢复和清理">9.6. 状态存储，恢复和清理</a>
<ul class="sectlevel3">
<li><a href="#_配置检查点">9.6.1. 配置检查点</a></li>
<li><a href="#_指定唯一的操作符标识符operator_identifiers">9.6.2. 指定唯一的操作符标识符(operator identifiers)</a></li>
<li><a href="#_指定操作符的最大并行度">9.6.3. 指定操作符的最大并行度</a></li>
<li><a href="#_防止状态泄露">9.6.4. 防止状态泄露</a></li>
<li><a href="#_选择一个状态后端">9.6.5. 选择一个状态后端</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_从外部系统读取以及写入外部系统">10. 从外部系统读取以及写入外部系统</a>
<ul class="sectlevel2">
<li><a href="#_应用的一致性保证">10.1. 应用的一致性保证</a>
<ul class="sectlevel3">
<li><a href="#_幂等性写入">10.1.1. 幂等性写入</a></li>
<li><a href="#_事务性写入">10.1.2. 事务性写入</a></li>
</ul>
</li>
<li><a href="#_flink提供的连接器">10.2. Flink提供的连接器}</a>
<ul class="sectlevel3">
<li><a href="#_apache_kafka_source连接器">10.2.1. Apache Kafka Source连接器</a></li>
<li><a href="#_apache_kafka_sink连接器">10.2.2. Apache Kafka Sink连接器</a></li>
<li><a href="#_kakfa_sink的at_least_once保证">10.2.3. Kakfa Sink的at-least-once保证</a></li>
<li><a href="#_kafka_sink的恰好处理一次语义保证">10.2.4. Kafka Sink的恰好处理一次语义保证</a></li>
<li><a href="#_文件系统source连接器">10.2.5. 文件系统source连接器</a></li>
<li><a href="#_文件系统sink连接器">10.2.6. 文件系统sink连接器</a></li>
</ul>
</li>
<li><a href="#_实现自定义源函数">10.3. 实现自定义源函数</a>
<ul class="sectlevel3">
<li><a href="#_可重置的源函数">10.3.1. 可重置的源函数</a></li>
</ul>
</li>
<li><a href="#_实现自定义sink函数">10.4. 实现自定义sink函数</a>
<ul class="sectlevel3">
<li><a href="#_幂等sink连接器">10.4.1. 幂等sink连接器</a></li>
<li><a href="#_事务性sink连接器">10.4.2. 事务性sink连接器</a>
<ul class="sectlevel4">
<li><a href="#_genericwriteaheadsink">GENERICWRITEAHEADSINK</a></li>
<li><a href="#_twophasecommitsinkfunction">TWOPHASECOMMITSINKFUNCTION</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#_flink_cep简介">11. Flink CEP简介</a></li>
<li><a href="#_尚硅谷大数据技术之电商用户行为分析">12. 尚硅谷大数据技术之电商用户行为分析</a>
<ul class="sectlevel2">
<li><a href="#_项目整体介绍">12.1. 项目整体介绍</a>
<ul class="sectlevel3">
<li><a href="#_电商的用户行为">12.1.1. 电商的用户行为</a></li>
<li><a href="#_项目主要模块">12.1.2. 项目主要模块</a></li>
<li><a href="#_数据源解析">12.1.3. 数据源解析</a></li>
</ul>
</li>
<li><a href="#_实时热门商品统计">12.2. 实时热门商品统计</a>
<ul class="sectlevel3">
<li><a href="#_创建maven项目">12.2.1. 创建Maven项目</a>
<ul class="sectlevel4">
<li><a href="#_项目框架搭建">项目框架搭建</a></li>
<li><a href="#_声明项目中工具的版本信息">声明项目中工具的版本信息</a></li>
<li><a href="#_添加项目依赖">添加项目依赖</a></li>
<li><a href="#_数据准备">数据准备</a></li>
</ul>
</li>
<li><a href="#_模块代码实现">12.2.2. 模块代码实现</a></li>
<li><a href="#_程序主体">12.2.3. 程序主体</a></li>
<li><a href="#_过滤出点击事件">12.2.4. 过滤出点击事件</a></li>
<li><a href="#_设置滑动窗口统计点击量">12.2.5. 设置滑动窗口，统计点击量</a>
<ul class="sectlevel4">
<li><a href="#_计算最热门top_n商品">计算最热门Top N商品</a></li>
<li><a href="#_完整代码">完整代码</a></li>
<li><a href="#_更换kafka作为数据源">更换Kafka作为数据源</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_实时流量统计">12.3. 实时流量统计</a>
<ul class="sectlevel3">
<li><a href="#_模块创建和数据准备">12.3.1. 模块创建和数据准备</a></li>
<li><a href="#_代码实现">12.3.2. 代码实现</a></li>
</ul>
</li>
<li><a href="#_uv统计的布隆过滤器实现">12.4. Uv统计的布隆过滤器实现</a></li>
<li><a href="#_app分渠道数据统计">12.5. APP分渠道数据统计</a></li>
<li><a href="#_app不分渠道数据统计">12.6. APP不分渠道数据统计</a></li>
<li><a href="#_恶意登陆课堂实现">12.7. 恶意登陆课堂实现</a></li>
<li><a href="#_恶意登录监控">12.8. 恶意登录监控</a>
<ul class="sectlevel3">
<li><a href="#_模块创建和数据准备_2">12.8.1. 模块创建和数据准备</a></li>
<li><a href="#_代码实现_2">12.8.2. 代码实现</a>
<ul class="sectlevel4">
<li><a href="#_状态编程">状态编程</a></li>
<li><a href="#_cep编程">CEP编程</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_订单支付实时监控">12.9. 订单支付实时监控</a>
<ul class="sectlevel3">
<li><a href="#_模块创建和数据准备_3">12.9.1. 模块创建和数据准备</a></li>
<li><a href="#_代码实现_3">12.9.2. 代码实现</a></li>
<li><a href="#_使用process_function实现订单超时需求">12.9.3. 使用Process Function实现订单超时需求</a></li>
</ul>
</li>
<li><a href="#_实现两条流的join">12.10. 实现两条流的join</a></li>
</ul>
</li>
<li><a href="#_dataflow模型">13. Dataflow模型</a>
<ul class="sectlevel2">
<li><a href="#_摘要">13.1. 摘要</a></li>
<li><a href="#_简介">13.2. 简介</a>
<ul class="sectlevel3">
<li><a href="#_无边界有边界与流处理批处理">13.2.1. 无边界、有边界与流处理、批处理</a></li>
<li><a href="#_窗口">13.2.2. 窗口</a></li>
<li><a href="#_时间域">13.2.3. 时间域</a></li>
</ul>
</li>
<li><a href="#_dataflow模型_2">13.3. DataFlow模型</a>
<ul class="sectlevel3">
<li><a href="#_核心编程模型">13.3.1. 核心编程模型</a></li>
<li><a href="#_窗口_2">13.3.2. 窗口</a>
<ul class="sectlevel4">
<li><a href="#_窗口分配">窗口分配</a></li>
<li><a href="#_窗口合并">窗口合并</a></li>
<li><a href="#_api">API</a></li>
</ul>
</li>
<li><a href="#_触发器和增量处理">13.3.3. 触发器和增量处理</a></li>
</ul>
</li>
<li><a href="#_实现和设计">13.4. 实现和设计</a>
<ul class="sectlevel3">
<li><a href="#_实现">13.4.1. 实现</a></li>
<li><a href="#_设计原则">13.4.2. 设计原则</a></li>
<li><a href="#_业务场景">13.4.3. 业务场景</a>
<ul class="sectlevel4">
<li><a href="#_大规模数据回写和lambda架构统一模型">大规模数据回写和Lambda架构；统一模型</a></li>
<li><a href="#_非对齐窗口会话">非对齐窗口：会话</a></li>
<li><a href="#_支付触发器累加和撤回">支付：触发器，累加和撤回</a></li>
<li><a href="#_统计计算水位线触发器">统计计算：水位线触发器</a></li>
<li><a href="#_推荐处理时间触发器">推荐：处理时间触发器</a></li>
<li><a href="#_异常探测数据驱动和组合触发器">异常探测：数据驱动和组合触发器</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_总结">13.5. 总结</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="imageblock">
<div class="content">
<img src="images/atguigu.jpg" alt="atguigu" width="300" height="200">
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_flink简介">1. Flink简介</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_初识flink">1.1. 初识Flink</h3>
<div class="paragraph">
<p>Flink起源于Stratosphere项目，Stratosphere是在2010～2014年由3所地处柏林的大学和欧洲的一些其他的大学共同进行的研究项目，2014年4月Stratosphere的代码被复制并捐赠给了Apache软件基金会，参加这个孵化项目的初始成员是Stratosphere系统的核心开发人员，2014年12月，Flink一跃成为Apache软件基金会的顶级项目。</p>
</div>
<div class="paragraph">
<p>在德语中，Flink一词表示快速和灵巧，项目采用一只松鼠的彩色图案作为logo，这不仅是因为松鼠具有快速和灵巧的特点，还因为柏林的松鼠有一种迷人的红棕色，而Flink的松鼠logo拥有可爱的尾巴，尾巴的颜色与Apache软件基金会的logo颜色相呼应，也就是说，这是一只Apache风格的松鼠。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/flink-header-logo.png" alt="flink header logo">
</div>
<div class="title">Figure 1. apache flink logo</div>
</div>
<div class="paragraph">
<p>Flink主页在其顶部展示了该项目的理念: "<span class="red">Apache Flink是为分布式、高性能、随时可用以及准确的流处理应用程序打造的开源流处理框架</span>"。</p>
</div>
<div class="paragraph">
<p>Apache Flink是一个框架和分布式处理引擎，<span class="red">用于对无界和有界数据流进行有状态计算</span>。Flink被设计在所有常见的集群环境中运行，以内存执行速度和任意规模来执行计算。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/flink-home-graphic.png" alt="flink home graphic">
</div>
</div>
<div class="paragraph">
<p>Flink几大模块</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Flink Table &amp; SQL(还没开发完)</p>
</li>
<li>
<p>Flink Gelly(图计算)</p>
</li>
<li>
<p>Flink CEP(复杂事件处理)</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_为什么选择flink">1.2. 为什么选择Flink</h3>
<div class="paragraph">
<p>许多系统都会产生连续的事件流，如行驶中的汽车发射出GPS信号，金融交易，移动通信基站与繁忙的智能手机进行信号交换，网络流量，机器日志，工业传感器和可穿戴设备的测量结果，等等。如果能够高效地分析大规模流数据，我们对上述系统的理解将会更清楚、更快速。简而言之，流数据更真实地反映了我们的生活方式。</p>
</div>
<div class="paragraph">
<p>实际上，企业常见的数据架构仍旧假设数据是有头有尾的有限集。这个假设存在的大部分原因在于，与有限集匹配的数据存储及处理系统建起来比较简单。但是，这样做无疑给那些天然的流式场景人为地加了限制。</p>
</div>
<div class="paragraph">
<p>我们渴望按照流的方式处理数据，但要做好很困难; 随着大规模数据在各行各业中出现，难度越来越大。这是一个属于物理学范畴的难题: 在大型分布式系统中，数据一致性和对事件发生顺序的理解必然都是有限的。</p>
</div>
<div class="paragraph">
<p>而Flink为大容量数据提供流处理，并用同一种技术实现批处理。</p>
</div>
<div class="sect3">
<h4 id="_流处理欠佳的后果">1.2.1. 流处理欠佳的后果</h4>
<div class="paragraph">
<p>谁需要和流数据打交道呢? 首先映入脑海的是从事传感器测量和金融交易的工作人员。对于他们来说，流处理非常有用。但是流数据来源非常广泛，两个常见的例子是: 网站获得的能够反映用户行为的点击流数据，以及私有数据中心的机器日志。事实上，流数据来源无处不在，但是从连续事件中获得数据并不意味着可以在批量计算中使用这些数据。如今，处理大规模流数据的新技术正在改变这一状况。</p>
</div>
<div class="sect4">
<h5 id="_零售业和市场营销">零售业和市场营销</h5>
<div class="paragraph">
<p>在现代零售业中，网站点击量就代表了销量。网站获得的点击数据可能是大量、连续、不均匀的。用以往的技术很难处理好如此规模的数据。仅是构建批量系统处理这些数据流就很有挑战性: 结果很可能是需要一个庞大且复杂的系统。并且，传统的做法还会带来数据丢失、延迟、错误的聚合结果等问题。这样的结果怎能对商业领域有所帮助呢?</p>
</div>
<div class="paragraph">
<p>假设你正在向首席执行官汇报上一季度的销售数据，你肯定不想事后因为使用了不准确的数据而不得不向首席执行官更正汇报结果。如果不能良好地处理点击数据，你很可能对网站点击量进行不准确的计算，这将导致广告投放报价和业绩数字不准确。</p>
</div>
<div class="paragraph">
<p>航空旅客服务业面临同样的挑战: 航空公司需要快速、准确地处理从各种渠道获得的大量数据。例如，当为一名旅客办理登机手续时，需要对该旅客的机票预订数据进行核对，还需要核对行李处理信息、航班状态信息和账单信息。如果没有强大的技术来支持流处理，这种规模的数据是很难不出错的。近几年，美国四大航空公司中有三家都出现了大面积的服务中断，这几次故障都可以归咎于大规模实时数据处理失败。</p>
</div>
<div class="paragraph">
<p>当然，很多相关问题(如怎样避免重复预订酒店或演唱会门票)，一般都能够通过有效的数据库操作来解决，但是这种操作相当费钱，也费精力。尤其当数据量增加时，成本会飙升，并且在某些情况下，数据库的反应速度会变得特别慢。由于缺乏灵活性，开发速度受到影响，项目在庞大又复杂或者不断发生变化的系统中进展缓慢。想要在大型系统中处理流数据，并且在保持一致性的同时有效地控制成本，难度非常大。</p>
</div>
<div class="paragraph">
<p>幸运的是，现代的流处理器经常可以用新的方式解决这些问题，这使得实时处理大规模数据的成本更低。流处理还激发了新的尝试，比如构建一个系统，该系统能够基于顾客当下购买的商品实时给出相关的建议，看看他们是否还需要买一些别的商品。这不代表流处理器替代了数据库(远远不能替代)，而是说在数据库处理不好时，流处理器提供了更好的解决方案。这样做也使数据库得以解脱，不用再参与对当前业务状态的实时分析。</p>
</div>
</div>
<div class="sect4">
<h5 id="_物联网">物联网</h5>
<div class="paragraph">
<p>物联网是流数据被普遍应用的领域。在物联网中，低延迟的数据传输和处理，以及准确的数据分析通常很关键。各类仪器中的传感器频繁地获得测量数据，并将它们以流的形式传输至数据中心。在数据中心内，实时或者接近实时的应用程序将更新显示板，运行机器学习模型，发布警告，并就许多不同的服务项目提供反馈。</p>
</div>
<div class="paragraph">
<p>交通运输业也体现了流处理的重要性。举例来说，先进的列车系统依靠的是传感器测量数据，这些数据从轨道传至列车，再从列车传至沿途的传感器; 与此同时，报告也被发送回控制中心。测量数据包括列车的速度和位置，以及轨道周边的状况。如果流数据没有被正确处理，调整意见和警告就不能相应产生，从而也就不能通过对危险状况做出反应来避免事故发生。</p>
</div>
<div class="paragraph">
<p>另一个例子是"智能"汽车，或称联网汽车，它们通过移动网络将数据传输回制造商。在有些国家(北欧国家、法国和英国，美国则刚开始)，联网汽车甚至可以将信息传给保险公司; 如果是赛车，信息还可以通过射频链路传送至维修站进行分析。此外，一些智能手机应用程序还支持数百万司机共享实时路况信息。</p>
</div>
<div class="paragraph">
<p>物联网对公用事业也有影响。相关公司已经开始安装智能计量表，以替换每个月需要人工读数的旧表。智能计量表可以定期将用电量反馈给公司(例如每15分钟一次)。有些公司正在尝试每30秒就进行一次测量。使用智能计量表的这一转变带来了大量的流数据，同时也获得了大量的潜在收益。其中一个好处就是通过机器学习模型来检测设备故障或者窃电等使用异常。如果不能对流数据进行高吞吐、低延迟和准确的处理，这些新的目标都无法实现。</p>
</div>
<div class="paragraph">
<p>如果流处理做得不好，其他物联网项目也会遭殃。大型设备，比如风力涡轮机、生产设备和钻井泵，都依赖对传感器测量数据的分析来获得故障警告。如果不能及时地处理好这些设备的流数据，将可能付出高昂的代价，甚至导致灾难性后果。</p>
</div>
</div>
<div class="sect4">
<h5 id="_电信业">电信业</h5>
<div class="paragraph">
<p>电信业是一个特殊的例子，它广泛地应用了基于各种目的而产生的跨地域的事件流数据。如果电信公司不能很好地处理流数据，就不能在某个移动通信基站出现流量高峰前预先将流量分配给其他的基站，也不能在断电时快速做出反应。通过处理流数据来进行异常检测，如检测通话中断或者设备故障，对于电信业来说至关重要。</p>
</div>
</div>
<div class="sect4">
<h5 id="_银行和金融业">银行和金融业</h5>
<div class="paragraph">
<p>因为流处理做得不好而给银行以及金融业带来的潜在问题是极其显著的。从事零售业务的银行不希望客户交易被延迟或者因为错误统计而造成账户余额出错。曾有一个说法叫作"银行家工作时间"，指的就是银行需要在下午早早关门进行结算，这样才能保证第二天营业之前算出准确的账。这种批量作业的营业模式早已消失。如今，交易和报表都必须快速且准确地生成; 有些新兴的银行甚至提供实时的推送通知，以及随时随地访问手机银行的服务。在全球化经济中，能够提供24小时服务变得越来越重要。</p>
</div>
<div class="paragraph">
<p>那么，如果缺少能够灵敏地实时检测出用户行为异常的应用程序，会对金融机构带来什么后果呢? 信用卡欺诈检测需要及时的监控和反馈。对异常登录的检测能发现钓鱼式攻击，从而避免巨大的损失。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_连续事件处理的目标">1.2.2. 连续事件处理的目标</h4>
<div class="paragraph">
<p>能够以非常低的延迟处理数据，这并不是流处理的唯一优势。人们希望流处理不仅做到低延迟和高吞吐，还可以处理中断。优秀的流处理技术应该能使系统在崩溃之后重新启动，并且产出准确的结果; 换句话说，优秀的流处理技术可以容错，而且能保证exactly-once。</p>
</div>
<div class="paragraph">
<p>与此同时，获得这种程度的容错性所采用的技术还需要在没有数据错误的情况下不产生太大的开销。这种技术需要能够基于事件发生的时间(而不是随意地设置处理间隔)来保证按照正确的顺序跟踪事件。对于开发人员而言，不论是写代码还是修正错误，系统都要容易操作和维护。同样重要的是，系统生成的结果需要与事件实际发生的顺序一致，比如能够处理乱序事件流(一个很不幸但无法避免的事实)，以及能够准确地替换流数据(在审计或者调试时很有用)。</p>
</div>
</div>
<div class="sect3">
<h4 id="_流处理技术的演变">1.2.3. 流处理技术的演变</h4>
<div class="paragraph">
<p>分开处理连续的实时数据和有限批次的数据，可以使系统构建工作变得更加简单，但是这种做法将管理两套系统的复杂性留给了系统用户: 应用程序的开发团队和DevOps团队需要自己使用并管理这两套系统。</p>
</div>
<div class="paragraph">
<p>为了处理这种情况，有些用户开发出了自己的流处理系统。在开源世界里，Apache Storm项目(以下简称Storm)是流处理先锋。Storm提供了低延迟的流处理，但是它为实时性付出了一些代价: 很难实现高吞吐，并且其正确性没能达到通常所需的水平。换句话说，它并不能保证exactly-once; 即便是它能够保证的正确性级别，其开销也相当大。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
若要依靠多个流事件来计算结果，必须将数据从一个事件保留到下一个事件。这些保存下来的数据叫作计算的状态。准确处理状态对于计算结果的一致性至关重要。在故障或中断之后能够继续准确地更新状态是容错的关键。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>在低延迟和高吞吐的流处理系统中维持良好的容错性是非常困难的，但是为了得到有保障的准确状态，人们想出了一种替代方法: 将连续事件中的流数据分割成一系列微小的批量作业。如果分割得足够小(即所谓的微批处理作业)，计算就几乎可以实现真正的流处理。因为存在延迟，所以不可能做到完全实时，但是每个简单的应用程序都可以实现仅有几秒甚至几亚秒的延迟。这就是在Spark批处理引擎上运行的Apache Spark Streaming所使用的方法。</p>
</div>
<div class="paragraph">
<p>更重要的是，使用微批处理方法，可以实现exactly-once语义，从而保障状态的一致性。如果一个微批处理作业失败了，它可以重新运行。这比连续的流处理方法更容易。Storm Trident是对Storm的延伸，它的底层流处理引擎就是基于微批处理方法来进行计算的，从而实现了exactly-once语义，但是在延迟性方面付出了很大的代价。</p>
</div>
<div class="paragraph">
<p>然而，通过间歇性的批处理作业来模拟流处理，会导致开发和运维相互交错。完成间歇性的批处理作业所需的时间和数据到达的时间紧密耦合，任何延迟都可能导致不一致(或者说错误)的结果。这种技术的潜在问题是，时间由系统中生成小批量作业的那一部分全权控制。Spark Streaming等一些流处理框架在一定程度上弱化了这一弊端，但还是不能完全避免。另外，使用这种方法的计算有着糟糕的用户体验，尤其是那些对延迟比较敏感的作业，而且人们需要在写业务代码时花费大量精力来提升性能。</p>
</div>
<div class="paragraph">
<p>为了实现理想的功能，人们继续改进已有的处理器(比如Storm Trident的开发初衷就是试图克服Storm的局限性)。当已有的处理器不能满足需求时，产生的各种后果则必须由应用程序开发人员面对和解决。以微批处理方法为例，人们往往期望根据实际情况分割事件数据，而处理器只能根据批量作业时间(恢复间隔)的倍数进行分割。当灵活性和表现力都缺乏的时候，开发速度变慢，运维成本变高。</p>
</div>
<div class="paragraph">
<p>于是，Flink出现了。这一数据处理器可以避免上述弊端，并且拥有所需的诸多功能，还能按照连续事件高效地处理数据。Flink 的一些功能如下图所示。</p>
</div>
<div class="paragraph">
<p>与Storm和Spark Streaming类似，其他流处理技术同样可以提供一些有用的功能，但是没有一个像Flink那样功能如此齐全。举例来说，Apache Samza(以下简称Samza)是早期的一个开源流处理器，它不仅没能实现exactly-once语义，而且只能提供底层的API; 同样，Apache Apex提供了与Flink相同的一些功能，但不全面(比如只提供底层的API，不支持事件时间，也不支持批量计算)。这些项目没有一个能和Flink在开源社区的规模上相提并论。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/flinkvsother.png" alt="flinkvsother">
</div>
</div>
<div class="paragraph">
<p>Flink的一个优势是，它拥有诸多重要的流式计算功能。其他项目为了实现这些功能，都不得不付出代价。比如，Storm实现了低延迟，但是做不到高吞吐，也不能在故障发生时准确地处理计算状态; Spark Streaming通过采用微批处理方法实现了高吞吐和容错性，但是牺牲了低延迟和实时处理能力，也不能使窗口与自然时间相匹配，并且表现力欠佳。</p>
</div>
<div class="paragraph">
<p><strong>Spark Streaming</strong> vs <strong>Flink</strong></p>
</div>
<div class="paragraph">
<p><strong>两者最重要的区别(流和微批)</strong></p>
</div>
<div class="paragraph">
<p>(1). Micro Batching 模式(spark)</p>
</div>
<div class="paragraph">
<p>Micro-Batching计算模式认为"流是批的特例"，流计算就是将连续不断的批进行持续计算，如果批足够小那么就有足够小的延时，在一定程度上满足了99%的实时计算场景。那么那1%为啥做不到呢? 这就是架构的魅力，在Micro-Batching模式的架构实现上就有一个自然流数据流入系统进行攒批的过程，这在一定程度上就增加了延时。具体如下示意图：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/sparkstreamingvsflink1.png" alt="sparkstreamingvsflink1">
</div>
</div>
<div class="paragraph">
<p>从上面可以看到是把输入的数据, 分成微小的批次, 然后一个批次一个批次的处理, 然后也是一片批次的输出. 很显然Micro-Batching模式有其天生的低延时瓶颈，但任何事物的存在都有两面性，在大数据计算的发展历史上，最初Hadoop上的MapReduce就是优秀的批模式计算框架，Micro-Batching在设计和实现上可以借鉴很多成熟实践。</p>
</div>
<div class="paragraph">
<p>(2). Native Streaming 模式(flink)</p>
</div>
<div class="paragraph">
<p>Native Streaming计算模式认为批是流的特例"，这个认知更贴切流的概念，比如一些监控类的消息流，数据库操作的binlog，实时的支付交易信息等等自然流数据都是一条，一条的流入。Native Streaming计算模式每条数据的到来都进行计算，这种计算模式显得更自然，并且延时性能达到更低。具体如下示意图：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/sparkstreamingvsflink2.png" alt="sparkstreamingvsflink2">
</div>
</div>
<div class="paragraph">
<p>从上图可以看到输入的数据过来一条处理一条, 然后输出, 几乎不存在延迟, 很明显Native Streaming模式占据了流计算领域"低延时"的核心竞争力, 当然Native Streaming模式的实现框架是一个历史先河，第一个实现Native Streaming模式的流计算框架是第一个吃螃蟹的人，需要面临更多的挑战，后续章节我们会慢慢介绍。当然Native Streaming模式的框架实现上面很容易实现Micro-Batching和Batching模式的计算，Apache Flink就是Native Streaming计算模式的流批统一的计算引擎。</p>
</div>
<div class="paragraph">
<p><strong>数据模型</strong></p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/shujumoxing1.jpg" alt="shujumoxing1">
</div>
</div>
<div class="paragraph">
<p>Spark最早采用RDD模型，达到比MapReduce计算快100倍的显著优势，对Hadoop生态大幅升级换代。RDD弹性数据集是分割为固定大小的批数据，RDD提供了丰富的底层API对数据集做操作。为持续降低使用门槛，Spark社区开始开发高阶API：DataFrame/DataSet，Spark SQL作为统一的API，掩盖了底层，同时针对性地做SQL逻辑优化和物理优化，非堆存储优化也大幅提升了性能。</p>
</div>
<div class="paragraph">
<p>Spark Streaming里的DStream和RDD模型类似，把一个实时进来的无限数据分割为一个个小批数据集合DStream，定时器定时通知处理系统去处理这些微批数据。劣势非常明显，API少、难胜任复杂的流计算业务，调大吞吐量而不触发背压是个体力活。不支持乱序处理，或者说很难处理乱序的问题。Spark Streaming仅适合简单的流处理，这里稍微解释一下，因为Spark的创始人在当时认为延迟不是那么的重要，他认为现实生活中没有那么多低延迟的应用场景，所以就没太注重延迟的问题，但是随着生活多样化场景的不断增加，对实时性的要求越来越高，所以Spark也注意到了这个问题，开始在延迟方面发力，进而推出了Structured Streaming，相信很快Spark Streaming就会被Structured Streaming替代掉。</p>
</div>
<div class="paragraph">
<p>Spark Structured Streaming提供了微批和流式两个处理引擎。微批的API虽不如Flink丰富，窗口、消息时间、trigger、watermarker、流表join、流流join这些常用的能力都具备了。时延仍然保持最小100毫秒。当前处在试验阶段的流式引擎，提供了1毫秒的时延，但不能保证exactly-once语义，支持at-least-once语义。同时，微批作业打了快照，作业改为流式模式重启作业是不兼容的。这一点不如Flink做的完美。当然了现在还在优化阶段.</p>
</div>
<div class="paragraph">
<p>综上，Spark Streaming和Structured Streaming是用批计算的思路做流计算。其实，用流计算的思路开发批计算才是最合理的。对Spark来讲，大换血不大可能，只有局部优化。其实，Spark里core、streaming、structured streaming、graphx四个模块，是四种实现思路，通过上层SQL统一显得不纯粹和谐。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/shujumoxing2.png" alt="shujumoxing2">
</div>
</div>
<div class="paragraph">
<p>Flink的基本数据模型是数据流，及事件(Event)的序列。数据流作为数据的基本模型可能没有表或者数据块直观熟悉，但是可以证明是完全等效的。流可以是无边界的无限流，即一般意义上的流处理。也可以是有边界的有限流，这样就是批处理。</p>
</div>
<div class="paragraph">
<p>Flink采用Dataflow模型，和Lambda模式不同。Dataflow是纯粹的节点组成的一个图，图中的节点可以执行批计算，也可以是流计算，也可以是机器学习算法，流数据在节点之间流动，被节点上的处理函数实时apply处理，节点之间是用netty连接起来，两个netty之间keepalive，网络buffer是自然反压的关键。经过逻辑优化和物理优化，Dataflow的逻辑关系和运行时的物理拓扑相差不大。这是纯粹的流式设计，时延和吞吐理论上是最优的。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/lambdaarch.png" alt="lambdaarch">
</div>
</div>
<div class="paragraph">
<p><strong>运行时架构</strong></p>
</div>
<div class="paragraph">
<p><strong>Spark运行时架构</strong></p>
</div>
<div class="paragraph">
<p>批计算是把DAG划分为不同stage，DAG节点之间有血缘关系，在运行期间一个stage的task任务列表执行完毕，销毁再去执行下一个stage；Spark Streaming则是对持续流入的数据划分一个批次，定时去执行批次的数据运算。Structured Streaming将无限输入流保存在状态存储中，对流数据做微批或实时的计算，跟Dataflow模型比较像。</p>
</div>
<div class="paragraph">
<p><strong>Flink运行时架构</strong></p>
</div>
<div class="paragraph">
<p>Flink有统一的runtime，在此之上可以是Batch API、Stream API、ML、Graph、CEP等，DAG中的节点上执行上述模块的功能函数，DAG会一步步转化成ExecutionGraph，即物理可执行的图，最终交给调度系统。节点中的逻辑在资源池中的task上被apply执行，task和Spark中的task类似，都对应线程池中的一个线程。</p>
</div>
<div class="paragraph">
<p>在DAG的执行上，Spark和Flink有一个比较显著的区别。在Flink的流执行模式中，一个事件在一个节点处理完后的输出就可以发到下一个节点立即处理。这样执行引擎并不会引入额外的延迟。与之相应的，所有节点是需要同时运行的。而Spark的micro batch和一般的batch执行一样，处理完上游的stage得到输出之后才开始下游的stage。</p>
</div>
<div class="paragraph">
<p>在流计算的运行时架构方面，Flink明显更为统一且优雅一些。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Lambda架构的问题是改变代码后需要重新在两个复杂的分布式系统中再次处理输出结果是非常痛苦的，而且我不认为这个问题能够解决。相当于同一套数据集的处理逻辑，使用Spark Core需要写一遍，使用Spark Streaming需要再写一遍，无法复用，这是致命缺陷。
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_flink的重要特点">1.3. Flink的重要特点</h3>
<div class="sect3">
<h4 id="_事件驱动型event_driven">1.3.1. 事件驱动型(Event-Driven)</h4>
<div class="paragraph">
<p>事件驱动型应用是一类具有状态的应用，它从一个或多个事件流提取数据，并根据到来的事件触发计算、状态更新或其他外部动作。比较典型的就是以Kafka为代表的消息队列几乎都是事件驱动型应用。</p>
</div>
<div class="paragraph">
<p>与之不同的就是Spark Streaming微批次，如图：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/streaming-flow.png" alt="streaming flow">
</div>
</div>
<div class="paragraph">
<p>事件驱动型：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/usecases-eventdrivenapps.png" alt="usecases eventdrivenapps">
</div>
</div>
</div>
<div class="sect3">
<h4 id="_流与批的世界观">1.3.2. 流与批的世界观</h4>
<div class="paragraph">
<p><strong>批处理</strong>的特点是有界、持久、大量，非常适合需要访问全套记录才能完成的计算工作，一般用于离线统计。</p>
</div>
<div class="paragraph">
<p><strong>流处理</strong>的特点是无界、实时，无需针对整个数据集执行操作，而是对通过系统传输的每个数据项执行操作，一般用于实时统计。</p>
</div>
<div class="paragraph">
<p>在Spark的世界观中，一切都是由批次组成的，离线数据是一个大批次，而实时数据是由一个一个无限的小批次组成的。</p>
</div>
<div class="paragraph">
<p>而在Flink的世界观中，一切都是由流组成的，离线数据是有界限的流，实时数据是一个没有界限的流，这就是所谓的有界流和无界流。</p>
</div>
<div class="paragraph">
<p><strong>无界数据流</strong>：无界数据流有一个开始但是没有结束，它们不会在生成时终止并提供数据，必须连续处理无界流，也就是说必须在获取后立即处理event。对于无界数据流我们无法等待所有数据都到达，因为输入是无界的，并且在任何时间点都不会完成。处理无界数据通常要求以特定顺序(例如事件发生的顺序)获取event，以便能够推断结果完整性。</p>
</div>
<div class="paragraph">
<p><strong>有界数据流</strong>：有界数据流有明确定义的开始和结束，可以在执行任何计算之前通过获取所有数据来处理有界流，处理有界流不需要有序获取，因为可以始终对有界数据集进行排序，有界流的处理也称为批处理。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/bounded-unbounded.png" alt="bounded unbounded">
</div>
</div>
<div class="paragraph">
<p><span class="red">这种以流为世界观的架构，获得的最大好处就是具有极低的延迟。</span></p>
</div>
</div>
<div class="sect3">
<h4 id="_分层api">1.3.3. 分层api</h4>
<div class="imageblock">
<div class="content">
<img src="images/api-stack.png" alt="api stack">
</div>
</div>
<div class="paragraph">
<p>最底层级的抽象仅仅提供了有状态流，它将通过在DataStream API中嵌入Process Function来处理数据。Process Function与DataStream API相集成，使其可以对某些特定的操作进行底层的抽象，它允许用户可以自由地处理来自一个或多个数据流的事件，并使用一致的容错的状态。除此之外，用户可以注册事件时间并处理时间回调，从而使程序可以处理复杂的计算。</p>
</div>
<div class="paragraph">
<p>实际上，大多数应用并不需要上述的底层抽象，而是针对核心API(Core APIs)进行编程，比如DataStream API(有界或无界流数据)以及DataSet API(有界数据集)。这些API为数据处理提供了通用的构建模块，比如由用户定义的多种形式的转换(transformations)，连接(joins)，聚合(aggregations)，窗口操作(window)等等。DataSet API为有界数据集提供了额外的支持，例如循环与迭代。这些API处理的数据类型以类(classes)的形式由各自的编程语言所表示。</p>
</div>
<div class="paragraph">
<p>Table API是以表为中心的声明式编程，其中表可能会动态变化(在表达流数据时)。Table API遵循(扩展的)关系模型：表有二维数据结构(schema)(类似于关系数据库中的表)，同时API提供与RDBMS相似的操作，例如select、project、join、group-by、aggregate等。Table API程序声明式地定义了什么逻辑操作应该执行，而不是准确地确定这些操作代码看上去如何(过程式编程风格)。尽管Table API可以通过多种类型的用户自定义函数(UDF)进行扩展，其仍不如核心API更具表达能力，但是使用起来却更加简洁(代码量更少)。除此之外，Table API程序在执行之前会经过内置优化器进行优化。</p>
</div>
<div class="paragraph">
<p>你可以在表与DataStream/DataSet之间无缝切换，以允许程序将Table API与DataStream以及DataSet混合使用。</p>
</div>
<div class="paragraph">
<p>Flink提供的最高层级的抽象是SQL。这一层抽象在语法与表达能力上与Table API类似，但是是以SQL查询表达式的形式表现程序。SQL抽象与Table API交互密切，同时SQL查询可以直接在Table API定义的表上执行。</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
目前Flink作为批处理还不是主流，不如Spark成熟，所以DataSet使用的并不是很多。Flink Table API和Flink SQL也并不完善，大多都由各大厂商自己定制。所以我们主要学习DataStream API的使用。实际上Flink作为最接近Google DataFlow模型的实现，是流批统一的观点，所以基本上使用DataStream就可以了。
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_有状态的流式处理简介">2. 有状态的流式处理简介</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Apache Flink是一个分布式流处理器，具有直观和富有表现力的API，可实现有状态的流处理应用程序。它以容错的方式有效地大规模运行这些应用程序。 Flink于2014年4月加入Apache软件基金会作为孵化项目，并于2015年1月成为顶级项目。从一开始，Flink就拥有一个非常活跃且不断增长的用户和贡献者社区。到目前为止，已有超过五百人为Flink做出贡献，并且它已经发展成为最复杂的开源流处理引擎之一，并得到了广泛采用的证明。 Flink为不同行业和全球的许多公司和企业提供大规模的商业关键应用。</p>
</div>
<div class="paragraph">
<p>流处理技术在大大小小的公司中越来越受欢迎，因为它为许多已建立的用例（如数据分析，ETL和事务应用程序）提供了卓越的解决方案，同时也促进了新颖的应用程序，软件架构和商机。接下来我们将讨论，为什么有状态流处理变得如此受欢迎并评估其潜力。我们首先回顾传统的数据应用程序架构并指出它们的局限性。接下来，我们介绍基于状态流处理的应用程序设计 与传统方法相比，它具有许多有趣的特征最后，我们简要讨论开源流处理器的发展，并在本地Flink实例上运行流应用程序。</p>
</div>
<div class="sect2">
<h3 id="_传统数据处理架构">2.1. 传统数据处理架构</h3>
<div class="paragraph">
<p>数十年来，数据和数据处理在企业中无处不在。多年来，数据的收集和使用一直在增长，公司已经设计并构建了基础架构来管理数据。大多数企业实施的传统架构区分了两种类型的数据处理：事务处理（OLTP）和分析处理（OLAP）。</p>
</div>
<div class="sect3">
<h4 id="_事务处理">2.1.1. 事务处理</h4>
<div class="paragraph">
<p>公司将各种应用程序用于日常业务活动，例如企业资源规划（ERP）系统，客户关系管理（CRM）软件和基于Web的应用程序。这些系统通常设计有单独的层，用于数据处理（应用程序本身）和数据存储（事务数据库系统），如图1-1所示。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/spaf_0101.png" alt="spaf 0101">
</div>
</div>
<div class="paragraph">
<p>应用程序通常连接到外部服务或直接面向用户，并持续处理传入的事件，如网站上的订单，电子邮件或点击。处理事件时，应用程序将会读取远程数据库的状态，或者通过运行事务来更新它。通常，一个数据库系统可以服务于多个应用程序，它们有时会访问相同的数据库或表。</p>
</div>
<div class="paragraph">
<p>当应用程序需要扩展时，这样的设计可能会导致问题。由于多个应用程序可能会同时用到相同的数据表示，或者共享相同的基础设施，因此想要更改表的结构或扩展数据库，就需要仔细的规划和大量的工作。克服紧耦合应用程序的最新方法是微服务设计模式。微服务被设计为小型、完备且独立的应用程序。他们遵循UNIX的理念，即“只做一件事并且把它做好”。通过将几个微服务相互连接来构建更复杂的应用程序，这些微服务仅通过标准化接口（例如RESTful HTTP连接）进行通信。由于微服务严格地彼此分离并且仅通过明确定义的接口进行通信，因此每个微服务都可以用不同技术栈来实现，包括编程语言、类库和数据存储。微服务和所有必需的软件和服务通常捆绑在一起并部署在独立的容器中。图1-2描绘了一种微服务架构。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/spaf_0102.png" alt="spaf 0102">
</div>
</div>
</div>
<div class="sect3">
<h4 id="_分析处理">2.1.2. 分析处理</h4>
<div class="paragraph">
<p>大量数据存储在公司的各种事务数据库系统中，它们可以为公司业务运营提供宝贵的参考意见。例如，分析订单处理系统的数据，可以获得销量随时间的增长曲线；可以识别延迟发货的原因；还可以预测未来的销量以便提前调整库存。但是，事务数据通常分布在多个数据库中，它们往往汇总起来联合分析时更有价值。而且，数据通常需要转换为通用格式。</p>
</div>
<div class="paragraph">
<p>所以我们一般不会直接在事务数据库上运行分析查询，而是复制数据到数据仓库。数据仓库是对工作负载进行分析和查询的专用数据存储。为了填充数据仓库，需要将事务数据库系统管理的数据复制过来。将数据复制到数据仓库的过程称为extract-transform-load（ETL）。 ETL过程从事务数据库中提取数据，将其转换为某种通用的结构表示，可能包括验证，值的规范化，编码，重复数据删除（去重）和模式转换，最后将其加载到分析数据库中。 ETL过程可能非常复杂，并且通常需要技术复杂的解决方案来满足性能要求。 ETL过程需要定期运行以保持数据仓库中的数据同步。</p>
</div>
<div class="paragraph">
<p>将数据导入数据仓库后，可以查询和分析数据。通常，在数据仓库上执行两类查询。第一种类型是定期报告查询，用于计算与业务相关的统计信息，比如收入、用户增长或者输出的产量。这些指标汇总到报告中，帮助管理层评估业务的整体健康状况。第二种类型是即席查询，旨在提供特定问题的答案并支持关键业务决策，例如收集统计在投放商业广告上的花费，和获取的相应收入，以评估营销活动的有效性。两种查询由批处理方式由数据仓库执行，如图1-3所示。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/spaf_0103.png" alt="spaf 0103">
</div>
</div>
<div class="paragraph">
<p>如今，Apache Hadoop生态系统的组件，已经是许多企业IT基础架构中不可或缺的组成部分。现在的做法不是直接将所有数据都插入关系数据库系统，而是将大量数据（如日志文件，社交媒体或Web点击日志）写入Hadoop的分布式文件系统（HDFS）、S3或其他批量数据存储库，如Apache HBase，以较低的成本提供大容量存储容量。驻留在此类存储系统中的数据可以通过SQL-on-Hadoop引擎查询和处理，例如Apache Hive，Apache Drill或Apache Impala。但是，基础结构与传统数据仓库架构基本相同。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_有状态的流式处理">2.2. 有状态的流式处理</h3>
<div class="paragraph">
<p>日常生活中，所有数据都是作为连续的事件流创建的。比如网站或者移动应用中的用户交互动作，订单的提交，服务器日志或传感器测量数据：所有这些都是事件流。实际上，很少有应用场景，能一次性地生成所需要的完整（有限）数据集。实际应用中更多的是无限事件流。有状态的流处理就是用于处理这种无限事件流的应用程序设计模式，在公司的IT基础设施中有广泛的应用场景。在我们讨论其用例之前，我们将简要介绍有状态流处理的工作原理。</p>
</div>
<div class="paragraph">
<p>如果我们想要无限处理事件流，并且不愿意繁琐地每收到一个事件就记录一次，那这样的应用程序就需要是有状态的，也就是说能够存储和访问中间数据。当应用程序收到一个新事件时，它可以从状态中读取数据，或者向该状态写入数据，总之可以执行任何计算。原则上讲，我们可以在各种不同的地方存储和访问状态，包括程序变量（内存）、本地文件，还有嵌入式或外部数据库。</p>
</div>
<div class="paragraph">
<p>Apache Flink将应用程序状态，存储在内存或者嵌入式数据库中。由于Flink是一个分布式系统，因此需要保护本地状态以防止在应用程序或计算机故障时数据丢失。 Flink通过定期将应用程序状态的一致性检查点（check point）写入远程且持久的存储，来保证这一点。状态、状态一致性和Flink的检查点将在后面的章节中更详细地讨论，但是，现在，图1-4显示了有状态的流式Flink应用程序。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/spaf_0104.png" alt="spaf 0104">
</div>
</div>
<div class="paragraph">
<p>有状态的流处理应用程序，通常从事件日志中提取输入事件。事件日志就用来存储和分发事件流。事件被写入持久的仅添加（append-only）日志，这意味着无法更改写入事件的顺序。写入事件日志的流，可以被相同或不同的消费者多次读取。由于日志的仅附加（append-only）属性，事件始终以完全相同的顺序发布给所有消费者。现在已有几种事件日志系统，其中Apache Kafka是最受欢迎的，可以作为开源软件使用，或者是云计算提供商提供的集成服务。</p>
</div>
<div class="paragraph">
<p>在Flink上运行的有状态的流处理应用程序，是很有意思的一件事。在这个架构中，事件日志会按顺序保留输入事件，并且可以按确定的顺序重播它们。如果发生故障，Flink将从先前的检查点（check point）恢复其状态，并重置事件日志上的读取位置，这样就可以恢复整个应用。应用程序将重放（并快进）事件日志中的输入事件，直到它到达流的尾部。此技术一般用于从故障中恢复，但也可用于更新应用程序、修复bug或者修复以前发出的结果，另外还可以用于将应用程序迁移到其他群集，或使用不同的应用程序版本执行A / B测试。</p>
</div>
<div class="paragraph">
<p>如前所述，有状态的流处理是一种通用且灵活的设计架构，可用于许多不同的场景。在下文中，我们提出了三类通常使用有状态流处理实现的应用程序：（1）事件驱动应用程序，（2）数据管道应用程序，以及（3）数据分析应用程序。</p>
</div>
<div class="paragraph">
<p>我们将应用程序分类描述，是为了强调有状态流处理适用于多种业务场景；而实际的应用中，往往会具有以上多种情况的特征。</p>
</div>
<div class="sect3">
<h4 id="_事件驱动应用程序event_driven_applications">2.2.1. 事件驱动应用程序（Event-Driven Applications）</h4>
<div class="paragraph">
<p>事件驱动的应用程序是有状态的流应用程序，它们使用特定的业务逻辑来提取事件流并处理事件。根据业务逻辑，事件驱动的应用程序可以触发诸如发送警报、或电子邮件之类的操作，或者将事件写入向外发送的事件流以供另一个应用程序使用。</p>
</div>
<div class="paragraph">
<p>事件驱动应用程序的典型场景包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>实时推荐（例如，在客户浏览零售商网站时推荐产品）</p>
</li>
<li>
<p>行为模式检测或复杂事件处理（例如，用于信用卡交易中的欺诈检测）</p>
</li>
<li>
<p>异常检测（例如，检测侵入计算机网络的尝试</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>事件驱动应用程序是微服务的演变。它们通过事件日志而不是REST调用进行通信，并将应用程序数据保存为本地状态，而不是将其写入外部数据存储区（例如关系数据库或键值数据库）。图1-5显示了由事件驱动的流应用程序组成的服务架构。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/spaf_0105.png" alt="spaf 0105">
</div>
</div>
<div class="paragraph">
<p>图1-5中的应用程序通过事件日志连接。一个应用程序将其输出发送到事件日志通道（kafka），另一个应用程序使用其他应用程序发出的事件。事件日志通道将发送者和接收者分离，并提供异步、非阻塞的事件传输。每个应用程序都可以是有状态的，并且可以本地管理自己的状态而无需访问外部数据存储。应用程序也可以单独处理和扩展。</p>
</div>
<div class="paragraph">
<p>与事务性应用程序或微服务相比，事件驱动的应用程序具有多种优势。与读写远程数据库相比，本地状态访问提供了非常好的性能。扩展性和容错性都由流处理器来保证，并且以事件日志作为输入源，应用程序的整个输入数据可以可靠地存储，并且可以确定性地重放。此外，Flink可以将应用程序的状态重置为先前的保存点（save point），从而可以在不丢失状态的情况下更新或重新扩展应用程序。</p>
</div>
<div class="paragraph">
<p>事件驱动的应用程序对运行它们的流处理器有很高的要求，并不是所有流处理器都适合运行事件驱动的应用程序。 API的表现力，以及对状态处理和事件时间支持的程度，决定了可以实现和执行的业务逻辑。这方面取决于流处理器的API，主要看它能提供什么样的状态类型，以及它对事件时间处理的支持程度。此外，精确一次（exactly-once）的状态一致性和扩展应用程序的能力是事件驱动应用程序的基本要求。 Apache Flink符合所有的这些要求，是运行此类应用程序的一个非常好的选择。</p>
</div>
</div>
<div class="sect3">
<h4 id="_数据管道data_pipelines">2.2.2. 数据管道（Data Pipelines）</h4>
<div class="paragraph">
<p>当今的IT架构包括许多不同的数据存储，例如关系型数据库和专用数据库系统、事件日志、分布式文件系统，内存中的缓存和搜索索引。所有这些系统都以不同的格式和数据结构存储数据，为其特定的访问模式提供最佳性能。公司通常将相同的数据存储在多个不同的系统中，以提高数据访问的性能。例如，网上商店中提供的产品的信息，可以存储在交易数据库中，同时也存储在缓存（如redis）和搜索索引（如ES）中。由于数据的这种复制，数据存储必须保持同步。</p>
</div>
<div class="paragraph">
<p>在不同存储系统中同步数据的传统方法是定期ETL作业。但是，它们不能满足当今许多场景的延迟要求。另一种方法是使用事件日志（event log）来发布更新。更新将写入事件日志并由事件日志分发。日志的消费者获取到更新之后，将更新合并到受影响的数据存储中。根据使用情况，传输的数据可能需要标准化、使用外部数据进行扩展，或者在目标数据存储提取之前进行聚合。</p>
</div>
<div class="paragraph">
<p>以较低的延迟，来提取、转换和插入数据是有状态流处理应用程序的另一个常见应用场景。这种类型的应用程序称为数据管道（data pipeline）。数据管道必须能够在短时间内处理大量数据。操作数据管道的流处理器还应具有许多源（source）和接收器（sink）的连接器，以便从各种存储系统读取数据并将数据写入各种存储系统。当然，同样地，Flink完成了所有这些功能。</p>
</div>
</div>
<div class="sect3">
<h4 id="_流分析">2.2.3. 流分析</h4>
<div class="paragraph">
<p>ETL作业定期将数据导入数据存储区，数据的处理是由即席查询（用户自定义查询）或设定好的通常查询来做的。无论架构是基于数据仓库还是基于Hadoop生态系统的组件，这都是批处理。多年来最好的处理方式就是，定期将数据加载到数据分析系统中，但它给分析管道带了的延迟相当大，而且无法避免。</p>
</div>
<div class="paragraph">
<p>根据设定好的时间间隔，可能需要数小时或数天才能将数据点包含在报告中。我们前面已经提到，数据管道可以实现低延迟的ETL，所以在某种程度上，可以通过使用数据管道将数据导入存储区来减少延迟。但是，即使持续不停地进行ETL操作，在用查询来处理事件之前总会有延迟。虽然这种延迟在过去可能是可以接受的，但是今天的应用程序，往往要求必须能够实时收集数据，并立即对其进行操作（例如，在手机游戏中去适应不断变化的条件，或者在电商网站中提供个性化的用户体验）。</p>
</div>
<div class="paragraph">
<p>流式分析应用程序不是等待定期触发，而是连续地提取事件流，并且通过纳入最新事件来更新其计算结果，这个过程是低延迟的。这有些类似于数据库中用于更新视图（views）的技术。通常，流应用程序将其结果存储在支持更新的外部数据存储中，例如数据库或键值（key-value）存储。流分析应用程序的实时更新结果可用于驱动监控仪表板（dashboard）应用程序，如图1-6所示。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/spaf_0106.png" alt="spaf 0106">
</div>
</div>
<div class="paragraph">
<p>流分析应用程序最大的优势就是，将每个事件纳入到分析结果所需的时间短得多。除此之外，流分析应用程序还有另一个不太明显的优势。传统的分析管道由几个独立的组件组成，例如ETL过程、存储系统、对于基于Hadoop的环境，还包括用于触发任务（jobs）的数据处理和调度程序。相比之下，如果我们运行一个有状态流应用程序，那么流处理器就会负责所有这些处理步骤，包括事件提取、带有状态维护的连续计算以及更新结果。此外，流处理器可以从故障中恢复，并且具有精确一次（exactly-once）的状态一致性保证，还可以调整应用程序的计算资源。像Flink这样的流处理器还支持事件时间（event-time）处理，这可以保证产生正确和确定的结果，并且能够在很短的时间内处理大量数据。</p>
</div>
<div class="paragraph">
<p>流分析应用程序通常用于：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>监控手机网络的质量分析</p>
</li>
<li>
<p>移动应用中的用户行为</p>
</li>
<li>
<p>实时数据的即席分析</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>虽然我们不在此处介绍，但Flink还提供对流上的分析SQL查询的支持。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_开源流处理的演进">2.3. 开源流处理的演进</h3>
<div class="paragraph">
<p>数据流处理并不是一项新技术。一些最初的研究原型和商业产品可以追溯到20世纪90年代（1990s）。然而，在很大程度上，过去采用的流处理技术是由成熟的开源流处理器驱动的。如今，分布式开源流处理器在不同行业的许多企业中，处理着核心业务应用，比如电商、社交媒体、电信、游戏和银行等。开源软件是这一趋势的主要驱动力，主要原因有两个：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>开源流处理软件是大家每一个人都可以评估和使用的产品。</p>
</li>
<li>
<p>由于许多开源社区的努力，可扩展流处理技术正在迅速成熟和发展</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>仅仅一个Apache软件基金会就支持了十几个与流处理相关的项目。新的分布式流处理项目不断进入开源阶段，并不断增加新的特性和功能。开源社区不断改进其项目的功能，并正在推动流处理的技术边界。我们将简要介绍一下过去，看看开源流处理的起源和今天的状态。</p>
</div>
<div class="sect3">
<h4 id="_流处理的历史">2.3.1. 流处理的历史</h4>
<div class="paragraph">
<p>第一代分布式开源流处理器（2011）专注于具有毫秒延迟的事件处理，并提供了在发生故障时防止事件丢失的保证。这些系统具有相当低级的API，并且对于流应用程序的准确性和结果的一致性，不提供内置支持，因为结果会取决于到达事件的时间和顺序。另外，即使事件没有丢失，也可能不止一次地处理它们。与批处理器相比，第一代开源流处理器牺牲了结果准确性，用来获得更低的延迟。为了让当时的数据处理系统，可以同时提供快速和准确的结果，人们设计了所谓的lambda架构，如图1-7所示。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/spaf_0107.png" alt="spaf 0107">
</div>
</div>
<div class="paragraph">
<p>lambda架构增强了传统的批处理架构，其“快速层”（speed layer）由低延迟的流处理器来支持。数据到达之后由流处理器提取出来，并写入批处理存储。流处理器近乎实时地计算近似结果并将它们写入“快速表”（speed table）。批处理器定期处理批量存储中的数据，将准确的结果写入批处理表，并从速度表中删除相应的不准确结果。应用程序会合并快速表中的近似结果和批处理表中的准确结果，然后消费最终的结果。</p>
</div>
<div class="paragraph">
<p>lambda架构现在已经不再是最先进的，但仍在许多地方使用。该体系结构的最初目标是改善原始批处理分析体系结构的高延迟。但是，它有一些明显的缺点。首先，它需要对一个应用程序，做出两个语义上等效的逻辑实现，用于两个独立的、具有不同API的处理系统。其次，流处理器计算的结果只是近似的。第三，lambda架构很难建立和维护。</p>
</div>
<div class="paragraph">
<p>通过在第一代基础上进行改进，下一代分布式开源流处理器（2013）提供了更好的故障保证，并确保在发生故障时，每个输入记录仅对结果产生一次影响（exactly -once）。此外，编程API从相当低级的操作符接口演变为高级API。但是，一些改进（例如更高的吞吐量和更好的故障保证）是以将处理延迟从毫秒增加到几秒为代价的。此外，结果仍然取决于到达事件的时间和顺序。</p>
</div>
<div class="paragraph">
<p>第三代分布式开源流处理器（2015）解决了结果对到达事件的时间和顺序的依赖性。结合精确一次（exactly-once）的故障语义，这一代系统是第一个具有计算一致性和准确结果的开源流处理器。通过基于实际数据来计算结果（“重演”数据），这些系统还能够以与“实时”数据相同的方式处理历史数据。另一个改进是解决了延迟/吞吐量无法同时保证的问题。先前的流处理器仅能提供高吞吐量或者低延迟（其中之一），而第三代系统能够同时提供这两个特性。这一代的流处理器使得lambda架构过时了。当然，这一代流处理以flink为代表。</p>
</div>
<div class="paragraph">
<p>除了目前讨论的特性，例如容错、性能和结果准确性之外，流处理器还不断添加新的操作功能，例如高可用性设置，与资源管理器（如YARN或Kubernetes）的紧密集成，以及能够动态扩展流应用程序。其他功能包括：支持升级应用程序代码，或将作业迁移到其他群集或新版本的流处理器，而不会丢失当前状态。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_flink_简介">2.4. Flink 简介</h3>
<div class="paragraph">
<p>Apache Flink是第三代分布式流处理器，它拥有极富竞争力的功能。它提供准确的大规模流处理，具有高吞吐量和低延迟。特别的是，以下功能使Flink脱颖而出：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>事件时间（event-time）和处理时间（processing-tme）语义。即使对于无序事件流，事件时间（event-time）语义仍然能提供一致且准确的结果。而处理时间（processing-time）语义可用于具有极低延迟要求的应用程序。</p>
</li>
<li>
<p>精确一次（exactly-once）的状态一致性保证。</p>
</li>
<li>
<p>每秒处理数百万个事件，毫秒级延迟。 Flink应用程序可以扩展为在数千个核（cores）上运行。</p>
</li>
<li>
<p>分层API，具有不同的权衡表现力和易用性。本书介绍了DataStream API和过程函数（process function），为常见的流处理操作提供原语，如窗口和异步操作，以及精确控制状态和时间的接口。本书不讨论Flink的关系API，SQL和LINQ风格的Table API。</p>
</li>
<li>
<p>连接到最常用的存储系统，如Apache Kafka，Apache Cassandra，Elasticsearch，JDBC，Kinesis和（分布式）文件系统，如HDFS和S3。</p>
</li>
<li>
<p>由于其高可用的设置（无单点故障），以及与Kubernetes，YARN和Apache Mesos的紧密集成，再加上从故障中快速恢复和动态扩展任务的能力，Flink能够以极少的停机时间7*24全天候运行流应用程序。</p>
</li>
<li>
<p>能够更新应用程序代码并将作业（jobs）迁移到不同的Flink集群，而不会丢失应用程序的状态。</p>
</li>
<li>
<p>详细且可自定义的系统和应用程序指标集合，以提前识别问题并对其做出反应。</p>
</li>
<li>
<p>最后但同样重要的是，Flink也是一个成熟的批处理器。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>除了这些功能之外，Flink还是一个非常易于开发的框架，因为它易于使用的API。嵌入式执行模式，可以在单个JVM进程中启动应用程序和整个Flink系统，这种模式一般用于在IDE中运行和调试Flink作业。在开发和测试Flink应用程序时，此功能非常有用。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_流处理基础">3. 流处理基础</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_数据流编程简介">3.1. 数据流编程简介</h3>
<div class="paragraph">
<p>在我们深入研究流处理的基础知识之前，让我们来看看在数据流程编程的背景和使用的术语。</p>
</div>
<div class="sect3">
<h4 id="_数据流图dataflow_graph">3.1.1. 数据流图(dataflow graph)</h4>
<div class="paragraph">
<p>顾名思义，数据流程序描述了数据如何在算子之间流动。数据流程序通常表示为有向图，其中节点称为算子，用来表示计算，边表示数据之间的依赖性。算子是数据流程序的基本功能单元。他们从输入消耗数据，对它们执行计算，并生成数据输出用于进一步处理。一个数据流图必须至少有一个数据源和一个数据接收器。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/spaf_0201.png" alt="spaf 0201">
</div>
</div>
<div class="paragraph">
<p>像图2-1中的数据流图被称为逻辑流图，因为它们表示了计算逻辑的高级视图。为了执行一个数据流程序，Flink会将逻辑流图转换为物理数据流图，详细说明程序的执行方式。例如，如果我们使用分布式处理引擎，每个算子在不同的物理机器可能有几个并行的任务运行。图2-2显示了图2-1逻辑图的物理数据流图。而在逻辑数据流图中节点表示算子，在物理数据流图中，节点是任务。“Extract hashtags”和“Count”算子有两个并行算子任务，每个算子任务对输入数据的子集执行计算。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/spaf_0202.png" alt="spaf 0202">
</div>
</div>
</div>
<div class="sect3">
<h4 id="_数据并行和任务并行">3.1.2. 数据并行和任务并行</h4>
<div class="paragraph">
<p>我们可以以不同方式利用数据流图中的并行性。第一，我们可以对输入数据进行分区，并在数据的子集上并行执行具有相同算子的任务并行。这种类型的并行性被称为数据并行性。数据并行是有用的，因为它允许处理大量数据，并将计算分散到不同的计算节点上。第二，我们可以将不同的算子在相同或不同的数据上并行执行。这种并行性称为任务并行性。使用任务并行性，我们可以更好地利用计算资源。</p>
</div>
</div>
<div class="sect3">
<h4 id="_数据交换策略">3.1.3. 数据交换策略</h4>
<div class="paragraph">
<p>数据交换策略定义了在物理执行流图中如何将数据分配给任务。数据交换策略可以由执行引擎自动选择，具体取决于算子的语义或我们明确指定的语义。在这里，我们简要回顾一些常见的数据交换策略，如图2-3所示。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/spaf_0203.png" alt="spaf 0203">
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>前向策略将数据从一个任务发送到接收任务。如果两个任务都位于同一台物理计算机上（这通常由任务调度器确保），这种交换策略可以避免网络通信。</p>
</li>
<li>
<p>广播策略将所有数据发送到算子的所有的并行任务上面去。因为这种策略会复制数据和涉及网络通信，所以代价相当昂贵。</p>
</li>
<li>
<p>基于键控的策略通过Key值(键)对数据进行分区保证具有相同Key的数据将由同一任务处理。在图2-2中，输出“Extract hashtags”算子使用键来分区（hashtag），以便count算子的任务可以正确计算每个\#标签的出现次数。</p>
</li>
<li>
<p>随机策略统一将数据分配到算子的任务中去，以便均匀地将负载分配到不同的计算任务。</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_并行处理流数据">3.2. 并行处理流数据</h3>
<div class="paragraph">
<p>既然我们熟悉了数据流编程的基础知识，现在是时候看看这些概念如何应用于并行的处理数据流了。但首先，让我们定义术语数据流：数据流是一个可能无限的事件序列。</p>
</div>
<div class="paragraph">
<p>数据流中的事件可以表示监控数据，传感器测量数据，信用卡交易数据，气象站观测数据，在线用户交互数据，网络搜索数据等。在本节中，我们将学习如何并行处理无限流，使用数据流编程范式。</p>
</div>
<div class="sect3">
<h4 id="_延迟和吞吐量">3.2.1. 延迟和吞吐量</h4>
<div class="paragraph">
<p>流处理程序不同与批处理程序。在评估性能时，要求也有所不同。对于批处理程序，我们通常关心一个作业的总的执行时间，或我们的处理引擎读取输入所需的时间，执行计算，并回写结果。由于流处理程序是连续运行的，输入可能是无界的，所以数据流处理中没有总执行时间的概念。
相反，流处理程序必须尽可能快的提供输入数据的计算结果。我们使用延迟和吞吐量来表征流处理的性能要求。</p>
</div>
</div>
<div class="sect3">
<h4 id="_延迟">3.2.2. 延迟</h4>
<div class="paragraph">
<p>延迟表示处理事件所需的时间。它是接收事件和看到在输出中处理此事件的效果之间的时间间隔。要直观的理解延迟，考虑去咖啡店买咖啡。当你进入咖啡店时，可能还有其他顾客在里面。因此，你排队等候直到轮到你下订单。收银员收到你的付款并通知准备饮料的咖啡师。一旦你的咖啡准备好了，咖啡师会叫你的名字，你可以到柜台拿你的咖啡。服务延迟是从你进入咖啡店的那一刻起，直到你喝上第一口咖啡之间的时间间隔。</p>
</div>
<div class="paragraph">
<p>在数据流中，延迟是以时间为单位测量的，例如毫秒。根据应用程序，我们可能会关心平均延迟，最大延迟或百分位延迟。例如，平均延迟值为10ms意味着处理事件的平均时间在10毫秒内。或者，延迟值为95\% 10ms表示95\%的事件在10ms内处理完毕。平均值隐藏了处理延迟的真实分布，可能会让人难以发现问题。如果咖啡师在准备卡布奇诺之前用完了牛奶，你必须等到他们从供应室带来一些。虽然你可能会因为这么长时间的延迟而生气，但大多数其他客户仍然会感到高兴。</p>
</div>
<div class="paragraph">
<p>确保低延迟对于许多流应用程序来说至关重要，例如欺诈检测，系统警报，网络监控和提供具有严格服务水平协议的服务。低延迟是流处理的关键特性，它实现了我们所谓的实时应用程序。像Apache Flink这样的现代流处理器可以提供低至几毫秒的延迟。相比之下，传统批处理程序延迟通常从几分钟到几个小时不等。在批处理中，首先需要收集事件批次，然后才能处理它们。因此，延迟是受每个批次中最后一个事件的到达时间的限制。所以自然而然取决于批的大小。真正的流处理不会引入这样的人为延迟，因此可以实现真正的低延迟。真的流模型，事件一进入系统就可以得到处理。延迟更密切地反映了在每个事件上必须进行的实际工作。</p>
</div>
</div>
<div class="sect3">
<h4 id="_吞吐量">3.2.3. 吞吐量</h4>
<div class="paragraph">
<p>吞吐量是衡量系统处理能力的指标，也就是处理速率。也就是说，吞吐量告诉我们每个时间单位系统可以处理多少事件。重温咖啡店的例子，如果商店营业时间为早上7点至晚上7点。当天为600个客户提供了服务，它的平均吞吐量将是每小时50个客户。虽然我们希望延迟尽可能低，但我们通常也需要吞吐量尽可能高。</p>
</div>
<div class="paragraph">
<p>吞吐量以每个时间单位系统所能处理的事件数量或操作数量来衡量。值得注意的是，事件处理速率取决于事件到达的速率，低吞吐量并不一定表示性能不佳。
在流式系统中，我们通常希望确保我们的系统可以处理最大的预期事件到达的速率。也就是说，我们主要的关注点在于确定的峰值吞吐量是多少，当系统处于最大负载时性能怎么样。为了更好地理解峰值吞吐量的概念，让我们考虑一个流处理
程序没有收到任何输入的数据，因此没有消耗任何系统资源。当第一个事件进来时，它会尽可能以最小延迟立即处理。例如，如果你是第一个出现在咖啡店的顾客，在早上开门后，你将立即获得服务。理想情况下，您希望此延迟保持不变
，并且独立于传入事件的速率。但是，一旦我们达到使系统资源被完全使用的事件传入速率，我们将不得不开始缓冲事件。在咖啡店里
，午餐后会看到这种情况发生。许多人出现在同一时间，必须排队等候。在此刻，咖啡店系统已达到其峰值吞吐量，进一步增加
事件传入的速率只会导致更糟糕的延迟。如果系统继续以可以处理的速率接收数据，缓冲区可能变为不可用，数据可能会丢失。这种情况是众所周知的
作为背压，有不同的策略来处理它。</p>
</div>
</div>
<div class="sect3">
<h4 id="_延迟与吞吐量的对比">3.2.4. 延迟与吞吐量的对比</h4>
<div class="paragraph">
<p>此时，应该清楚延迟和吞吐量不是独立指标。如果事件需要在处理流水线中待上很长时间，我们不能轻易确保高吞吐量。同样，如果系统容量很小，事件将被缓冲，而且必须等待才能得到处理。</p>
</div>
<div class="paragraph">
<p>让我们重温一下咖啡店的例子来阐明一下延迟和吞吐量如何相互影响。首先，应该清楚存在没有负载时的最佳延迟。也就是说，如果你是咖啡店的唯一客户，会很快得到咖啡。然而，在繁忙时期，客户将不得不排队等待，并且会有延迟增加。另一个影响延迟和吞吐量的因素是处理事件所花费的时间或为每个客户提供服务所花费的时间。想象一下，期间圣诞节假期，咖啡师不得不为每杯咖啡画圣诞老人。这意味着准备一杯咖啡需要的时间会增加，导致每个人花费
更多的时间在等待咖啡师画圣诞老人，从而降低整体吞吐量。</p>
</div>
<div class="paragraph">
<p>那么，你可以同时获得低延迟和高吞吐量吗？或者这是一个无望的努力？我们可以降低得到咖啡的延迟
，方法是：聘请一位更熟练的咖啡师来准备咖啡。在高负载时，这种变化也会增加吞吐量，因为会在相同的时间内为更多的客户提供服务。
实现相同结果的另一种方法是雇用第二个咖啡师来利用并行性。这里的主要想法是降低延迟来增加吞吐量。当然，如果系统可以更快的执行操作，它可以在相同的时间内执行更多操作。
事实上，在流中利用并行性时也会发生这种情况。通过并行处理多个流，在同时处理更多事件的同时降低延迟。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_数据流上的操作">3.3. 数据流上的操作</h3>
<div class="paragraph">
<p>流处理引擎通常提供一组内置操作：摄取(ingest)，转换(transform)和输出流(output)。这些操作可以
结合到数据流图中来实现逻辑流处理程序。在本节中，我们描述最常见的流处理操作。</p>
</div>
<div class="paragraph">
<p>操作可以是无状态的或有状态的。无状态操作不保持任何内部状态。也就是说，事件的处理不依赖于过去看到的任何事件，也没有保留历史。
无状态操作很容易并行化，因为事件可以彼此独立地处理，也独立于事件到达的顺序(和事件到达顺序没有关系)。
而且，在失败的情况下，无状态操作可以是简单的重新启动并从中断处继续处理。相反，
有状态操作可能会维护之前收到的事件的信息。此状态可以通过传入事件更新，也可以用于未来事件的处理逻辑。有状态的流
处理应用程序更难以并行化和以容错的方式来运行，因为状态需要有效的进行分区和在发生故障的情况下可靠地恢复。</p>
</div>
<div class="sect3">
<h4 id="_数据摄入和数据吞吐量">3.3.1. 数据摄入和数据吞吐量</h4>
<div class="paragraph">
<p>数据摄取和数据出口操作允许流处理程序与外部系统通信。数据摄取是操作从外部源获取原始数据并将其转换为其他格式(ETL)。实现数据提取逻辑的运算符被称为数据源。数据源可以从TCP
Socket，文件，Kafka Topic或传感器数据接口中提取数据。数据出口是以适合消费的形式产出到外部系统。执行数据出口的运算符称为数据接收器，包括文件，数据库，消息队列和监控接口。</p>
</div>
</div>
<div class="sect3">
<h4 id="_转换算子">3.3.2. 转换算子</h4>
<div class="imageblock">
<div class="content">
<img src="images/spaf_0204.png" alt="spaf 0204">
</div>
</div>
<div class="paragraph">
<p>转换算子是单遍处理算子，碰到一个事件处理一个事件。这些操作在使用后会消费一个事件，然后对事件数据做一些转换，产生一个新的输出流。转换逻辑可以集成在
操作符中或由UDF函数提供，如图所示图2-4。程序员编写实现自定义计算逻辑。</p>
</div>
<div class="paragraph">
<p>操作符可以接受多个输入流并产生多个输出流。他们还可以通过修改数据流图的结构要么将流分成多个流，要么将流合并为一条流。</p>
</div>
</div>
<div class="sect3">
<h4 id="_滚动聚合">3.3.3. 滚动聚合</h4>
<div class="paragraph">
<p>滚动聚合是一种聚合，例如sum，minimum和maximum，为每个输入事件不断更新。
聚合操作是有状态的，并将当前状态与传入事件一起计算以产生更新的聚合值。请注意能够有效地将当前状态与事件相结合
产生单个值，聚合函数必须是关联的和可交换的。否则，操作符必须存储完整的流数据历史。图2-5显示了最小滚动
聚合。操作符保持当前的最小值和相应地为每个传入的事件来更新最小值。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/spaf_0205.png" alt="spaf 0205">
</div>
</div>
</div>
<div class="sect3">
<h4 id="_窗口操作符">3.3.4. 窗口操作符</h4>
<div class="paragraph">
<p>转换和滚动聚合一次处理一个事件产生输出事件并可能更新状态。但是，有些操作必须收集并缓冲数据以计算其结果。
例如，考虑不同流之间的连接或整体聚合这样的操作，例如中值函数。为了在无界流上高效运行这些操作符，我们需要限制
这些操作维护的数据量。在本节中，我们将讨论窗口操作，提供此服务。</p>
</div>
<div class="paragraph">
<p>窗口还可以在语义上实现关于流的比较复杂的查询。我们已经看到了滚动聚合的方式，以聚合值编码整个流的历史数据来为每个事件提供低延迟的结果。
但如果我们只对最近的数据感兴趣的话会怎样？考虑给司机提供实时交通信息的应用程序。这个程序可以使他们避免拥挤的路线。在这种场景下，你想知道某个位置在最近几分钟内是否有事故发生。
另一方面，了解所有发生过的事故在这个应用场景下并没有什么卵用。更重要的是，通过将流历史缩减为单一聚合值，我们将丢失这段时间内数据的变化。例如，我们可能想知道每5分钟有多少车辆穿过
某个路口。</p>
</div>
<div class="paragraph">
<p>窗口操作不断从无限事件流中创建有限的事件集，好让我们执行有限集的计算。通常会基于数据属性或基于时间的窗口来分配事件。
要正确定义窗口运算符语义，我们需要确定如何给窗口分配事件以及对窗口中的元素进行求值的频率是什么样的。
窗口的行为由一组策略定义。窗口策略决定何时创建新的窗口以及要分配的事件属于哪个窗口，以及何时对窗口中的元素进行求值。
而窗口的求值基于触发条件。一旦触发条件得到满足，窗口的内容将会被发送到求值函数，求值函数会将计算逻辑应用于窗口中的元素。
求值函数可以是sum或minimal或自定义的聚合函数。
求值策略可以根据时间或者数据属性计算(例如，在过去五秒内收到的事件或者最近的一百个事件等等)。
接下来，我们描述常见窗口类型的语义。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>滚动窗口是将事件分配到固定大小的不重叠的窗口中。当通过窗口的结尾时，全部事件被发送到求值函数进行处理。基于计数的滚动窗口定义了在触发求值之前需要收集多少事件。图2-6显示了一个基于计数的翻滚窗口，每四个元素一个窗口。基于时间的滚动窗口定义一个时间间隔，包含在此时间间隔内的事件。图2-7显示了基于时间的滚动窗口，将事件收集到窗口中每10分钟触发一次计算。</p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="images/spaf_0206.png" alt="spaf 0206">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="images/spaf_0207.png" alt="spaf 0207">
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>滑动窗口将事件分配到固定大小的重叠的窗口中去。因此，事件可能属于多个桶。我们通过提供窗口的长度和滑动距离来定义滑动窗口。滑动距离定义了创建新窗口的间隔。基于滑动计数的窗口，图2-8的长度为四个事件，三个为滑动距离。</p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="images/spaf_0208.png" alt="spaf 0208">
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>会话窗口在常见的真实场景中很有用，一些场景既不能使用滚动窗口也不能使用滑动窗口。考虑一个分析在线用户行为的应用程序。在应用程序里，我们想把源自同一时期的用户活动或会话事件分组在一起。会话由一系列相邻时间发生的事件组成，接下来有一段时间没有活动。例如，用户在App上浏览一系列的新闻，然后关掉App，那么浏览新闻这段时间的浏览事件就是一个会话。会话窗口事先没有定义窗口的长度，而是取决于数据的实际情况，滚动窗口和滑动窗口无法应用于这个场景。相反，我们需要将同一会话中的事件分配到同一个窗口中去，而不同的会话可能窗口长度不一样。会话窗口会定义一个间隙值来区分不同的会话。间隙值的意思是：用户一段时间内不活动，就认为用户的会话结束了。图2-9显示了一个会话窗口。</p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="images/spaf_0209.png" alt="spaf 0209">
</div>
</div>
<div class="paragraph">
<p>到目前为止，所有窗口类型都是在整条流上去做窗口操作。但实际上你可能想要将一条流分流成多个逻辑流并定义并行窗口。
例如，如果我们正在接收来自不同传感器的测量结果，那么可能想要在做窗口计算之前按传感器ID对流进行分流操作。
在并行窗口中，每条流都独立于其他流，然后应用了窗口逻辑。图2-10显示了一个基于计数的长度为2的并行滚动窗口，根据事件颜色分流。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/spaf_0210.png" alt="spaf 0210">
</div>
</div>
<div class="paragraph">
<p>在流处理中，窗口操作与两个主要概念密切相关：时间语义和状态管理。时间也许是流处理最重要的方面。即使低延迟是流处理的一个有吸引力的特性，它的真正价值不仅仅是快速分析。真实世界的系统，网络和通信渠道远非完美，流数据经常被推迟或无序(乱序)到达。理解如何在这种条件下提供准确和确定的结果是至关重要的。
更重要的是，流处理程序可以按原样处理事件制作的也应该能够处理相同的历史事件方式，从而实现离线分析甚至时间旅行分析。
当然，前提是我们的系统可以保存状态，因为可能有故障发生。到目前为止，我们看到的所有窗口类型在产生结果前都需要保存之前的数据。实际上，如果我们想计算任何指标，即使是简单的计数，我们也需要保存状态。考虑到流处理程序可能会运行几天，几个月甚至几年，我们需要确保状态可以在发生故障的情况下可靠地恢复。
并且即使程序崩溃，我们的系统也能保证计算出准确的结果。本章，我们将在流处理应用可能发生故障的语境下，深入探讨时间和状态的概念。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_时间语义">3.4. 时间语义</h3>
<div class="paragraph">
<p>在本节中，我们将介绍时间语义，并描述流中不同的时间概念。我们将讨论流处理器在乱序事件流的情况下如何提供准确的计算结果，以及我们如何处理历史事件流，如何在流中进行时间旅行。</p>
</div>
<div class="sect3">
<h4 id="_在流处理中一分钟代表什么">3.4.1. 在流处理中一分钟代表什么？</h4>
<div class="paragraph">
<p>在处理可能是无限的事件流（包含了连续到达的事件），时间成为流处理程序的核心方面。假设我们想要连续的计算结果，可能每分钟就要计算一次。在我们的流处理程序上下文中，一分钟的意思是什么？</p>
</div>
<div class="paragraph">
<p>考虑一个程序需要分析一款移动端的在线游戏的用户所产生的事件流。游戏中的用户分了组，而应用程序将收集每个小组的活动数据，基于小组中的成员多快达到了游戏设定的目标，然后在游戏中提供奖励。例如额外的生命和用户升级。例如，如果一个小组中的所有用户在一分钟之内都弹出了500个泡泡，他们将升一级。Alice是一个勤奋的玩家，她在每天早晨的通勤时间玩游戏。问题在于Alice住在柏林，并且乘地铁去上班。而柏林的地铁手机信号很差。我们设想一个这样的场景，Alice当她的手机连上网时，开始弹泡泡，然后游戏会将数据发送到我们编写的应用程序中，这时地铁突然进入了隧道，她的手机也断网了。Alice还在玩这个游戏，而产生的事件将会缓存在手机中。当地铁离开隧道，Alice的手机又在线了，而手机中缓存的游戏事件将发送到应用程序。我们的应用程序应该如何处理这些数据？在这个场景中一分钟的意思是什么？这个一分钟应该包含Alice离线的那段时间吗？下图展示了这个问题。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/spaf_0211.png" alt="spaf 0211">
</div>
</div>
<div class="paragraph">
<p>在线手游是一个简单的场景，展示了应用程序的运算应该取决于事件实际发生的时间，而不是应用程序收到事件的时间。如果我们按照应用程序收到事件的时间来进行处理的话，最糟糕的后果就是，Alice和她的朋友们再也不玩这个游戏了。但是还有很多时间语义非常关键的应用程序，我们需要保证时间语义的正确性。如果我们只考虑我们在一分钟之内收到了多少数据，我们的结果会变化，因为结果取决于网络连接的速度或处理的速度。相反，定义一分钟之内的事件数量，这个一分钟应该是数据本身的时间。</p>
</div>
<div class="paragraph">
<p>在Alice的这个例子中，流处理程序可能会碰到两个不同的时间概念：处理时间和事件时间。我们将在接下来的部分，讨论这两个概念。</p>
</div>
</div>
<div class="sect3">
<h4 id="_处理时间">3.4.2. 处理时间</h4>
<div class="paragraph">
<p>处理时间是处理流的应用程序的机器的本地时钟的时间（墙上时钟）。处理时间的窗口包含了一个时间段内来到机器的所有事件。这个时间段指的是机器的墙上时钟。如下图所示，在Alice的这个例子中，处理时间窗口在Alice的手机离线的情况下，时间将会继续行走。但这个处理时间窗口将不会收集Alice的手机离线时产生的事件。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/spaf_0212.png" alt="spaf 0212">
</div>
</div>
</div>
<div class="sect3">
<h4 id="_事件时间">3.4.3. 事件时间</h4>
<div class="paragraph">
<p>事件时间是流中的事件实际发生的时间。事件时间基于流中的事件所包含的时间戳。通常情况下，在事件进入流处理程序前，事件数据就已经包含了时间戳。下图展示了事件时间窗口将会正确的将事件分发到窗口中去。可以如实反应事情是怎么发生的。即使事件可能存在延迟。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/spaf_0213.png" alt="spaf 0213">
</div>
</div>
<div class="paragraph">
<p>事件时间使得计算结果的过程不需要依赖处理数据的速度。基于事件时间的操作是可以预测的，而计算结果也是确定的。无论流处理程序处理流数据的速度快或是慢，无论事件到达流处理程序的速度快或是慢，事件时间窗口的计算结果都是一样的。</p>
</div>
<div class="paragraph">
<p>可以处理迟到的事件只是我们使用事件时间所克服的一个挑战而已。普遍存在的事件乱序问题可以使用事件时间得到解决。考虑和Alice玩同样游戏的Bob，他恰好和Alice在同一趟地铁上。Alice和Bob虽然玩的游戏一样，但他们的手机信号是不同的运营商提供的。当Alice的手机没信号时，Bob的手机依然有信号，游戏数据可以正常发送出去。</p>
</div>
<div class="paragraph">
<p>如果使用事件时间，即使碰到了事件乱序到达的情况，我们也可以保证结果的正确性。还有，当我们在处理可以重播的流数据时，由于时间戳的确定性，我们可以快进过去。也就是说，我们可以重播一条流，然后分析历史数据，就好像流中的事件是实时发生一样。另外，我们可以快进历史数据来使我们的应用程序追上现在的事件，然后应用程序仍然是一个实时处理程序，而且业务逻辑不需要改变。</p>
</div>
</div>
<div class="sect3">
<h4 id="_水位线watermarks">3.4.4. 水位线（Watermarks）</h4>
<div class="paragraph">
<p>在我们对事件时间窗口的讨论中，我们忽略了一个很重要的方面：我们应该怎样去决定何时触发事件时间窗口的计算？也就是说，在我们可以确定一个时间点之前的所有事件都已经到达之前，我们需要等待多久？我们如何知道事件是迟到的？在分布式系统无法准确预测行为的现实条件下，以及外部组件所引发的事件的延迟，以上问题并没有准确的答案。在本小节中，我们将会看到如何使用水位线来设置事件时间窗口的行为。</p>
</div>
<div class="paragraph">
<p>水位线是全局进度的度量标准。系统可以确信在一个时间点之后，不会有早于这个时间点发生的事件到来了。本质上，水位线提供了一个逻辑时钟，这个逻辑时钟告诉系统当前的事件时间。当一个运算符接收到含有时间T的水位线时，这个运算符会认为早于时间T的发生的事件已经全部都到达了。对于事件时间窗口和乱序事件的处理，水位线非常重要。运算符一旦接收到水位线，运算符会认为一段时间内发生的所有事件都已经观察到，可以触发针对这段时间内所有事件的计算了。</p>
</div>
<div class="paragraph">
<p>水位线提供了一种结果可信度和延时之间的妥协。激进的水位线设置可以保证低延迟，但结果的准确性不够。在这种情况下，迟到的事件有可能晚于水位线到达，我们需要编写一些代码来处理迟到事件。另一方面，如果水位线设置的过于宽松，计算的结果准确性会很高，但可能会增加流处理程序不必要的延时。</p>
</div>
<div class="paragraph">
<p>在很多真实世界的场景里面，系统无法获得足够的知识来完美的确定水位线。在手游这个场景中，我们无法得知一个用户离线时间会有多长，他们可能正在穿越一条隧道，可能正在乘飞机，可能永远不会再玩儿了。水位线无论是用户自定义的或者是自动生成的，在一个分布式系统中追踪全局的时间进度都不是很容易。所以仅仅依靠水位线可能并不是一个很好的主意。流处理系统还需要提供一些机制来处理迟到的元素（在水位线之后到达的事件）。根据应用场景，我们可能需要把迟到事件丢弃掉，或者写到日志里，或者使用迟到事件来更新之前已经计算好的结果。</p>
</div>
</div>
<div class="sect3">
<h4 id="_处理时间_vs_事件时间">3.4.5. 处理时间 vs 事件时间</h4>
<div class="paragraph">
<p>大家可能会有疑问，既然事件时间已经可以解决我们的所有问题，为什么我们还要对比这两个时间概念？真相是，处理时间在很多情况下依然很有用。处理时间窗口将会带来理论上最低的延迟。因为我们不需要考虑迟到事件以及乱序事件，所以一个窗口只需要简单的缓存窗口内的数据即可，一旦机器时间超过指定的处理时间窗口的结束时间，就会触发窗口的计算。所以对于一些处理速度比结果准确性更重要的流处理程序，处理时间就派上用场了。另一个应用场景是，当我们需要在真实的时间场景下，周期性的报告结果时，同时不考虑结果的准确性。一个例子就是一个实时监控的仪表盘，负责显示当事件到达时立即聚合的结果。最后，处理时间窗口可以提供流本身数据的忠实表达，对于一些案例可能是很必要的特性。例如我们可能对观察流和对每分钟事件的计数（检测可能存在的停电状况）很感兴趣。简单的说，处理时间提供了低延迟，同时结果也取决于处理速度，并且也不能保证确定性。另一方面，事件时间保证了结果的确定性，同时还可以使我们能够处理迟到的或者乱序的事件流。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_状态和持久化模型">3.5. 状态和持久化模型</h3>
<div class="paragraph">
<p>我们现在转向另一个对于流处理程序非常重要的话题：状态。在数据处理中，状态是普遍存在的。任何稍微复杂一点的计算，都涉及到状态。为了产生计算结果，一个函数在一段时间内的一定数量的事件上来累加状态（例如，聚合计算或者模式匹配）。有状态的运算符使用输入的事件以及内部保存的状态来计算得到输出。例如，一个滚动聚合运算符需要输出这个运算符所观察到的所有事件的累加和。这个运算符将会在内部保存当前观察到的所有事件的累加和，同时每输入一个事件就更新一次累加和的计算结果。相似的，当一个运算符检测到一个“高温”事件紧接着十分钟以内检测到一个“烟雾”事件时，将会报警。直到运算符观察到一个“烟雾”事件或者十分钟的时间段已经过去，这个运算符需要在内部状态中一直保存着“高温”事件。</p>
</div>
<div class="paragraph">
<p>当我们考虑一下使用批处理系统来分析一个无界数据集时，会发现状态的重要性显而易见。在现代流处理器兴起之前，处理无界数据集的一个通常做法是将输入的事件攒成微批，然后交由批处理器来处理。当一个任务结束时，计算结果将被持久化，而所有的运算符状态就丢失了。一旦一个任务在计算下一个微批次的数据时，这个任务是无法访问上一个任务的状态的（都丢掉了）。这个问题通常使用将状态代理到外部系统（例如数据库）的方法来解决。相反，在一个连续不间断运行的流处理任务中，事件的状态是一直存在的，我们可以将状态暴露出来作为编程模型中的一等公民。当然，我们的确可以使用外部系统来管理流的状态，即使这个解决方案会带来额外的延迟。</p>
</div>
<div class="paragraph">
<p>由于流处理运算符默认处理的是无界数据流。所以我们必须要注意不要让内部状态无限的增长。为了限制状态的大小，运算符通常情况下会保存一些之前所观察到的事件流的总结或者概要。这个总结可能是一个计数值，一个累加和，或者事件流的采样，窗口的缓存操作，或者是一个自定义的数据结构，这个数据结构用来保存数据流中感兴趣的一些特性。</p>
</div>
<div class="paragraph">
<p>我们可以想象的到，支持有状态的运算符可能会碰到一些实现上的挑战：</p>
</div>
<div class="paragraph">
<p><strong>状态管理</strong></p>
</div>
<div class="paragraph">
<p>系统需要搞笑的管理状态，并保证针对状态的并发更新，不会产生竞争条件（race condition）。</p>
</div>
<div class="paragraph">
<p><strong>状态分区</strong></p>
</div>
<div class="paragraph">
<p>并行会带来复杂性。因为计算结果同时取决于已经保存的状态和输入的事件流。幸运的是，大多数情况下，我们可以使用Key来对状态进行分区，然后独立的管理每一个分区。例如，当我们处理一组传感器的测量事件流时，我们可以使用分区的运算符状态来针对不同的传感器独立的保存状态。</p>
</div>
<div class="paragraph">
<p><strong>状态恢复</strong></p>
</div>
<div class="paragraph">
<p>第三个挑战是有状态的运算符如何保证状态可以恢复，即使出现任务失败的情况，计算也是正确的。</p>
</div>
<div class="paragraph">
<p>下一节，我们将讨论任务失败和计算结果的保证。</p>
</div>
<div class="sect3">
<h4 id="_任务失败">3.5.1. 任务失败</h4>
<div class="paragraph">
<p>流任务中的运算符状态是很宝贵的，也需要抵御任务失败带来的问题。如果在任务失败的情况下，状态丢失的话，在任务恢复以后计算的结果将是不正确的。流任务会连续不断的运行很长时间，而状态可能已经收集了几天甚至几个月。在失败的情况下，重新处理所有的输入并重新生成一个丢失的状态，将会很浪费时间，开销也很大。</p>
</div>
<div class="paragraph">
<p>在本章开始时，我们看到如何将流的编程建模成数据流模型。在执行之前，流程序将会被翻译成物理层数据流图，物理层数据流图由连接的并行任务组成，而一个并行任务运行一些运算符逻辑，消费输入流数据，并为其他任务产生输出流数据。真实场景下，可能有数百个这样的任务并行运行在很多的物理机器上。在长时间的运行中，流任务中的任意一个任务在任意时间点都有可能失败。我们如何保证任务的失败能被正确的处理，以使任务能继续的运行下去呢？事实上，我们可能希望我们的流处理器不仅能在任务失败的情况下继续处理数据，还能保证计算结果的正确性以及运算符状态的安全。我们在本小节来讨论这些问题。</p>
</div>
<div class="sect4">
<h5 id="_什么是任务失败">什么是任务失败？</h5>
<div class="paragraph">
<p>对于流中的每一个事件，一个处理任务分为以下步骤：（1）接收事件，并将事件存储在本地的缓存中；（2）可能会更新内部状态；（3）产生输出记录。这些步骤都能失败，而系统必须对于在失败的场景下如何处理有清晰的定义。如果任务在第一步就失败了，事件会丢失吗？如果当更新内部状态的时候任务失败，那么内部状态会在任务恢复以后更新吗？在以上这些场景中，输出是确定性的吗？</p>
</div>
<div class="paragraph">
<p>在批处理场景下，所有的问题都不是问题。因为我们可以很方便的重新计算。所以不会有事件丢失，状态也可以得到完全恢复。在流的世界里，处理失败不是一个小问题。流系统在失败的情况下需要保证结果的准确性。接下来，我们需要看一下现代流处理系统所提供的一些保障，以及实现这些保障的机制。</p>
</div>
</div>
<div class="sect4">
<h5 id="_结果的保证">结果的保证</h5>
<div class="paragraph">
<p>当我们讨论保证计算的结果时，我们的意思是流处理器的内部状态需要保证一致性。也就是说我们关心的是应用程序的代码在故障恢复以后看到的状态值是什么。要注意保证应用程序状态的一致性并不是保证应用程序的输出结果的一致性。一旦输出结果被持久化，结果的准确性就很难保证了。除非持久化系统支持事务。</p>
</div>
<div class="paragraph">
<p><strong>AT-MOST-ONCE</strong></p>
</div>
<div class="paragraph">
<p>当任务故障时，最简单的做法是什么都不干，既不恢复丢失的状态，也不重播丢失的事件。At-most-once语义的含义是最多处理一次事件。换句话说，事件可以被丢弃掉，也没有任何操作来保证结果的准确性。这种类型的保证也叫“没有保证”，因为一个丢弃掉所有事件的系统其实也提供了这样的保障。没有保障听起来是一个糟糕的主意，但如果我们能接受近似的结果，并且希望尽可能低的延迟，那么这样也挺好。</p>
</div>
<div class="paragraph">
<p><strong>AT-LEAST-ONCE</strong></p>
</div>
<div class="paragraph">
<p>在大多数的真实应用场景，我们希望不丢失事件。这种类型的保障成为at-least-once，意思是所有的事件都得到了处理，而且一些事件还可能被处理多次。如果结果的正确性仅仅依赖于数据的完整性，那么重复处理是可以接受的。例如，判断一个事件是否在流中出现过，at-least-once这样的保证完全可以正确的实现。在最坏的情况下，我们多次遇到了这个事件。而如果我们要对一个特定的事件进行计数，计算结果就可能是错误的了。</p>
</div>
<div class="paragraph">
<p>为了保证在at-least-once语义的保证下，计算结果也能正确。我们还需要另一套系统来从数据源或者缓存中重新播放数据。持久化的事件日志系统将会把所有的事件写入到持久化存储中。所以如果任务发生故障，这些数据可以重新播放。还有一种方法可以获得同等的效果，就是使用结果承认机制。这种方法将会把每一条数据都保存在缓存中，直到数据的处理等到所有的任务的承认。一旦得到所有任务的承认，数据将被丢弃。</p>
</div>
<div class="paragraph">
<p><strong>EXACTLY-ONCE</strong></p>
</div>
<div class="paragraph">
<p>恰好处理一次是最严格的保证，也是最难实现的。恰好处理一次语义不仅仅意味着没有事件丢失，还意味着针对每一个数据，内部状态仅仅更新一次。本质上，恰好处理一次语义意味着我们的应用程序可以提供准确的结果，就好像从未发生过故障。</p>
</div>
<div class="paragraph">
<p>提供恰好处理一次语义的保证必须有至少处理一次语义的保证才行，同时还需要数据重放机制。另外，流处理器还需要保证内部状态的一致性。也就是说，在故障恢复以后，流处理器应该知道一个事件有没有在状态中更新。事务更新是达到这个目标的一种方法，但可能引入很大的性能问题。Flink使用了一种轻量级快照机制来保证恰好处理一次语义。</p>
</div>
<div class="paragraph">
<p><strong>端到端恰好处理一次</strong></p>
</div>
<div class="paragraph">
<p>目前我们看到的一致性保证都是由流处理器实现的，也就是说都是在Flink流处理器内部保证的。而在真实世界中，流处理应用除了流处理器以外还包含了数据源（例如Kafka）和持久化系统。端到端的一致性保证意味着结果的正确性贯穿了整个流处理应用的始终。每一个组件都保证了它自己的一致性。而整个端到端的一致性级别取决于所有组件中一致性最弱的组件。要注意的是，我们可以通过弱一致性来实现更强的一致性语义。例如，当任务的操作具有幂等性时，比如流的最大值或者最小值的计算。在这种场景下，我们可以通过最少处理一次这样的一致性来实现恰好处理一次这样的最高级别的一致性。</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_flink快速上手">4. Flink快速上手</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_使用maven搭建工程">4.1. 使用Maven搭建工程</h3>
<div class="paragraph">
<p><strong>IDE推荐使用Idea</strong></p>
</div>
<div class="paragraph">
<p>我们使用Flink官方提供的flink-quickstart-scala原型来创建我们的工程，因为Flink官方提供的pom.xml经过了精心配置，可以打包出很小的Jar包。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/quickstart1.png" alt="quickstart1">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="images/quickstart2.png" alt="quickstart2">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="images/quickstart3.png" alt="quickstart3">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="images/quickstart4.png" alt="quickstart4">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="images/quickstart5.png" alt="quickstart5">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="images/quickstart6.png" alt="quickstart6">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="images/quickstart7.png" alt="quickstart7">
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="shell"><span></span>$ tree quickstart/
quickstart/
├── pom.xml
└── src
    └── main
        ├── resources
        │   └── log4j.properties
        └── scala
            └── org
                └── myorg
                    └── quickstart
                        ├── BatchJob.scala
                        └── StreamingJob.scala</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">StreamingJob.scala</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">package</span> <span class="tok-nn">com.atguigu</span>

<span class="tok-k">import</span> <span class="tok-nn">org.apache.flink.streaming.api.scala._</span> <span class="tok-c1">// 导入隐式类型转换</span>
<span class="tok-k">import</span> <span class="tok-nn">org.apache.flink.streaming.api.windowing.time.Time</span>

<span class="tok-k">object</span> <span class="tok-nc">StreamingJob</span> <span class="tok-o">{</span>

  <span class="tok-cm">/** Main program method */</span>
  <span class="tok-k">def</span> <span class="tok-n">main</span><span class="tok-o">(</span><span class="tok-n">args</span><span class="tok-k">:</span> <span class="tok-kt">Array</span><span class="tok-o">[</span><span class="tok-kt">String</span><span class="tok-o">])</span> <span class="tok-k">:</span> <span class="tok-kt">Unit</span> <span class="tok-o">=</span> <span class="tok-o">{</span>

    <span class="tok-c1">// get the execution environment</span>
    <span class="tok-k">val</span> <span class="tok-n">env</span><span class="tok-k">:</span> <span class="tok-kt">StreamExecutionEnvironment</span> <span class="tok-o">=</span> <span class="tok-nc">StreamExecutionEnvironment</span><span class="tok-o">.</span><span class="tok-n">getExecutionEnvironment</span>

    <span class="tok-c1">// get input data by connecting to the socket</span>
    <span class="tok-k">val</span> <span class="tok-n">text</span><span class="tok-k">:</span> <span class="tok-kt">DataStream</span><span class="tok-o">[</span><span class="tok-kt">String</span><span class="tok-o">]</span> <span class="tok-k">=</span> <span class="tok-n">env</span><span class="tok-o">.</span><span class="tok-n">socketTextStream</span><span class="tok-o">(</span><span class="tok-s">&quot;localhost&quot;</span><span class="tok-o">,</span> <span class="tok-mi">9999</span><span class="tok-o">,</span> <span class="tok-sc">&#39;\n&#39;</span><span class="tok-o">)</span>

    <span class="tok-c1">// parse the data, group it, window it, and aggregate the counts</span>
    <span class="tok-k">val</span> <span class="tok-n">windowCounts</span> <span class="tok-k">=</span> <span class="tok-n">text</span>
      <span class="tok-o">.</span><span class="tok-n">flatMap</span> <span class="tok-o">{</span> <span class="tok-n">w</span> <span class="tok-k">=&gt;</span> <span class="tok-n">w</span><span class="tok-o">.</span><span class="tok-n">split</span><span class="tok-o">(</span><span class="tok-s">&quot;\\s&quot;</span><span class="tok-o">)</span> <span class="tok-o">}</span> <i class="conum" data-value="1"></i><b>(1)</b>
      <span class="tok-o">.</span><span class="tok-n">map</span> <span class="tok-o">{</span> <span class="tok-n">w</span> <span class="tok-k">=&gt;</span> <span class="tok-nc">WordWithCount</span><span class="tok-o">(</span><span class="tok-n">w</span><span class="tok-o">,</span> <span class="tok-mi">1</span><span class="tok-o">)</span> <span class="tok-o">}</span>
      <span class="tok-o">.</span><span class="tok-n">keyBy</span><span class="tok-o">(</span><span class="tok-s">&quot;word&quot;</span><span class="tok-o">)</span>
      <span class="tok-o">.</span><span class="tok-n">timeWindow</span><span class="tok-o">(</span><span class="tok-nc">Time</span><span class="tok-o">.</span><span class="tok-n">seconds</span><span class="tok-o">(</span><span class="tok-mi">5</span><span class="tok-o">))</span>
      <span class="tok-o">.</span><span class="tok-n">sum</span><span class="tok-o">(</span><span class="tok-s">&quot;count&quot;</span><span class="tok-o">)</span>

    <span class="tok-c1">// print the results with a single thread, rather than in parallel</span>
    <span class="tok-n">windowCounts</span><span class="tok-o">.</span><span class="tok-n">print</span><span class="tok-o">().</span><span class="tok-n">setParallelism</span><span class="tok-o">(</span><span class="tok-mi">1</span><span class="tok-o">)</span>

    <span class="tok-n">env</span><span class="tok-o">.</span><span class="tok-n">execute</span><span class="tok-o">(</span><span class="tok-s">&quot;Socket Window WordCount&quot;</span><span class="tok-o">)</span>
  <span class="tok-o">}</span>

  <span class="tok-cm">/** Data type for words with count */</span>
  <span class="tok-k">case</span> <span class="tok-k">class</span> <span class="tok-nc">WordWithCount</span><span class="tok-o">(</span><span class="tok-n">word</span><span class="tok-k">:</span> <span class="tok-kt">String</span><span class="tok-o">,</span> <span class="tok-n">count</span><span class="tok-k">:</span> <span class="tok-kt">Long</span><span class="tok-o">)</span>
<span class="tok-o">}</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>flatMap的函数签名：<code>def flatMap[A,B](as: List[A])(f: A &#8658; List[B]): List[B]</code>, 例如: <code>flatMap(List(1,2,3))(i &#8658; List(i,i))</code>结果是<code>List(1,1,2,2,3,3)</code>, <code>List("a b", "c d").flatMap(line &#8658; line.split(" "))</code>结果是<code>List(a, b, c, d)</code>。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>新建一个Terminal终端，然后运行以下:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="shell"><span></span>$ nc -lk <span class="tok-m">9999</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>查看结果，在flink文件夹中的log文件夹里，后缀名为<code>.out</code>, 和在idea里面执行的样子不一样，不会打印到控制台。</p>
</div>
</div>
<div class="sect2">
<h3 id="_flink部署">4.2. Flink部署</h3>
<div class="sect3">
<h4 id="_下载hadoop_free版本的flink">4.2.1. 下载Hadoop Free版本的Flink</h4>
<div class="paragraph">
<p><a href="https://www.apache.org/dyn/closer.lua/flink/flink-1.7.2/flink-1.7.2-bin-scala_2.11.tgz">下载链接</a></p>
</div>
</div>
<div class="sect3">
<h4 id="_解压缩">4.2.2. 解压缩</h4>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="shell"><span></span>$ tar xvfz flink-1.7.2-bin-scala_2.11.tgz</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_启动flink集群">4.2.3. 启动Flink集群</h4>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="shell"><span></span>$ <span class="tok-nb">cd</span> flink-1.7.2
$ ./bin/start-cluster.sh</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_在浏览器中打开flink的web_ui">4.2.4. 在浏览器中打开Flink的Web UI</h4>
<div class="paragraph">
<p><a href="http://localhost:8081" class="bare">http://localhost:8081</a></p>
</div>
</div>
<div class="sect3">
<h4 id="_打包编写好的streamingjob程序">4.2.5. 打包编写好的StreamingJob程序</h4>
<div class="paragraph">
<p>在Idea中使用maven package功能打包。</p>
</div>
</div>
<div class="sect3">
<h4 id="_提交打包好的程序">4.2.6. 提交打包好的程序</h4>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="shell"><span></span>$ ./bin/flink run xxxx.jar</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_在flink_web_ui查看dashboard中job的执行状态">4.2.7. 在Flink Web UI查看Dashboard中job的执行状态</h4>

</div>
<div class="sect3">
<h4 id="_停止flink集群">4.2.8. 停止Flink集群</h4>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="shell"><span></span>$ ./bin/stop-cluster.sh</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_flink运行架构">5. Flink运行架构</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_任务调度原理">5.1. 任务调度原理</h3>
<div class="imageblock">
<div class="content">
<img src="images/processes.png" alt="processes">
</div>
</div>
<div class="paragraph">
<p>客户端不是运行时和程序执行的一部分，但它用于准备并发送Dataflow（JobGraph）给Master（JobManager），然后，客户端断开连接或者维持连接以等待接收计算结果。</p>
</div>
<div class="paragraph">
<p>当Flink集群启动后，首先会启动一个JobManger和一个或多个的TaskManager。由Client提交任务给JobManager，JobManager再调度任务到各个TaskManager去执行，然后TaskManager将心跳和统计信息汇报给JobManager。TaskManager之间以流的形式进行数据的传输。上述三者均为独立的JVM进程。</p>
</div>
<div class="paragraph">
<p>Client为提交Job的客户端，可以运行在任何机器上(与JobManager环境连通即可)。提交Job后，Client可以结束进程(Streaming的任务)，也可以不结束并等待结果返回。</p>
</div>
<div class="paragraph">
<p>JobManager主要负责调度Job并协调Task做Checkpoint。从Client处接收到Job和JAR包等资源后，会生成优化后的执行计划，并以Task为单元调度到各个TaskManager去执行。</p>
</div>
<div class="paragraph">
<p>TaskManager在启动的时候就设置好了槽位数(Slot)，每个Slot能启动一个Task，Task为线程。从JobManager处接收需要部署的Task，部署启动后，与自己的上游建立Netty <sup class="footnote">[<a id="_footnoteref_1" class="footnote" href="#_footnotedef_1" title="View footnote.">1</a>]</sup> 连接，接收数据并处理。</p>
</div>
<div class="paragraph">
<p><strong>关于执行图</strong></p>
</div>
<div class="paragraph">
<p>Flink中的执行图可以分成四层：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/dot-example1.png" alt="dot example1">
</div>
</div>
<div class="paragraph">
<p><strong>StreamGraph</strong>：是根据用户通过Stream API编写的代码生成的最初的图。用来表示程序的拓扑结构。</p>
</div>
<div class="paragraph">
<p><strong>JobGraph</strong>：StreamGraph经过优化后生成了JobGraph，提交给JobManager的数据结构。主要的优化为，将多个符合条件的节点chain在一起作为一个节点，这样可以减少数据在节点之间流动所需要的序列化/反序列化/传输消耗。</p>
</div>
<div class="paragraph">
<p><strong>ExecutionGraph</strong>：JobManager根据JobGraph生成ExecutionGraph。ExecutionGraph是JobGraph的并行化版本，是调度层最核心的数据结构。</p>
</div>
<div class="paragraph">
<p><strong>物理执行图</strong>：JobManager根据ExecutionGraph对Job进行调度后，在各个TaskManager上部署Task后形成的"图"，并不是一个具体的数据结构。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/jobgraph.png" alt="jobgraph">
</div>
</div>
</div>
<div class="sect2">
<h3 id="_worker与slots">5.2. Worker与Slots</h3>
<div class="paragraph">
<p>每一个Worker(TaskManager)是一个JVM进程，它可能会在独立的线程上执行一个或多个SubTask。为了控制一个Worker能接收多少个Task，Worker通过Task Slot来进行控制(一个Worker至少有一个Task Slot)。</p>
</div>
<div class="paragraph">
<p>每个Task Slot表示TaskManager拥有资源的一个固定大小的子集。假如一个TaskManager有三个Slot，那么它会将其管理的内存分成三份给各个Slot。资源Slot化意味着一个SubTask将不需要跟来自其他Job的SubTask竞争被管理的内存，取而代之的是它将拥有一定数量的内存储备。需要注意的是，这里不会涉及到CPU的隔离，Slot目前仅仅用来隔离Task的受管理的内存。</p>
</div>
<div class="paragraph">
<p>通过调整Task Slot的数量，允许用户定义SubTask之间如何互相隔离。如果一个TaskManager一个Slot，那将意味着每个Task Group运行在独立的JVM中(该JVM可能是通过一个特定的容器启动的)，而一个TaskManager多个Slot意味着更多的SubTask可以共享同一个JVM。而在同一个JVM进程中的Task将共享TCP连接(基于IO多路复用)和心跳消息。它们也可能共享数据集和数据结构，因此这减少了每个Task的负载。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/tasks_slots.png" alt="tasks slots">
</div>
</div>
<div class="paragraph">
<p>Task Slot是静态的概念，是指TaskManager具有的并发执行能力，可以通过参数taskmanager.numberOfTaskSlots进行配置，而并行度parallelism是动态概念，即TaskManager运行程序时实际使用的并发能力，可以通过参数parallelism.default进行配置。</p>
</div>
<div class="paragraph">
<p>也就是说，假设一共有3个TaskManager，每一个TaskManager中的分配3个Task Slot，也就是每个TaskManager可以接收3个Task，一共9个Task Slot，如果我们设置parallelism.default=1，即运行程序默认的并行度为1，9个TaskSlot只用了1个，有8个空闲，因此，设置合适的并行度才能提高效率。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/slots_parallelism.png" alt="slots parallelism">
</div>
</div>
</div>
<div class="sect2">
<h3 id="_程序与数据流">5.3. 程序与数据流</h3>
<div class="imageblock">
<div class="content">
<img src="images/program_dataflow.png" alt="program dataflow">
</div>
</div>
<div class="paragraph">
<p>所有的Flink程序都是由三部分组成的：Source、Transformation和Sink。</p>
</div>
<div class="paragraph">
<p>Source负责读取数据源，Transformation利用各种算子进行处理加工，Sink负责输出。</p>
</div>
<div class="paragraph">
<p>在运行时，Flink上运行的程序会被映射成Streaming Dataflows，它包含了这三部分。每一个Dataflow以一个或多个sources开始以一个或多个sinks结束。dataflow类似于任意的有向无环图(DAG)。在大部分情况下，程序中的transformations跟dataflow中的operator是一一对应的关系，但有时候，一个transformation可能对应多个operator。</p>
</div>
</div>
<div class="sect2">
<h3 id="_并行数据流">5.4. 并行数据流</h3>
<div class="paragraph">
<p>Flink程序的执行具有并行、分布式的特性。在执行过程中，一个stream包含一个或多个stream partition，而每一个operator包含一个或多个operator subtask，这些operator subtasks在不同的线程、不同的物理机或不同的容器中彼此互不依赖的执行。</p>
</div>
<div class="paragraph">
<p>一个特定operator的subtask的个数被称之为其parallelism(并行度)。一个stream的并行度总是等同于其producing operator的并行度。一个程序中，不同的operator可能具有不同的并行度。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/parallel_dataflow.png" alt="parallel dataflow">
</div>
</div>
<div class="paragraph">
<p>Stream在operator之间传输数据的形式可以是one-to-one(forwarding)的模式也可以是redistributing的模式，具体是哪一种形式，取决于operator的种类。</p>
</div>
<div class="paragraph">
<p><strong>One-to-One</strong>：stream(比如在source和map operator之间)维护着分区以及元素的顺序。那意味着map operator的subtask看到的元素的个数以及顺序跟source operator的subtask生产的元素的个数、顺序相同，map、fliter、flatMap等算子都是one-to-one的对应关系。类似于spark中的窄依赖。</p>
</div>
<div class="paragraph">
<p><strong>Redistributing</strong>：stream（map()跟keyBy/window之间或者keyBy/window跟sink之间）的分区会发生改变。每一个operator subtask依据所选择的transformation发送数据到不同的目标subtask。例如，keyBy()基于hashCode重分区、broadcast和rebalance会随机重新分区，这些算子都会引起redistributing过程，而redistributing过程就类似于Spark中的shuffle过程。类似于spark中的宽依赖。</p>
</div>
</div>
<div class="sect2">
<h3 id="_task与operator_chains">5.5. task与operator chains</h3>
<div class="paragraph">
<p>相同并行度的one to one操作，Flink这样相连的operator链接在一起形成一个task，原来的operator成为里面的subtask。将operators链接成task是非常有效的优化：它能减少线程之间的切换和基于缓存区的数据交换，在减少时延的同时提升吞吐量。链接的行为可以在编程API中进行指定。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/operatorschains.png" alt="operatorschains">
</div>
</div>
</div>
<div class="sect2">
<h3 id="_系统架构">5.6. 系统架构</h3>
<div class="paragraph">
<p>Flink是一个用于有状态的并行数据流处理的分布式系统。它由多个进程构成，这些进程一般会分布运行在不同的机器上。对于分布式系统来说，面对的常见问题有：集群中资源的分配和管理、进程协调调度、持久化和高可用的数据存储，以及故障恢复。</p>
</div>
<div class="paragraph">
<p>对于这些分布式系统的经典问题，业内已有比较成熟的解决方案和服务。所以Flink并不会自己去处理所有的问题，而是利用了现有的集群架构和服务，这样它就可以把精力集中在核心工作——分布式数据流处理上了。Flink与一些集群资源管理工具有很好的集成，比如Apache Mesos、YARN和Kubernetes；同时，也可以配置为独立（stand-alone）集群运行。Flink自己并不提供持久化的分布式存储，而是直接利用了已有的分布式文件系统（比如HDFS）或者对象存储（比如S3）。对于高可用的配置，Flink需要依靠Apache ZooKeeper来完成。</p>
</div>
<div class="paragraph">
<p>在本节中，我们将介绍Flink的不同组件，以及在运行程序时它们如何相互作用。我们会讨论部署Flink应用程序的两种模式，并且了解每种模式下分发和执行任务的方式。最后，我们还会解释一下Flink的高可用性模式是如何工作的。</p>
</div>
<div class="sect3">
<h4 id="_flink运行时组件">5.6.1. Flink运行时组件</h4>
<div class="paragraph">
<p>Flink运行时架构主要包括四个不同的组件，它们会在运行流处理应用程序时协同工作：作业管理器（JobManager）、资源管理器（ResourceManager）、任务管理器（TaskManager），以及分发器（Dispatcher）。因为Flink是用Java和Scala实现的，所以所有组件都会运行在Java虚拟机（JVMs）上。每个组件的职责如下：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>作业管理器（JobManager）是控制一个应用程序执行的主进程，也就是说，每个应用程序都会被一个不同的JobManager所控制执行。JobManager会先接收到要执行的应用程序。这个应用程序会包括：作业图（JobGraph）、逻辑数据流图（logical dataflow graph）和打包了所有的类、库和其它资源的JAR包。JobManager会把JobGraph转换成一个物理层面的数据流图，这个图被叫做“执行图”（ExecutionGraph），包含了所有可以并发执行的任务。JobManager会向资源管理器（ResourceManager）请求执行任务必要的资源，也就是任务管理器（TaskManager）上的插槽（slot）。一旦它获取到了足够的资源，就会将执行图分发到真正运行它们的TaskManager上。而在运行过程中，JobManager会负责所有需要中央协调的操作，比如说检查点（checkpoints）的协调。</p>
</li>
<li>
<p>ResourceManager主要负责管理任务管理器（TaskManager）的插槽（slot），TaskManger插槽是Flink中定义的处理资源单元。Flink为不同的环境和资源管理工具提供了不同资源管理器（ResourceManager），比如YARN、Mesos、K8s，以及standalone部署。当JobManager申请插槽资源时，ResourceManager会将有空闲插槽的TaskManager分配给JobManager。如果ResourceManager没有足够的插槽来满足JobManager的请求，它还可以向资源提供平台发起会话，以提供启动TaskManager进程的容器。另外，ResourceManager还负责终止空闲的TaskManager，释放计算资源。</p>
</li>
<li>
<p>任务管理器（TaskManager）是Flink中的工作进程。通常在Flink中会有多个TaskManager运行，每一个TaskManager都包含了一定数量的插槽（slots）。插槽的数量限制了TaskManager能够执行的任务数量。启动之后，TaskManager会向资源管理器注册它的插槽；收到资源管理器的指令后，TaskManager就会将一个或者多个插槽提供给JobManager调用。JobManager就可以向插槽分配任务（tasks）来执行了。在执行过程中，一个TaskManager可以跟其它运行同一应用程序的TaskManager交换数据。任务的执行和插槽的概念会在“任务执行”一节做具体讨论。</p>
</li>
<li>
<p>分发器（Dispatcher）可以跨作业运行，它为应用提交提供了REST接口。当一个应用被提交执行时，分发器就会启动并将应用移交给一个JobManager。由于是REST接口，所以Dispatcher可以作为集群的一个HTTP接入点，这样就能够不受防火墙阻挡。Dispatcher也会启动一个Web UI，用来方便地展示和监控作业执行的信息。Dispatcher在架构中可能并不是必需的，这取决于应用提交运行的方式。</p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="images/spaf_0301.png" alt="spaf 0301">
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
上图是从一个较为高层级的视角，来看应用中各组件的交互协作。如果部署的集群环境不同（例如YARN，Mesos，Kubernetes，standalone等），其中一些步骤可以被省略，或是有些组件会运行在同一个JVM进程中。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_应用部署">5.6.2. 应用部署</h4>
<div class="paragraph">
<p>Flink应用程序可以用以下两种不同的方式部署：</p>
</div>
<div class="paragraph">
<p><strong>框架（Framework）方式</strong></p>
</div>
<div class="paragraph">
<p>在这个模式下，Flink应用被打包成一个Jar文件，并由客户端提交给一个运行服务（running service）。这个服务可以是一个Flink的Dispatcher，也可以是一个Flink的JobManager，或是Yarn的ResourceManager。如果application被提交给一个JobManager，则它会立即开始执行这个application。如果application被提交给了一个Dispatcher，或是Yarn ResourceManager，则它会启动一个JobManager，然后将application交给它，再由JobManager开始执行此应用。</p>
</div>
<div class="paragraph">
<p><strong>库（Library）方式</strong></p>
</div>
<div class="paragraph">
<p>在这个模式下，Flink Application 会被打包在一个容器（container） 镜像里，例如一个Docker 镜像。此镜像包含了运行JobManager和ResourceManager的代码。当一个容器从镜像启动后，它会自动启动ResourceManager和JobManager，并提交打包好的应用。另一种方法是：将应用打包到镜像后，只用于部署TaskManager容器。从镜像启动的容器会自动启动一个TaskManager，然后连接ResourceManager并注册它的slots。这些镜像的启动以及失败重启，通常都会由一个外部的资源管理器管理（比如Kubernetes）。</p>
</div>
<div class="paragraph">
<p>框架模式遵循了传统的任务提交方式，从客户端提交到Flink运行服务。而在库模式下，没有运行的Flink服务。它是将Flink作为一个库，与应用程序一同打包到了一个容器镜像。这种部署方式在微服务架构中较为常见。我们会在“运行管理流式应用程序”一节对这个话题做详细讨论。</p>
</div>
</div>
<div class="sect3">
<h4 id="_任务执行">5.6.3. 任务执行</h4>
<div class="paragraph">
<p>一个TaskManager可以同时执行多个任务（tasks）。这些任务可以是同一个算子（operator）的子任务（数据并行），也可以是来自不同算子的（任务并行），甚至可以是另一个不同应用程序的（作业并行）。TaskManager提供了一定数量的处理插槽（processing slots），用于控制可以并行执行的任务数。一个slot可以执行应用的一个分片，也就是应用中每一个算子的一个并行任务。图3-2展示了TaskManagers，slots，tasks以及operators之间的关系：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/spaf_0302.png" alt="spaf 0302">
</div>
</div>
<div class="paragraph">
<p>最左边是一个“作业图”（JobGraph），包含了5个算子——它是应用程序的非并行表示。其中算子A和C是数据源（source），E是输出端（sink）。C和E并行度为2，而其他的算子并行度为4。因为最高的并行度是4，所以应用需要至少四个slot来执行任务。现在有两个TaskManager，每个又各有两个slot，所以我们的需求是满足的。JobManager将JobGraph转化为“执行图”（ExecutionGraph），并将任务分配到四个可用的slot上。对于有4个并行任务的算子，它的task会分配到每个slot上。而对于并行度为2的operator C和E，它们的任务被分配到slot 1.1、2.1 以及 slot 1.2、2.2。将tasks调度到slots上，可以让多个tasks跑在同一个TaskManager内，也就可以是的tasks之间的数据交换更高效。然而将太多任务调度到同一个TaskManager上会导致TaskManager过载，继而影响效率。之后我们会在“控制任务调度”一节继续讨论如何控制任务的调度。</p>
</div>
<div class="paragraph">
<p>TaskManager在同一个JVM中以多线程的方式执行任务。线程较进程会更轻量级，但是线程之间并没有对任务进行严格隔离。所以，单个任务的异常行为有可能会导致整个TaskManager进程挂掉，当然也同时包括运行在此进程上的所有任务。通过为每个TaskManager配置单独的slot，就可以将应用在TaskManager上相互隔离开来。TaskManager内部有多线程并行的机制，而且在一台主机上可以部署多个TaskManager，所以Flink在资源配置上非常灵活，在部署应用时可以充分权衡性能和资源的隔离。我们将会在第九章对Flink集群的配置和搭建继续做详细讨论。</p>
</div>
</div>
<div class="sect3">
<h4 id="_高可用配置">5.6.4. 高可用配置</h4>
<div class="paragraph">
<p>流式应用程序一般被设计为7 x 24 小时运行。所以很重要的一点是：即使出现了进程挂掉的情况，应用仍需要继续保持运行。为了从故障恢复，系统首先需要重启进程、然后重启应用并恢复它的状态。接下来，我们就来了解Flink如何重启失败的进程。</p>
</div>
<div class="paragraph">
<p><strong>TaskManager故障</strong></p>
</div>
<div class="paragraph">
<p>如前所述，Flink需要足够数目的slot，来执行一个应用的所有任务。假设一个Flink环境有4个TaskManager，每个提供2个插槽，那么流应用程序执行的最高并行度为8。如果其中一个TaskManager挂掉了，那么可用的slots会降到6。在这种情况下，JobManager会请求ResourceManager提供更多的slots。如果此请求无法满足——例如应用跑在一个standalone集群——那么JobManager在有足够的slots之前，无法重启应用。应用的重启策略决定了JobManager的重启频率，以及两次重启尝试之间的时间间隔。</p>
</div>
<div class="paragraph">
<p><strong>JobManager故障</strong></p>
</div>
<div class="paragraph">
<p>比TaskManager故障更严重的问题是JobManager故障。JobManager控制整个流应用程序的执行，并维护执行中的元数据——例如指向已完成检查点的指针。若是对应的JobManager挂掉，则流程序无法继续运行。所以这就导致在Flink应用中，JobManager是单点故障。为了解决这个问题，Flink提供了高可用模式。在原先的JobManager挂掉后，可以将一个作业的状态和元数据迁移到另一个JobManager，并继续执行。</p>
</div>
<div class="paragraph">
<p>Flink的高可用模式基于Apache ZooKeeper，我们知道，ZooKeeper是用来管理需要协调和共识的分布式服务的系统。Flink主要利用ZooKeeper来进行领导者（leader）的选举，并把它作为一个高可用和持久化的数据存储。当在高可用模式下运行时，JobManager会将JobGraph以及所有需要的元数据（例如应用程序的jar文件），写入到一个远程的持久化存储系统中。而且，JobManager会将指向存储位置的指针，写入到ZooKeeper的数据存储中。在执行一个应用的过程中，JobManager会接收每个独立任务检查点的状态句柄（也就是存储位置）。当一个检查点完成时（所有任务已经成功地将它们的状态写入到远程存储）， JobManager把状态句柄写入远程存储，并将指向这个远程存储的指针写入ZooKeeper。这样，一个JobManager挂掉之后再恢复，所需要的所有数据信息已经都保存在了远程存储，而ZooKeeper里存有指向此存储位置的指针。图3-3描述了这个设计：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/spaf_0303.png" alt="spaf 0303">
</div>
</div>
<div class="paragraph">
<p>当一个JobManager失败，所有属于这个应用的任务都会自动取消。一个新的JobManager接管工作，会执行以下操作：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>从ZooKeeper请求存储位置（storage location），从远端存储获取JobGraph，Jar文件，以及应用最近一次检查点（checkpoint）的状态句柄（state handles）</p>
</li>
<li>
<p>从ResourceManager请求slots，用来继续运行应用</p>
</li>
<li>
<p>重启应用，并将所有任务的状态，重设为最近一次已完成的检查点</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果我们是在容器环境里运行应用（如Kubernetes），故障的JobManager或TaskManager 容器通常会由容器服务自动重启。当运行在YARN或Mesos之上时，JobManager或TaskManager进程会由Flink的保留进程自动触发重启。而在standalone模式下，Flink并未提供重启故障进程的工具。所以，此模式下我们可以增加备用（standby）的 JobManager和TaskManager，用于接管故障的进程。我们将会在“高可用配置”一节中做进一步讨论。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_flink中的数据传输">5.7. Flink中的数据传输</h3>
<div class="paragraph">
<p>运行中的应用任务，会持续不断地交换数据。TaskManager负责将数据从“发送任务”（sending tasks）传递到“接收任务”（receiving tasks）。TaskManager的网络组件会在缓冲区中收集数据，然后再将其发送，也就是说，数据不是逐条发送的，而是在缓冲区中“攒”成了一批。这种技术是有效利用网络资源和实现高吞吐量的基础，机制类似于网络或磁盘I/O协议中使用的缓冲技术。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
通过缓冲区来传递数据，意味着Flink的处理模型是基于微批的。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>每个TaskManager都有一个网络缓冲池（默认大小为32KB），用于发送和接收数据。如果发送任务和接收任务运行在不同的TaskManager进程中，那么它们会通过操作系统的网络栈来进行通信。流应用程序需要以管道方式传递数据，所以每对TaskManager之间都需要维护一个永久TCP连接，用来交换数据。在无序连接模式下，每个发送任务都需要能向任何接收任务传递数据。所以我们发现，TaskManager需要为每一个接收任务设置一个专用的网络缓冲区，因为其中的每一个任务都需要接收数据。图3-4展示了这种架构。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/spaf_0304.png" alt="spaf 0304">
</div>
</div>
<div class="paragraph">
<p>如图3-4所示，四个发送任务中的每一个都需要至少四个网络缓冲区，用来向每个接收任务发送数据，而每个接收任务也需要至少四个缓冲区来接收数据。需要发送到另一个TaskManager的缓冲数据，会复用同一网络连接。为了实现平滑的管道数据传输，TaskManager必须能够提供足够的缓冲，来同时为所有传出和传入连接提供服务。对于无序或广播连接，每个发送任务都需要为每个接收任务提供一个缓冲；所以，所需缓冲区的数量是相关算子任务数量的平方。Flink网络缓冲区的默认配置足以满足中小型应用；对于更大的应用场景，就需要按照“主内存和网络缓冲区”一节中的叙述调整配置了。</p>
</div>
<div class="paragraph">
<p>当发送任务和接收任务在同一个TaskManager进程中运行时，发送任务会将传出的数据序列化，放入字节缓冲区，并在缓冲区填满后将其放入队列。接收任务从队列中提取缓冲数据并对其进行反序列化。因此，在同一个TaskManager上运行的任务，它们之间的数据传输不会导致网络通信。</p>
</div>
<div class="paragraph">
<p>Flink采用不同的技术来降低任务之间的通信成本。在下面的部分中，我们会简要讨论基于信任度（Credit）的流控制和任务链。</p>
</div>
<div class="sect3">
<h4 id="_基于信任度credit的流控制">5.7.1. 基于信任度（credit）的流控制</h4>
<div class="paragraph">
<p>通过网络连接来发送每条数据的效率很低，会导致很大的开销。为了充分利用网络连接的带宽，就需要进行缓冲了。在流处理的上下文中，缓冲的一个缺点是会增加延迟，因为数据需要在缓冲区中进行收集，而不是立即发送。</p>
</div>
<div class="paragraph">
<p>Flink实现了一个基于信任度的流量控制机制，其工作原理如下。接收任务授予发送任务一些“信任度”（credit），也就是为了接收其数据而保留的网络缓冲区数。当发送者收到一个信任度通知，它就会按照被授予的信任度，发送尽可能多的缓冲数据，并且同时发送目前积压数据的大小——也就是已填满并准备发送的网络缓冲的数量。接收者用保留的缓冲区处理发来的数据，并对发送者传来的积压量进行综合考量，为其所有连接的发送者确定下一个信用度授权的优先级。</p>
</div>
<div class="paragraph">
<p>基于信用度的流控制可以减少延迟，因为发送者可以在接收者有足够的资源接受数据时立即发送数据。此外，在数据倾斜的情况下，这样分配网络资源是一种很有效的机制，因为信用度是根据发送者积压数据量的规模授予的。因此，基于信用的流量控制是Flink实现高吞吐量和低延迟的重要组成部分。</p>
</div>
</div>
<div class="sect3">
<h4 id="_任务链task_chaining">5.7.2. 任务链（Task Chaining）</h4>
<div class="paragraph">
<p>Flink采用了一种称为任务链的优化技术，可以在特定条件下减少本地通信的开销。为了满足任务链的要求，必须将两个或多个算子设为相同的并行度，并通过本地转发（local forward）的方式进行连接。图3-5所示的算子管道满足这些要求。它由三个算子组成，这些算子的任务并行度都被设为2，并且通过本地转发方式相连接。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/spaf_0305.png" alt="spaf 0305">
</div>
</div>
<div class="paragraph">
<p>图3-6展示了管道以任务链方式运行的过程。算子的函数被融合成了一个单一的任务，由一个线程执行。由函数生成的数据通过一个简单的方法调用移交给下一个函数；这样在函数之间直接传递数据，基本上没有序列化和通信成本。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/spaf_0306.png" alt="spaf 0306">
</div>
</div>
<div class="paragraph">
<p>任务链可以显著降低本地任务之间的通信成本，但也有一些场景，在没有链接的情况下运行管道操作是有意义的。例如，如果任务链中某个函数执行的开销巨大，那就可以将一条长的任务链管道断开，或者将一条链断开为两个任务，从而可以将这个开销大的函数调度到不同的槽（slots）中。图3-7显示了在没有任务链的情况下相同管道操作的执行情况。所有函数都由独立的单个任务来评估，每个任务都在专有的线程中运行。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/spaf_0307.png" alt="spaf 0307">
</div>
</div>
<div class="paragraph">
<p>任务链在Flink中默认会启用。在“控制任务链”一节中，我们展示了如何禁用应用程序的任务链，以及如何控制各个算子的链接行为。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_事件时间event_time处理">5.8. 事件时间（Event-Time）处理</h3>
<div class="paragraph">
<p>在“时间语义”一节，我们重点强调了时间语义在流处理应用中的重要性，并且解释了处理时间（processing time）和事件时间（event time）的不同。处理时间比较好理解，因为它是基于处理器本地时间的；但同时，它会带来比较混乱、不一致、并且不可重现的结果。相比之下，事件时间语义能够产生可重现且一致的结果，这也是许多流处理场景希望解决的一大难题。但是，与处理时间应用程序相比，事件时间应用程序会更复杂，需要额外的配置。另外，支持事件时间的流处理器，也比纯粹在处理时间中运行的系统内部更为复杂。</p>
</div>
<div class="paragraph">
<p>Flink为常见的事件时间处理操作提供了直观且易于使用的原语，同时暴露了表达性很强的API，用户可以使用自定义算子实现更高级的事件时间应用程序。很好地理解Flink的内部时间处理，对于实现这样的高级应用程序会有很大帮助，有时也是必需的。上一章介绍了Flink利用两个概念来支持事件时间语义：记录时间戳（timestamps）和水位线（watermarks）。接下来，我们将描述Flink如何在内部实现并处理时间戳和水位线，进而支持具有事件时间语义的流式应用程序。</p>
</div>
<div class="sect3">
<h4 id="_时间戳timestamps">5.8.1. 时间戳（Timestamps）</h4>
<div class="paragraph">
<p>由Flink事件时间流应用程序处理的所有记录都必须伴有时间戳。时间戳将数据与特定时间点相关联，通常就是数据所表示的事件发生的时间点。而只要时间戳大致跟数据流保持一致，基本上随着数据流的前进而增大，应用程序就可以自由选择时间戳的含义。不过正如“时间语义”一节中所讨论的，在现实场景中，时间戳基本上都是乱序的，所以采用“事件时间”而非“处理事件”往往会显得更为重要。</p>
</div>
<div class="paragraph">
<p>当Flink以事件时间模式处理数据流时，它会根据数据记录的时间戳来处理基于时间的算子。例如，时间窗口算子根据相关时间戳将数据分配给不同的时间窗口。Flink将时间戳编码为16字节的长整型值，并将其作为元数据附加到数据记录中。它的内置运算符会将这个长整型值解释为一个具有毫秒精度的Unix时间戳，也就是1970-01-01-00:00:00.000以来的毫秒数。当然，如果用户进行了自定义，那么运算符可以有自己的解释，例如，可以将精度调整到微秒。</p>
</div>
</div>
<div class="sect3">
<h4 id="_水位线watermarks_2">5.8.2. 水位线(Watermarks)</h4>
<div class="paragraph">
<p>除了时间戳，基于事件时间的Flink应用程序还必须支持水位线（watermark）。在基于事件时间的应用中，水位线用于生成每个任务的当前事件时间。基于时间的算子使用这个“当前事件时间”来触发计算和处理操作。例如，一个时间窗口任务（time-window task）会在任务的事件时间超出窗口的关闭边界时，完成窗口计算，并输出计算结果。</p>
</div>
<div class="paragraph">
<p>在Flink中，水位线被实现为一条特殊的数据记录，它里面以长整型值保存了一个时间戳。水位线在带有时间戳的数据流中，跟随着其它数据一起流动，如图3-8所示。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/spaf_0308.png" alt="spaf 0308">
</div>
</div>
<div class="paragraph">
<p>水位线有两个基本属性：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>必须单调递增，以确保任务的事件时间时钟在向前推进，而不是在后退。</p>
</li>
<li>
<p>它们与数据的时间戳相关。带有时间戳T的水位线表示，所有后续数据的时间戳都应该大于T。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>上面的第二个属性用于处理带有乱序时间戳的数据流，比如图3-8中时间戳3和5的数据。基于时间的算子任务会收集和处理数据（这些数据可能具有乱序的时间戳），并在事件时间时钟到达某个时刻时完成计算。这个时刻就表示数据收集的截止，具有之前时间戳的数据应该都已经到达、不再需要了；而其中的事件时间时钟，正是由当前接收到的水位线来指示的。如果任务再接收到的数据违反了watermark的这一属性，也就是时间戳小于以前接收到的水位线时，它所属的那部分计算可能已经完成了。这种数据被称为延迟数据（late records）。Flink提供了处理延迟数据的不同方式，我们会在“处理延迟数据”一节中讨论。</p>
</div>
<div class="paragraph">
<p>水位线还有一个很有趣的特性，它允许应用程序自己来平衡结果的完整性和延迟。如果水位线与数据的时间戳非常接近，那么我们可以得到较低的处理延迟，因为任务在完成计算之前只会短暂地等待更多数据到达。而同时，结果的完整性可能会受到影响，因为相关数据可能因为迟到而被视为“延迟数据”，这样就不会包含在结果中。相反，非常保守的水位线提供了足够的时间去等待所有数据到达，这样会增加处理延迟，但提高了结果的完整性。</p>
</div>
</div>
<div class="sect3">
<h4 id="_watermark的传递和事件时间">5.8.3. watermark的传递和事件时间</h4>
<div class="paragraph">
<p>在本节中，我们将讨论算子如何处理水位线。Flink把watermark作为一条特殊的数据来实现，它也会由算子任务接收和发送。任务会有一个内部的时间服务，它会维护定时器，并在收到watermark时触发。任务可以在计时器服务中注册定时器，以便在将来特定的时间点执行计算。例如，窗口算子为每个活动窗口注册一个定时器，当事件时间超过窗口的结束时间时，该计时器将清除窗口的状态。</p>
</div>
<div class="paragraph">
<p>当任务收到watermark时，将执行以下操作：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>任务根据watermark的时间戳更新其内部事件时钟。</p>
</li>
<li>
<p>任务的时间服务会将所有过期的计时器标识出来，它们的时间小于当前的事件时间。对于每个过期的计时器，任务调用一个回调函数，该函数可以执行计算并发送结果。</p>
</li>
<li>
<p>任务会发出一个带有更新后的事件时间的watermark。</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Flink限制通过DataStream API访问时间戳和watermark。函数不能读取或修改数据的时间戳和watermark，但底层的“处理函数”（process functions）除外，它们可以读取当前处理数据的时间戳、请求算子的当前事件时间，还可以注册定时器。通常的函数都不会暴露这些可以设置时间戳、操作任务事件时间时钟、或者发出水位线的API。而基于时间的数据流算子任务则会配置发送出的数据的时间戳，以确保它们能够与已到达的水位线平齐。例如，窗口计算完成后，时间窗口的算子任务会将窗口的结束时间作为时间戳附加到将要发送出的结果数据上，然后再使用触发窗口计算的时间戳发出watermark。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>现在，让我们更详细地解释一下任务在接收到新的watermark时，如何继续发送watermark并更新其事件时钟。正如我们在“数据并发和任务并发”中所了解的，Flink将数据流拆分为多个分区，并通过单独的算子任务并行地处理每个分区。每个分区都是一个流，里面包含了带着时间戳的数据和watermark。一个算子与它前置或后续算子的连接方式有多种情况，所以它对应的任务可以从一个或多个“输入分区”接收数据和watermark，同时也可以将数据和watermark发送到一个或多个“输出分区”。接下来，我们将详细描述一个任务如何向多个输出任务发送watermark，以及如何通过接收到的watermark来驱动事件时间时钟前进。</p>
</div>
<div class="paragraph">
<p>任务为每个输入分区维护一个分区水位线（watermark）。当从一个分区接收到watermark时，它会比较新接收到的值和当前水位值，然后将相应的分区watermark更新为两者的最大值。然后，任务会比较所有分区watermark的大小，将其事件时钟更新为所有分区watermark的最小值。如果事件时间时钟前进了，任务就将处理所有被触发的定时器操作，并向所有连接的输出分区发送出相应的watermark，最终将新的事件时间广播给所有下游任务。</p>
</div>
<div class="paragraph">
<p>图3-9显示了具有四个输入分区和三个输出分区的任务如何接收watermark、更新分区watermark和事件时间时钟，以及向下游发出watermark。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/spaf_0309.png" alt="spaf 0309">
</div>
</div>
<div class="paragraph">
<p>具有两个或多个输入流（如Union或CoFlatMap）的算子任务（参见“多流转换”一节）也会以所有分区watermark的最小值作为事件时间时钟。它们并不区分不同输入流的分区watermark，所以两个输入流的数据都是基于相同的事件时间时钟进行处理的。当然我们可以想到，如果应用程序的各个输入流的事件时间不一致，那么这种处理方式可能会导致问题。</p>
</div>
<div class="paragraph">
<p>Flink的水位处理和传递算法，确保了算子任务发出的时间戳和watermark是“对齐”的。不过它依赖一个条件，那就是所有分区都会提供不断增长的watermark。一旦一个分区不再推进水位线的上升，或者完全处于空闲状态、不再发送任何数据和watermark，任务的事件时间时钟就将停滞不前，任务的定时器也就无法触发了。对于基于时间的算子来说，它们需要依赖时钟的推进来执行计算和清除状态，这种情况显然就会有问题。如果任务没有定期从所有输入任务接收到新的watermark，那么基于时间的算子的处理延迟和状态空间的大小都会显著增加。</p>
</div>
<div class="paragraph">
<p>对于具有两个输入流而且watermark明显不同的算子，也会出现类似的情况。具有两个输入流的任务的事件时间时钟，将会同较慢的那条流的watermark保持一致，而通常较快流的数据或者中间结果会在state中缓冲，直到事件时间时钟达到这条流的watermark，才会允许处理它们。</p>
</div>
</div>
<div class="sect3">
<h4 id="_时间戳的分配和水位线的产生">5.8.4. 时间戳的分配和水位线的产生</h4>
<div class="paragraph">
<p>我们已经解释了什么是时间戳和水位线，以及它们是如何由Flink内部处理的；然而我们还没有讨论它们的产生。流应用程序接收到数据流时，通常就会先分配时间戳并生成水位线（watermark）。因为时间戳的选择是由不同的应用程序决定的，而且watermark取决于时间戳和流的特性，所以应用程序必须首先显式地分配时间戳并生成watermark。Flink流应用程序可以通过三种方式分配时间戳和生成watermark：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>在数据源（source）处分配：当数据流被摄入到应用程序中时，可以由“源函数”SourceFunction分配和生成时间戳和watermark。SourceFunction可以产生并发送一个数据流；数据会与相关的时间戳一起发送出去，而watermark可以作为一条特殊数据在任何时间点发出。如果SourceFunction（暂时）不再发出watermark，它可以声明自己处于“空闲”（idle）状态。Flink会在后续算子的水位计算中，把空闲的SourceFunction产生的流分区排除掉。source的这一空闲机制，可以用来解决前面提到的水位不再上升的问题。源函数（Source Function）在“实现自定义源函数”一节中进行了更详细的讨论。</p>
</li>
<li>
<p>定期分配：在Flink中，DataStream API提供一个名为AssignerWithPeriodicWatermarks的用户定义函数，它可以从每个数据中提取时间戳，并被定期调用以生成当前watermark。提取出的时间戳被分配给相应的数据，而生成的watermark也会添加到流中。这个函数将在“分配时间戳和生成水位线”一节中讨论。</p>
</li>
<li>
<p>间断分配：AssignerWithPunctuatedWatermarks是另一个用户定义的函数，它同样会从每个数据中提取一个时间戳。它可以用于生成特殊输入数据中的watermark。与AssignerWithPeriodicWatermarks相比，此函数可以（但不是必须）从每个记录中提取watermark。我们在“分配时间戳和生成水位线”一节中同样讨论了该函数。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>用户定义的时间戳分配函数并没有严格的限制，通常会放在尽可能靠近source算子的位置，因为当经过一些算子处理后，数据及其时间戳的顺序就更加难以解释了。所以尽管我们可以在流应用程序的中段覆盖已有的时间戳和watermark——Flink通过用户定义的函数提供了这种灵活性，但这显然并不是推荐的做法。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_状态管理">5.9. 状态管理</h3>
<div class="paragraph">
<p>在第2章中，我们已经知道大多数流应用程序都是有状态的。许多算子会不断地读取和更新状态，例如在窗口中收集的数据、读取输入源的位置，或者像机器学习模型那样的用户定制化的算子状态。 Flink用同样的方式处理所有的状态，无论是内置的还是用户自定义的算子。本节我们将会讨论Flink支持的不同类型的状态，并解释“状态后端”是如何存储和维护状态的。</p>
</div>
<div class="paragraph">
<p>一般来说，由一个任务维护，并且用来计算某个结果的所有数据，都属于这个任务的状态。你可以认为状态就是一个本地变量，可以被任务的业务逻辑访问。图3-10显示了任务与其状态之间的交互。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/spaf_0310.png" alt="spaf 0310">
</div>
</div>
<div class="paragraph">
<p>任务会接收一些输入数据。在处理数据时，任务可以读取和更新状态，并根据输入数据和状态计算结果。最简单的例子，就是统计接收到多少条数据的任务。当任务收到新数据时，它会访问状态以获取当前的计数，然后让计数递增，更新状态并发送出新的计数。</p>
</div>
<div class="paragraph">
<p>应用程序里，读取和写入状态的逻辑一般都很简单直接，而有效可靠的状态管理会复杂一些。这包括如何处理很大的状态——可能会超过内存，并且保证在发生故障时不会丢失任何状态。幸运的是，Flink会帮我们处理这相关的所有问题，包括状态一致性、故障处理以及高效存储和访问，以便开发人员可以专注于应用程序的逻辑。</p>
</div>
<div class="paragraph">
<p>在Flink中，状态始终与特定算子相关联。为了使运行时的Flink了解算子的状态，算子需要预先注册其状态。总的说来，有两种类型的状态：算子状态（operator state）和键控状态（keyed state），它们有着不同的范围访问，我们将在下面展开讨论。</p>
</div>
<div class="sect3">
<h4 id="_算子状态">5.9.1. 算子状态</h4>
<div class="paragraph">
<p>算子状态的作用范围限定为算子任务。这意味着由同一并行任务所处理的所有数据都可以访问到相同的状态，状态对于同一任务而言是共享的。算子状态不能由相同或不同算子的另一个任务访问。图3-11显示了任务如何访问算子状态。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/spaf_0311.png" alt="spaf 0311">
</div>
</div>
<div class="paragraph">
<p>Flink为算子状态提供三种基本数据结构：</p>
</div>
<div class="sect4">
<h5 id="_列表状态list_state">列表状态（List state）</h5>
<div class="paragraph">
<p>将状态表示为一组数据的列表。</p>
</div>
</div>
<div class="sect4">
<h5 id="_联合列表状态union_list_state">联合列表状态（Union list state）</h5>
<div class="paragraph">
<p>也将状态表示为数据的列表。它与常规列表状态的区别在于，在发生故障时，或者从保存点（savepoint）启动应用程序时如何恢复。我们将在后面继续讨论。</p>
</div>
</div>
<div class="sect4">
<h5 id="_广播状态broadcast_state">广播状态（Broadcast state）</h5>
<div class="paragraph">
<p>如果一个算子有多项任务，而它的每项任务状态又都相同，那么这种特殊情况最适合应用广播状态。在保存检查点和重新调整算子并行度时，会用到这个特性。这两部分内容将在本章后面讨论。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_键控状态keyed_state">5.9.2. 键控状态（Keyed State）</h4>
<div class="paragraph">
<p>顾名思义，键控状态是根据输入数据流中定义的键（key）来维护和访问的。Flink为每个键值维护一个状态实例，并将具有相同键的所有数据，都分区到同一个算子任务中，这个任务会维护和处理这个key对应的状态。当任务处理一条数据时，它会自动将状态的访问范围限定为当前数据的key。因此，具有相同key的所有数据都会访问相同的状态。图3-12显示了任务如何与键控状态进行交互。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/spaf_0312.png" alt="spaf 0312">
</div>
</div>
<div class="paragraph">
<p>我们可以将键控状态看成是在算子所有并行任务上，对键进行分区（或分片）之后的一个键值映射（key-value map）。 Flink为键控状态提供不同的数据结构，用于确定map中每个key存储的值的类型。我们简单了解一下最常见的键控状态。</p>
</div>
<div class="sect4">
<h5 id="_值状态value_state">值状态（Value state）</h5>
<div class="paragraph">
<p>为每个键存储一个任意类型的单个值。复杂数据结构也可以存储为值状态。</p>
</div>
</div>
<div class="sect4">
<h5 id="_列表状态list_state_2">列表状态（List state）</h5>
<div class="paragraph">
<p>为每个键存储一个值的列表。列表里的每个数据可以是任意类型。</p>
</div>
</div>
<div class="sect4">
<h5 id="_映射状态map_state">映射状态（Map state）</h5>
<div class="paragraph">
<p>为每个键存储一个键值映射（map）。map的key和value可以是任意类型。</p>
</div>
<div class="paragraph">
<p>状态的数据结构可以让Flink实现更有效的状态访问。我们将在“在运行时上下文（RuntimeContext）中声明键控状态”中做进一步讨论。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_状态后端state_backends">5.9.3. 状态后端（State Backends）</h4>
<div class="paragraph">
<p>每传入一条数据，有状态的算子任务都会读取和更新状态。由于有效的状态访问对于处理数据的低延迟至关重要，因此每个并行任务都会在本地维护其状态，以确保快速的状态访问。状态到底是如何被存储、访问以及维护的？这件事由一个可插入的组件决定，这个组件就叫做状态后端（state backend）。状态后端主要负责两件事：本地的状态管理，以及将检查点（checkpoint）状态写入远程存储。</p>
</div>
<div class="paragraph">
<p>对于本地状态管理，状态后端会存储所有键控状态，并确保所有的访问都被正确地限定在当前键范围。 Flink提供了默认的状态后端，会将键控状态作为内存中的对象进行管理，将它们存储在JVM堆上。另一种状态后端则会把状态对象进行序列化，并将它们放入RocksDB中，然后写入本地硬盘。第一种方式可以提供非常快速的状态访问，但它受内存大小的限制；而访问RocksDB状态后端存储的状态速度会较慢，但其状态可以增长到非常大。</p>
</div>
<div class="paragraph">
<p>状态检查点的写入也非常重要，这是因为Flink是一个分布式系统，而状态只能在本地维护。 TaskManager进程（所有任务在其上运行）可能在任何时间点挂掉。因此，它的本地存储只能被认为是不稳定的。状态后端负责将任务的状态检查点写入远程的持久存储。写入检查点的远程存储可以是分布式文件系统，也可以是数据库。不同的状态后端在状态检查点的写入机制方面有所不同。例如，RocksDB状态后端支持增量的检查点，这对于非常大的状态来说，可以显著减少状态检查点写入的开销。</p>
</div>
<div class="paragraph">
<p>我们将在“选择状态后端”一节中更详细地讨论不同的状态后端及其优缺点。</p>
</div>
</div>
<div class="sect3">
<h4 id="_调整有状态算子的并行度">5.9.4. 调整有状态算子的并行度</h4>
<div class="paragraph">
<p>流应用程序的一个常见要求是，为了增大或较小输入数据的速率，需要灵活地调整算子的并行度。对于无状态算子而言，并行度的调整没有任何问题，但更改有状态算子的并行度显然就没那么简单了，因为它们的状态需要重新分区并分配给更多或更少的并行任务。 Flink支持四种模式来调整不同类型的状态。</p>
</div>
<div class="paragraph">
<p>具有键控状态的算子通过将键重新分区为更少或更多任务来缩放并行度。不过，并行度调整时任务之间会有一些必要的状态转移。为了提高效率，Flink并不会对单独的key做重新分配，而是用所谓的“键组”（key group）把键管理起来。键组是key的分区形式，同时也是Flink为任务分配key的方式。图3-13显示了如何在键组中重新分配键控状态。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/spaf_0313.png" alt="spaf 0313">
</div>
</div>
<div class="paragraph">
<p>具有算子列表状态的算子，会通过重新分配列表中的数据项目来进行并行度缩放。从概念上讲，所有并行算子任务的列表项目会被收集起来，并将其均匀地重新分配给更少或更多的任务。如果列表条目少于算子的新并行度，则某些任务将以空状态开始。图3-14显示了算子列表状态的重新分配。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/spaf_0314.png" alt="spaf 0314">
</div>
</div>
<div class="paragraph">
<p>具有算子联合列表状态的算子，会通过向每个任务广播状态的完整列表，来进行并行度的缩放。然后，任务可以选择要使用的状态项和要丢弃的状态项。图3-15显示了如何重新分配算子联合列表状态。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/spaf_0315.png" alt="spaf 0315">
</div>
</div>
<div class="paragraph">
<p>具有算子广播状态的算子，通过将状态复制到新任务，来增大任务的并行度。这是没问题的，因为广播状态保证了所有任务都具有相同的状态。而对于缩小并行度的情况，我们可以直接取消剩余任务，因为状态是相同的，已经被复制并且不会丢失。图3-16显示了算子广播状态的重新分配。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/spaf_0316.png" alt="spaf 0316">
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_检查点保存点和状态恢复">5.10. 检查点，保存点和状态恢复</h3>
<div class="paragraph">
<p>Flink是一个分布式数据处理系统，因此必须有一套机制处理各种故障，比如被杀掉的进程，故障的机器和中断的网络连接。任务都是在本地维护状态的，所以Flink必须确保状态不会丢失，并且在发生故障时能够保持一致。</p>
</div>
<div class="paragraph">
<p>在本节中，我们将介绍Flink的检查点（checkpoint）和恢复机制，这保证了“精确一次”（exactly-once）的状态一致性。我们还会讨论Flink独特的保存点（savepoint）功能，这是一个“瑞士军刀”式的工具，可以解决许多操作数据流时面对的问题。</p>
</div>
<div class="sect3">
<h4 id="_一致的检查点checkpoints">5.10.1. 一致的检查点（Checkpoints）</h4>
<div class="paragraph">
<p>Flink的恢复机制的核心，就是应用状态的一致检查点。有状态流应用的一致检查点，其实就是所有任务状态在某个时间点的一份拷贝，而这个时间点应该是所有任务都恰好处理完一个相同的输入数据的时候。这个过程可以通过一致检查点的一个简单算法步骤来解释。这个算法的步骤是：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>暂停所有输入流的摄取，也就是不再接收新数据的输入。</p>
</li>
<li>
<p>等待所有正在处理的数据计算完毕，这意味着结束时，所有任务都已经处理了所有输入数据。</p>
</li>
<li>
<p>通过将每个任务的状态复制到远程持久存储，来得到一个检查点。所有任务完成拷贝操作后，检查点就完成了。</p>
</li>
<li>
<p>恢复所有输入流的摄取。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>需要注意，Flink实现的并不是这种简单的机制。我们将在本节后面介绍Flink更精妙的检查点算法。</p>
</div>
<div class="paragraph">
<p>图3-17显示了一个简单应用中的一致检查点。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/spaf_0317.png" alt="spaf 0317">
</div>
</div>
<div class="paragraph">
<p>上面的应用程序中具有单一的输入源（source）任务，输入数据就是一组不断增长的数字的流——1,2,3等。数字流被划分为偶数流和奇数流。求和算子（sum）的两个任务会分别实时计算当前所有偶数和奇数的总和。源任务会将其输入流的当前偏移量存储为状态，而求和任务则将当前的总和值存储为状态。在图3-17中，Flink在输入偏移量为5时，将检查点写入了远程存储，当前的总和为6和9。</p>
</div>
</div>
<div class="sect3">
<h4 id="_从一致检查点中恢复状态">5.10.2. 从一致检查点中恢复状态</h4>
<div class="paragraph">
<p>在执行流应用程序期间，Flink会定期检查状态的一致检查点。如果发生故障，Flink将会使用最近的检查点来一致恢复应用程序的状态，并重新启动处理流程。图3-18显示了恢复过程。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/spaf_0318.png" alt="spaf 0318">
</div>
</div>
<div class="paragraph">
<p>应用程序从检查点的恢复分为三步：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>重新启动整个应用程序。</p>
</li>
<li>
<p>将所有的有状态任务的状态重置为最近一次的检查点。</p>
</li>
<li>
<p>恢复所有任务的处理。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这种检查点的保存和恢复机制可以为应用程序状态提供“精确一次”（exactly-once）的一致性，因为所有算子都会保存检查点并恢复其所有状态，这样一来所有的输入流就都会被重置到检查点完成时的位置。至于数据源是否可以重置它的输入流，这取决于其实现方式和消费流数据的外部接口。例如，像Apache Kafka这样的事件日志系统可以提供流上之前偏移位置的数据，所以我们可以将源重置到之前的偏移量，重新消费数据。而从套接字（socket）消费数据的流就不能被重置了，因为套接字的数据一旦被消费就会丢弃掉。因此，对于应用程序而言，只有当所有的输入流消费的都是可重置的数据源时，才能确保在“精确一次”的状态一致性下运行。</p>
</div>
<div class="paragraph">
<p>从检查点重新启动应用程序后，其内部状态与检查点完成时的状态完全相同。然后它就会开始消费并处理检查点和发生故障之间的所有数据。尽管这意味着Flink会对一些数据处理两次（在故障之前和之后），我们仍然可以说这个机制实现了精确一次的一致性语义，因为所有算子的状态都已被重置，而重置后的状态下还不曾看到这些数据。</p>
</div>
<div class="paragraph">
<p>我们必须指出，Flink的检查点保存和恢复机制仅仅可以重置流应用程序的内部状态。对于应用中的一些的输出（sink）算子，在恢复期间，某些结果数据可能会多次发送到下游系统，比如事件日志、文件系统或数据库。对于某些存储系统，Flink提供了具有精确一次输出功​​能的sink函数，比如，可以在检查点完成时提交发出的记录。另一种适用于许多存储系统的方法是幂等更新。在“应用程序一致性保证”一节中，我们还会详细讨论如何解决应用程序端到端的精确一次一致性问题。</p>
</div>
</div>
<div class="sect3">
<h4 id="_flink的检查点算法">5.10.3. Flink的检查点算法</h4>
<div class="paragraph">
<p>Flink的恢复机制，基于它的一致性检查点。前面我们已经了解了从流应用中创建检查点的简单方法——先暂停应用，保存检查点，然后再恢复应用程序，这种方法很好理解，但它的理念是“停止一切”，这对于即使是中等延迟要求的应用程序而言也是不实用的。所以Flink没有这么简单粗暴，而是基于Chandy-Lamport算法实现了分布式快照的检查点保存。该算法并不会暂停整个应用程序，而是将检查点的保存与数据处理分离，这样就可以实现在其它任务做检查点状态保存状态时，让某些任务继续进行而不受影响。接下来我们将解释此算法的工作原理。</p>
</div>
<div class="paragraph">
<p>Flink的检查点算法用到了一种称为“检查点分界线”（checkpoint barrier）的特殊数据形式。与水位线（watermark）类似，检查点分界线由source算子注入到常规的数据流中，它的位置是限定好的，不能超过其他数据，也不能被后面的数据超过。检查点分界线带有检查点ID，用来标识它所属的检查点；这样，这个分界线就将一条流逻辑上分成了两部分。分界线之前到来的数据导致的状态更改，都会被包含在当前分界线所属的检查点中；而基于分界线之后的数据导致的所有更改，就会被包含在之后的检查点中。</p>
</div>
<div class="paragraph">
<p>我们用一个简单的流应用程序作为示例，来一步一步解释这个算法。该应用程序有两个源（source）任务，每个任务都消费一个增长的数字流。源任务的输出被划分为两部分：偶数和奇数的流。每个分区由一个任务处理，该任务计算所有收到的数字的总和，并将更新的总和转发给输出（sink）任务。这个应用程序的结构如图3-19所示。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/spaf_0319.png" alt="spaf 0319">
</div>
</div>
<div class="paragraph">
<p>JobManager会向每个数据源（source）任务发送一条带有新检查点ID的消息，通过这种方式来启动检查点，如图3-20所示。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/spaf_0320.png" alt="spaf 0320">
</div>
</div>
<div class="paragraph">
<p>当source任务收到消息时，它会暂停发出新的数据，在状态后端触发本地状态的检查点保存，并向所有传出的流分区广播带着检查点ID的分界线（barriers）。状态后端在状态检查点完成后会通知任务，而任务会向JobManager确认检查点完成。在发出所有分界线后，source任务就可以继续常规操作，发出新的数据了。通过将分界线注入到输出流中，源函数（source function）定义了检查点在流中所处的位置。图3-21显示了两个源任务将本地状态保存到检查点，并发出检查点分界线之后的流应用程序。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/spaf_0321.png" alt="spaf 0321">
</div>
</div>
<div class="paragraph">
<p>源任务发出的检查点分界线（barrier），将被传递给所连接的任务。与水位线（watermark）类似，barrier会被广播到所有连接的并行任务，以确保每个任务从它的每个输入流中都能接收到。当任务收到一个新检查点的barrier时，它会等待这个检查点的所有输入分区的barrier到达。在等待的过程中，任务并不会闲着，而是会继续处理尚未提供barrier的流分区中的数据。对于那些barrier已经到达的分区，如果继续有新的数据到达，它们就不会被立即处理，而是先缓存起来。这个等待所有分界线到达的过程，称为“分界线对齐”（barrier alignment），如图3-22所示。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/spaf_0322.png" alt="spaf 0322">
</div>
</div>
<div class="paragraph">
<p>当任务从所有输入分区都收到barrier时，它就会在状态后端启动一个检查点的保存，并继续向所有下游连接的任务广播检查点分界线，如图3-23所示。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/spaf_0323.png" alt="spaf 0323">
</div>
</div>
<div class="paragraph">
<p>所有的检查点barrier都发出后，任务就开始处理之前缓冲的数据。在处理并发出所有缓冲数据之后，任务就可以继续正常处理输入流了。图3-24显示了此时的应用程序。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/spaf_0324.png" alt="spaf 0324">
</div>
</div>
<div class="paragraph">
<p>最终，检查点分界线会到达输出（sink）任务。当sink任务接收到barrier时，它也会先执行“分界线对齐”，然后将自己的状态保存到检查点，并向JobManager确认已接收到barrier。一旦从应用程序的所有任务收到一个检查点的确认信息，JobManager就会将这个检查点记录为已完成。图3-25显示了检查点算法的最后一步。这样，当发生故障时，我们就可以用已完成的检查点恢复应用程序了。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/spaf_0325.png" alt="spaf 0325">
</div>
</div>
</div>
<div class="sect3">
<h4 id="_检查点的性能影响">5.10.4. 检查点的性能影响</h4>
<div class="paragraph">
<p>Flink的检查点算法可以在不停止整个应用程序的情况下，生成一致的分布式检查点。但是，它可能会增加应用程序的处理延迟。Flink对此有一些调整措施，可以在某些场景下显得对性能的影响没那么大。</p>
</div>
<div class="paragraph">
<p>当任务将其状态保存到检查点时，它其实处于一个阻塞状态，而此时新的输入会被缓存起来。由于状态可能变得非常大，而且检查点需要通过网络将数据写入远程存储系统，检查点的写入很容易就会花费几秒到几分钟的时间——这对于要求低延迟的应用程序而言，显然是不可接受的。在Flink的设计中，真正负责执行检查点写入的，其实是状态后端。具体怎样复制任务的状态，取决于状态后端的实现方式。例如，文件系统（FileSystem）状态后端和RocksDB状态后端都支持了异步（asynchronous）检查点。触发检查点操作时，状态后端会先创建状态的本地副本。本地拷贝完成后，任务就将继续常规的数据处理，这往往并不会花费太多时间。一个后台线程会将本地快照异步复制到远程存储，并在完成检查点后再回来通知任务。异步检查点的机制，显著减少了任务继续处理数据之前的等待时间。此外，RocksDB状态后端还实现了增量的检查点，这样可以大大减少要传输的数据量。</p>
</div>
<div class="paragraph">
<p>为了减少检查点算法对处理延迟的影响，另一种技术是调整分界线对齐的步骤。对于需要非常低的延迟、并且可以容忍“至少一次”（at-least-once）状态保证的应用程序，Flink可以将检查点算法配置为，在等待barrier对齐期间处理所有到达的数据，而不是把barrier已经到达的那些分区的数据缓存起来。当检查点的所有barrier到达，算子任务就会将状态写入检查点——当然，现在的状态中，就可能包括了一些“提前”的更改，这些更改由本该属于下一个检查点的数据到来时触发。如果发生故障，从检查点恢复时，就将再次处理这些数据：这意味着检查点现在提供的是“至少一次”（at-least-once）而不是“精确一次”（exactly-once）的一致性保证。</p>
</div>
</div>
<div class="sect3">
<h4 id="_保存点savepoints">5.10.5. 保存点（Savepoints）</h4>
<div class="paragraph">
<p>Flink的恢复算法是基于状态检查点的。Flink根据可配置的策略，定期保存并自动丢弃检查点。检查点的目的是确保在发生故障时可以重新启动应用程序，所以当应用程序被显式地撤销（cancel）时，检查点会被删除掉。除此之外，应用程序状态的一致性快照还可用于除故障恢复之外的更多功能。</p>
</div>
<div class="paragraph">
<p>Flink中一个最有价值，也是最独特的功能是保存点（savepoints）。原则上，创建保存点使用的算法与检查点完全相同，因此保存点可以认为就是具有一些额外元数据的检查点。 Flink不会自动创建保存点，因此用户（或者外部调度程序）必须明确地触发创建操作。同样，Flink也不会自动清理保存点。第10章将会具体介绍如何触发和处理保存点。</p>
</div>
<div class="sect4">
<h5 id="_使用保存点">使用保存点</h5>
<div class="paragraph">
<p>有了应用程序和与之兼容的保存点，我们就可以从保存点启动应用程序了。这会将应用程序的状态初始化为保存点的状态，并从保存点创建时的状态开始运行应用程序。虽然看起来这种行为似乎与用检查点从故障中恢复应用程序完全相同，但实际上故障恢复只是一种特殊情况，它只是在相同的集群上以相同的配置启动相同的应用程序。而从保存点启动应用程序会更加灵活，这就可以让我们做更多事情了。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>可以从保存点启动不同但兼容的应用程序。这样一来，我们就可以及时修复应用程序中的逻辑bug，并让流式应用的源尽可能多地提供之前发生的事件，然后重新处理，以便修复之前的计算结果。修改后的应用程序还可用于运行A / B测试，或者具有不同业务逻辑的假设场景。这里要注意，应用程序和保存点必须兼容才可以这么做——也就是说，应用程序必须能够加载保存点的状态。</p>
</li>
<li>
<p>可以使用不同的并行度来启动相同的应用程序，可以将应用程序的并行度增大或减小。</p>
</li>
<li>
<p>可以在不同的集群上启动同样的应用程序。这非常有意义，意味着我们可以将应用程序迁移到较新的Flink版本或不同的集群上去。</p>
</li>
<li>
<p>可以使用保存点暂停应用程序，稍后再恢复。这样做的意义在于，可以为更高优先级的应用程序释放集群资源，或者在输入数据不连续生成时释放集群资源。</p>
</li>
<li>
<p>还可以将保存点设置为某一版本，并归档（archive）存储应用程序的状态。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>保存点是非常强大的功能，所以许多用户会定期创建保存点以便能够及时退回之前的状态。我们见到的各种场景中，保存点一个最有趣的应用是不断将流应用程序迁移到更便宜的数据中心上去。</p>
</div>
</div>
<div class="sect4">
<h5 id="_从保存点启动应用程序">从保存点启动应用程序</h5>
<div class="paragraph">
<p>前面提到的保存点的所有用例，都遵循相同的模式。那就是首先创建正在运行的应用程序的保存点，然后在一个新启动的应用程序中用它来恢复状态。之前我们已经知道，保存点的创建和检查点非常相似，而接下来我们就将介绍对于一个从保存点启动的应用程序，Flink如何初始化其状态。</p>
</div>
<div class="paragraph">
<p>应用程序由多个算子组成。每个算子可以定义一个或多个键控状态和算子状态。算子由一个或多个算子任务并行执行。因此，一个典型的应用程序会包含多个状态，这些状态分布在多个算子任务中，这些任务可以运行在不同的TaskManager进程上。</p>
</div>
<div class="paragraph">
<p>图3-26显示了一个具有三个算子的应用程序，每个算子执行两个算子任务。一个算子（OP-1）具有单一的算子状态（OS-1），而另一个算子（OP-2）具有两个键控状态（KS-1和KS-2）。当保存点创建时，会将所有任务的状态复制到持久化的存储位置。</p>
</div>
<div class="paragraph">
<p>保存点中的状态拷贝会以算子标识符（operator ID）和状态名称（state name）组织起来。算子ID和状态名称必须能够将保存点的状态数据，映射到一个正在启动的应用程序的算子状态。从保存点启动应用程序时，Flink会将保存点的数据重新分配给相应的算子任务。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
请注意，保存点不包含有关算子任务的信息。这是因为当应用程序以不同的并行度启动时，任务数量可能会更改。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>如果我们要从保存点启动一个修改过的应用程序，那么保存点中的状态只能映射到符合标准的应用程序——它里面的算子必须具有相应的ID和状态名称。默认情况下，Flink会自动分配唯一的算子ID。然而，一个算子的ID，是基于它之前算子的ID确定性地生成的。因此，算子的ID会在其前序算子改变时改变，比如，当我们添加了新的或移除掉一个算子时，前序算子ID改变，当前算子ID就会变化。所以对于具有默认算子ID的应用程序而言，如果想在不丢失状态的前提下升级，就会受到极大的限制。因此，我们强烈建议在程序中为算子手动分配唯一ID，而不是依靠Flink的默认分配。我们将在“指定唯一的算子标识符”一节中详细说明如何分配算子标识符。</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_flink_datastream_api">6. Flink DataStream API</h2>
<div class="sectionbody">
<div class="imageblock">
<div class="content">
<img src="images/dot-example.png" alt="dot example">
</div>
</div>
<div class="sect2">
<h3 id="_environment">6.1. Environment</h3>
<div class="paragraph">
<p><strong>getExecutionEnvironment</strong></p>
</div>
<div class="paragraph">
<p>创建一个执行环境，表示当前执行程序的上下文。如果程序是独立调用的，则此方法返回本地执行环境；如果从命令行客户端调用程序以提交到集群，则此方法返回此集群的执行环境，也就是说，getExecutionEnvironment会根据查询运行的方式决定返回什么样的运行环境，是最常用的一种创建执行环境的方式。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-c1">// 获取执行环境</span>
<span class="tok-k">val</span> <span class="tok-n">env</span><span class="tok-k">:</span> <span class="tok-kt">ExecutionEnvironment</span> <span class="tok-o">=</span> <span class="tok-nc">StreamExecutionEnvironment</span>
  <span class="tok-o">.</span><span class="tok-n">getExecutionEnvironment</span>
<span class="tok-c1">// 设置流的时间为Event Time</span>
<span class="tok-n">env</span><span class="tok-o">.</span><span class="tok-n">setStreamTimeCharacteristic</span><span class="tok-o">(</span><span class="tok-nc">TimeCharacteristic</span><span class="tok-o">.</span><span class="tok-nc">EventTime</span><span class="tok-o">)</span>
<span class="tok-c1">// 设置并行度为1，如果不设置，那么默认为当前机器的cpu的数量</span>
<span class="tok-n">env</span><span class="tok-o">.</span><span class="tok-n">setParallelism</span><span class="tok-o">(</span><span class="tok-mi">1</span><span class="tok-o">)</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_source">6.2. Source</h3>
<div class="paragraph">
<p>从批读取数据</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-c1">// 传感器id，时间戳，温度</span>
<span class="tok-k">case</span> <span class="tok-k">class</span> <span class="tok-nc">SensorReading</span><span class="tok-o">(</span>
  <span class="tok-n">id</span><span class="tok-k">:</span> <span class="tok-kt">String</span><span class="tok-o">,</span>
  <span class="tok-n">timestamp</span><span class="tok-k">:</span> <span class="tok-kt">Long</span><span class="tok-o">,</span>
  <span class="tok-n">temperature</span><span class="tok-k">:</span> <span class="tok-kt">Double</span>
<span class="tok-o">)</span>

<span class="tok-k">val</span> <span class="tok-n">stream</span> <span class="tok-k">=</span> <span class="tok-n">env</span>
  <span class="tok-o">.</span><span class="tok-n">fromCollection</span><span class="tok-o">(</span><span class="tok-nc">List</span><span class="tok-o">(</span>
    <span class="tok-nc">SensorReading</span><span class="tok-o">(</span><span class="tok-s">&quot;sensor_1&quot;</span><span class="tok-o">,</span> <span class="tok-mi">1547718199</span><span class="tok-o">,</span> <span class="tok-mf">35.80018327300259</span><span class="tok-o">),</span>
    <span class="tok-nc">SensorReading</span><span class="tok-o">(</span><span class="tok-s">&quot;sensor_6&quot;</span><span class="tok-o">,</span> <span class="tok-mi">1547718199</span><span class="tok-o">,</span> <span class="tok-mf">15.402984393403084</span><span class="tok-o">),</span>
    <span class="tok-nc">SensorReading</span><span class="tok-o">(</span><span class="tok-s">&quot;sensor_7&quot;</span><span class="tok-o">,</span> <span class="tok-mi">1547718199</span><span class="tok-o">,</span> <span class="tok-mf">6.720945201171228</span><span class="tok-o">),</span>
    <span class="tok-nc">SensorReading</span><span class="tok-o">(</span><span class="tok-s">&quot;sensor_10&quot;</span><span class="tok-o">,</span> <span class="tok-mi">1547718199</span><span class="tok-o">,</span> <span class="tok-mf">38.101067604893444</span><span class="tok-o">)</span>
  <span class="tok-o">))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>从文件读取数据</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">val</span> <span class="tok-n">stream</span> <span class="tok-k">=</span> <span class="tok-n">env</span><span class="tok-o">.</span><span class="tok-n">readTextFile</span><span class="tok-o">(</span><span class="tok-n">filePath</span><span class="tok-o">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>以Kafka消息队列的数据为数据来源</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">val</span> <span class="tok-n">properties</span> <span class="tok-k">=</span> <span class="tok-k">new</span> <span class="tok-nc">Properties</span><span class="tok-o">()</span>
<span class="tok-n">properties</span><span class="tok-o">.</span><span class="tok-n">setProperty</span><span class="tok-o">(</span><span class="tok-s">&quot;bootstrap.servers&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;localhost:9092&quot;</span><span class="tok-o">)</span>
<span class="tok-n">properties</span><span class="tok-o">.</span><span class="tok-n">setProperty</span><span class="tok-o">(</span><span class="tok-s">&quot;group.id&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;consumer-group&quot;</span><span class="tok-o">)</span>
<span class="tok-n">properties</span><span class="tok-o">.</span><span class="tok-n">setProperty</span><span class="tok-o">(</span><span class="tok-s">&quot;key.deserializer&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span><span class="tok-o">)</span>
<span class="tok-n">properties</span><span class="tok-o">.</span><span class="tok-n">setProperty</span><span class="tok-o">(</span><span class="tok-s">&quot;value.deserializer&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span><span class="tok-o">)</span>
<span class="tok-n">properties</span><span class="tok-o">.</span><span class="tok-n">setProperty</span><span class="tok-o">(</span><span class="tok-s">&quot;auto.offset.reset&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;latest&quot;</span><span class="tok-o">)</span>
<span class="tok-k">val</span> <span class="tok-n">env</span> <span class="tok-k">=</span> <span class="tok-nc">StreamExecutionEnvironment</span><span class="tok-o">.</span><span class="tok-n">getExecutionEnvironment</span>
<span class="tok-n">env</span><span class="tok-o">.</span><span class="tok-n">setStreamTimeCharacteristic</span><span class="tok-o">(</span><span class="tok-nc">TimeCharacteristic</span><span class="tok-o">.</span><span class="tok-nc">EventTime</span><span class="tok-o">)</span>
<span class="tok-n">env</span><span class="tok-o">.</span><span class="tok-n">setParallelism</span><span class="tok-o">(</span><span class="tok-mi">1</span><span class="tok-o">)</span>
<span class="tok-k">val</span> <span class="tok-n">stream</span> <span class="tok-k">=</span> <span class="tok-n">env</span>
  <span class="tok-c1">// source为来自Kafka的数据，这里我们实例化一个消费者，topic为hotitems</span>
  <span class="tok-o">.</span><span class="tok-n">addSource</span><span class="tok-o">(</span><span class="tok-k">new</span> <span class="tok-nc">FlinkKafkaConsumer</span><span class="tok-o">[</span><span class="tok-kt">String</span><span class="tok-o">](</span><span class="tok-s">&quot;hotitems&quot;</span><span class="tok-o">,</span> <span class="tok-k">new</span> <span class="tok-nc">SimpleStringSchema</span><span class="tok-o">(),</span> <span class="tok-n">properties</span><span class="tok-o">))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>我们也可以自定义Source，这里举一个例子。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">import</span> <span class="tok-nn">java.util.Calendar</span>

<span class="tok-k">import</span> <span class="tok-nn">org.apache.flink.streaming.api.functions.source.RichParallelSourceFunction</span>
<span class="tok-k">import</span> <span class="tok-nn">org.apache.flink.streaming.api.functions.source.SourceFunction.SourceContext</span>

<span class="tok-k">import</span> <span class="tok-nn">scala.util.Random</span>

<span class="tok-c1">// 传感器id，时间戳，温度</span>
<span class="tok-k">case</span> <span class="tok-k">class</span> <span class="tok-nc">SensorReading</span><span class="tok-o">(</span><span class="tok-n">id</span><span class="tok-k">:</span> <span class="tok-kt">String</span><span class="tok-o">,</span> <span class="tok-n">timestamp</span><span class="tok-k">:</span> <span class="tok-kt">Long</span><span class="tok-o">,</span> <span class="tok-n">temperature</span><span class="tok-k">:</span> <span class="tok-kt">Double</span><span class="tok-o">)</span>

<span class="tok-c1">// 需要extends RichParallelSourceFunction, 泛型为SensorReading</span>
<span class="tok-k">class</span> <span class="tok-nc">SensorSource</span> <span class="tok-k">extends</span> <span class="tok-nc">RichParallelSourceFunction</span><span class="tok-o">[</span><span class="tok-kt">SensorReading</span><span class="tok-o">]</span> <span class="tok-o">{</span>

  <span class="tok-c1">// flag indicating whether source is still running.</span>
  <span class="tok-c1">// flag: 表示数据源是否还在正常运行</span>
  <span class="tok-k">var</span> <span class="tok-n">running</span><span class="tok-k">:</span> <span class="tok-kt">Boolean</span> <span class="tok-o">=</span> <span class="tok-kc">true</span>

  <span class="tok-cm">/** run() continuously emits SensorReadings by emitting them through the SourceContext. */</span>
  <span class="tok-c1">// run()函数连续的发送SensorReading数据，使用SourceContext</span>
  <span class="tok-c1">// 需要override</span>
  <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">run</span><span class="tok-o">(</span><span class="tok-n">srcCtx</span><span class="tok-k">:</span> <span class="tok-kt">SourceContext</span><span class="tok-o">[</span><span class="tok-kt">SensorReading</span><span class="tok-o">])</span><span class="tok-k">:</span> <span class="tok-kt">Unit</span> <span class="tok-o">=</span> <span class="tok-o">{</span>

    <span class="tok-c1">// initialize random number generator</span>
    <span class="tok-c1">// 初始化随机数发生器</span>
    <span class="tok-k">val</span> <span class="tok-n">rand</span> <span class="tok-k">=</span> <span class="tok-k">new</span> <span class="tok-nc">Random</span><span class="tok-o">()</span>
    <span class="tok-c1">// look up index of this parallel task</span>
    <span class="tok-c1">// 查找当前运行时上下文的任务的索引</span>
    <span class="tok-k">val</span> <span class="tok-n">taskIdx</span> <span class="tok-k">=</span> <span class="tok-k">this</span><span class="tok-o">.</span><span class="tok-n">getRuntimeContext</span><span class="tok-o">.</span><span class="tok-n">getIndexOfThisSubtask</span>

    <span class="tok-c1">// initialize sensor ids and temperatures</span>
    <span class="tok-c1">// 初始化10个(温度传感器的id, 温度值)元组</span>
    <span class="tok-k">var</span> <span class="tok-n">curFTemp</span> <span class="tok-k">=</span> <span class="tok-o">(</span><span class="tok-mi">1</span> <span class="tok-n">to</span> <span class="tok-mi">10</span><span class="tok-o">).</span><span class="tok-n">map</span> <span class="tok-o">{</span>
      <span class="tok-c1">// nextGaussian产生高斯随机数</span>
      <span class="tok-n">i</span> <span class="tok-k">=&gt;</span> <span class="tok-o">(</span><span class="tok-s">&quot;sensor_&quot;</span> <span class="tok-o">+</span> <span class="tok-o">(</span><span class="tok-n">taskIdx</span> <span class="tok-o">*</span> <span class="tok-mi">10</span> <span class="tok-o">+</span> <span class="tok-n">i</span><span class="tok-o">),</span> <span class="tok-mi">65</span> <span class="tok-o">+</span> <span class="tok-o">(</span><span class="tok-n">rand</span><span class="tok-o">.</span><span class="tok-n">nextGaussian</span><span class="tok-o">()</span> <span class="tok-o">*</span> <span class="tok-mi">20</span><span class="tok-o">))</span>
    <span class="tok-o">}</span>

    <span class="tok-c1">// emit data until being canceled</span>
    <span class="tok-c1">// 无限循环，产生数据流</span>
    <span class="tok-k">while</span> <span class="tok-o">(</span><span class="tok-n">running</span><span class="tok-o">)</span> <span class="tok-o">{</span>

      <span class="tok-c1">// update temperature</span>
      <span class="tok-c1">// 更新温度</span>
      <span class="tok-n">curFTemp</span> <span class="tok-k">=</span> <span class="tok-n">curFTemp</span><span class="tok-o">.</span><span class="tok-n">map</span><span class="tok-o">(</span> <span class="tok-n">t</span> <span class="tok-k">=&gt;</span> <span class="tok-o">(</span><span class="tok-n">t</span><span class="tok-o">.</span><span class="tok-n">_1</span><span class="tok-o">,</span> <span class="tok-n">t</span><span class="tok-o">.</span><span class="tok-n">_2</span> <span class="tok-o">+</span> <span class="tok-o">(</span><span class="tok-n">rand</span><span class="tok-o">.</span><span class="tok-n">nextGaussian</span><span class="tok-o">()</span> <span class="tok-o">*</span> <span class="tok-mf">0.5</span><span class="tok-o">))</span> <span class="tok-o">)</span>
      <span class="tok-c1">// get current time</span>
      <span class="tok-c1">// 获取当前时间戳</span>
      <span class="tok-k">val</span> <span class="tok-n">curTime</span> <span class="tok-k">=</span> <span class="tok-nc">Calendar</span><span class="tok-o">.</span><span class="tok-n">getInstance</span><span class="tok-o">.</span><span class="tok-n">getTimeInMillis</span>

      <span class="tok-c1">// emit new SensorReading</span>
      <span class="tok-c1">// 发射新的传感器数据, 注意这里srcCtx.collect</span>
      <span class="tok-n">curFTemp</span><span class="tok-o">.</span><span class="tok-n">foreach</span><span class="tok-o">(</span> <span class="tok-n">t</span> <span class="tok-k">=&gt;</span> <span class="tok-n">srcCtx</span><span class="tok-o">.</span><span class="tok-n">collect</span><span class="tok-o">(</span><span class="tok-nc">SensorReading</span><span class="tok-o">(</span><span class="tok-n">t</span><span class="tok-o">.</span><span class="tok-n">_1</span><span class="tok-o">,</span> <span class="tok-n">curTime</span><span class="tok-o">,</span> <span class="tok-n">t</span><span class="tok-o">.</span><span class="tok-n">_2</span><span class="tok-o">)))</span>

      <span class="tok-c1">// wait for 100 ms</span>
      <span class="tok-nc">Thread</span><span class="tok-o">.</span><span class="tok-n">sleep</span><span class="tok-o">(</span><span class="tok-mi">100</span><span class="tok-o">)</span>
    <span class="tok-o">}</span>

  <span class="tok-o">}</span>

  <span class="tok-cm">/** Cancels this SourceFunction. */</span>
  <span class="tok-c1">// override cancel函数</span>
  <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">cancel</span><span class="tok-o">()</span><span class="tok-k">:</span> <span class="tok-kt">Unit</span> <span class="tok-o">=</span> <span class="tok-o">{</span>
    <span class="tok-n">running</span> <span class="tok-k">=</span> <span class="tok-kc">false</span>
  <span class="tok-o">}</span>

<span class="tok-o">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>使用方法</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-c1">// ingest sensor stream</span>
<span class="tok-k">val</span> <span class="tok-n">sensorData</span><span class="tok-k">:</span> <span class="tok-kt">DataStream</span><span class="tok-o">[</span><span class="tok-kt">SensorReading</span><span class="tok-o">]</span> <span class="tok-k">=</span> <span class="tok-n">env</span>
  <span class="tok-c1">// SensorSource generates random temperature readings</span>
  <span class="tok-o">.</span><span class="tok-n">addSource</span><span class="tok-o">(</span><span class="tok-k">new</span> <span class="tok-nc">SensorSource</span><span class="tok-o">)</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_basic_transformations基本转换算子">6.3. Basic Transformations(基本转换算子)</h3>
<div class="sect3">
<h4 id="_map">6.3.1. map</h4>
<div class="imageblock">
<div class="content">
<img src="images/map.png" alt="map">
</div>
</div>
<div class="paragraph">
<p>我们需要实现接口<strong>MapFunction</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre>// T: the type of input elements
// O: the type of output elements
MapFunction[T, O]
    &gt; map(T): O</pre>
</div>
</div>
<div class="paragraph">
<p>例如</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">val</span> <span class="tok-n">readings</span><span class="tok-k">:</span> <span class="tok-kt">DataStream</span><span class="tok-o">[</span><span class="tok-kt">SensorReading</span><span class="tok-o">]</span> <span class="tok-k">=</span> <span class="tok-o">...</span>
<span class="tok-k">val</span> <span class="tok-n">sensorIds</span><span class="tok-k">:</span> <span class="tok-kt">DataStream</span><span class="tok-o">[</span><span class="tok-kt">String</span><span class="tok-o">]</span> <span class="tok-k">=</span> <span class="tok-n">readings</span><span class="tok-o">.</span><span class="tok-n">map</span><span class="tok-o">(</span><span class="tok-k">new</span> <span class="tok-nc">MyMapFunction</span><span class="tok-o">)</span>

<span class="tok-k">class</span> <span class="tok-nc">MyMapFunction</span> <span class="tok-k">extends</span> <span class="tok-nc">MapFunction</span><span class="tok-o">[</span><span class="tok-kt">SensorReading</span>, <span class="tok-kt">String</span><span class="tok-o">]</span> <span class="tok-o">{</span>
  <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">map</span><span class="tok-o">(</span><span class="tok-n">r</span><span class="tok-k">:</span> <span class="tok-kt">SensorReading</span><span class="tok-o">)</span><span class="tok-k">:</span> <span class="tok-kt">String</span> <span class="tok-o">=</span> <span class="tok-n">r</span><span class="tok-o">.</span><span class="tok-n">id</span>
<span class="tok-o">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的代码实现了将SensorReading的id抽取出来的操作, 当然我们更推荐匿名函数的写法。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">val</span> <span class="tok-n">readings</span><span class="tok-k">:</span> <span class="tok-kt">DataStream</span><span class="tok-o">[</span><span class="tok-kt">SensorReading</span><span class="tok-o">]</span> <span class="tok-k">=</span> <span class="tok-o">...</span>
<span class="tok-k">val</span> <span class="tok-n">sensorIds</span><span class="tok-k">:</span> <span class="tok-kt">DataStream</span><span class="tok-o">[</span><span class="tok-kt">String</span><span class="tok-o">]</span> <span class="tok-k">=</span> <span class="tok-n">readings</span><span class="tok-o">.</span><span class="tok-n">map</span><span class="tok-o">(</span><span class="tok-n">r</span> <span class="tok-k">=&gt;</span> <span class="tok-n">r</span><span class="tok-o">.</span><span class="tok-n">id</span><span class="tok-o">)</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_flatmap">6.3.2. flatMap</h4>
<div class="paragraph">
<p>flatMap的函数签名：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">def</span> <span class="tok-n">flatMap</span><span class="tok-o">[</span><span class="tok-kt">A</span>,<span class="tok-kt">B</span><span class="tok-o">](</span><span class="tok-n">as</span><span class="tok-k">:</span> <span class="tok-kt">List</span><span class="tok-o">[</span><span class="tok-kt">A</span><span class="tok-o">])(</span><span class="tok-n">f</span><span class="tok-k">:</span> <span class="tok-kt">A</span> <span class="tok-o">=&gt;</span> <span class="tok-nc">List</span><span class="tok-o">[</span><span class="tok-kt">B</span><span class="tok-o">])</span><span class="tok-k">:</span> <span class="tok-kt">List</span><span class="tok-o">[</span><span class="tok-kt">B</span><span class="tok-o">]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>, 例如:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-n">flatMap</span><span class="tok-o">(</span><span class="tok-nc">List</span><span class="tok-o">(</span><span class="tok-mi">1</span><span class="tok-o">,</span><span class="tok-mi">2</span><span class="tok-o">,</span><span class="tok-mi">3</span><span class="tok-o">))(</span><span class="tok-n">i</span> <span class="tok-k">=&gt;</span> <span class="tok-nc">List</span><span class="tok-o">(</span><span class="tok-n">i</span><span class="tok-o">,</span><span class="tok-n">i</span><span class="tok-o">))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>结果是List(1,1,2,2,3,3),</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-nc">List</span><span class="tok-o">(</span><span class="tok-s">&quot;a b&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;c d&quot;</span><span class="tok-o">).</span><span class="tok-n">flatMap</span><span class="tok-o">(</span><span class="tok-n">line</span> <span class="tok-k">=&gt;</span> <span class="tok-n">line</span><span class="tok-o">.</span><span class="tok-n">split</span><span class="tok-o">(</span><span class="tok-s">&quot; &quot;</span><span class="tok-o">))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>结果是List(a, b, c, d)。</p>
</div>
<div class="paragraph">
<p>我们需要实现<code>FlatMapFunction</code>接口</p>
</div>
<div class="listingblock">
<div class="content">
<pre>// T: the type of input elements
// O: the type of output elements
FlatMapFunction[T, O]
    &gt; flatMap(T, Collector[O]): Unit</pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="images/flatmap.png" alt="flatmap">
</div>
</div>
<div class="paragraph">
<p>白框不变，黑框复制，灰框过滤</p>
</div>
<div class="paragraph">
<p>flatmap类似map，但可以生成0个或者1个或者多个数据, 所以最后需要一个集合Collector来收集输出数据</p>
</div>
<div class="paragraph">
<p>flatmap可以实现map和filter</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">def</span> <span class="tok-n">filterViaFlatMap</span><span class="tok-o">[</span><span class="tok-kt">A</span><span class="tok-o">](</span><span class="tok-n">l</span><span class="tok-k">:</span> <span class="tok-kt">List</span><span class="tok-o">[</span><span class="tok-kt">A</span><span class="tok-o">])(</span><span class="tok-n">f</span><span class="tok-k">:</span> <span class="tok-kt">A</span> <span class="tok-o">=&gt;</span> <span class="tok-nc">Boolean</span><span class="tok-o">)</span><span class="tok-k">:</span> <span class="tok-kt">List</span><span class="tok-o">[</span><span class="tok-kt">A</span><span class="tok-o">]</span> <span class="tok-k">=</span>
  <span class="tok-n">flatMap</span><span class="tok-o">(</span><span class="tok-n">l</span><span class="tok-o">)(</span><span class="tok-n">a</span> <span class="tok-k">=&gt;</span> <span class="tok-k">if</span> <span class="tok-o">(</span><span class="tok-n">f</span><span class="tok-o">(</span><span class="tok-n">a</span><span class="tok-o">))</span> <span class="tok-nc">List</span><span class="tok-o">(</span><span class="tok-n">a</span><span class="tok-o">)</span> <span class="tok-k">else</span> <span class="tok-nc">Nil</span><span class="tok-o">)</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">val</span> <span class="tok-n">sentences</span><span class="tok-k">:</span> <span class="tok-kt">DataStream</span><span class="tok-o">[</span><span class="tok-kt">String</span><span class="tok-o">]</span> <span class="tok-k">=</span> <span class="tok-o">...</span>
<span class="tok-k">val</span> <span class="tok-n">words</span><span class="tok-k">:</span> <span class="tok-kt">DataStream</span><span class="tok-o">[</span><span class="tok-kt">String</span><span class="tok-o">]</span> <span class="tok-k">=</span> <span class="tok-n">sentences</span>
  <span class="tok-o">.</span><span class="tok-n">flatMap</span><span class="tok-o">(</span><span class="tok-n">id</span> <span class="tok-k">=&gt;</span> <span class="tok-n">id</span><span class="tok-o">.</span><span class="tok-n">split</span><span class="tok-o">(</span><span class="tok-s">&quot; &quot;</span><span class="tok-o">))</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_filter">6.3.3. Filter</h4>
<div class="paragraph">
<p>我们需要实现接口<code>FilterFunction</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre>// T: the type of elements
FilterFunction[T]
    &gt; filter(T): Boolean</pre>
</div>
</div>
<div class="paragraph">
<p>例如, 过滤出温度大于等于25度的传感器数据</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">val</span> <span class="tok-n">readings</span><span class="tok-k">:</span> <span class="tok-kt">DataStream</span><span class="tok-o">[</span><span class="tok-kt">SensorReadings</span><span class="tok-o">]</span> <span class="tok-k">=</span> <span class="tok-o">...</span>
<span class="tok-k">val</span> <span class="tok-n">filteredSensors</span> <span class="tok-k">=</span> <span class="tok-n">readings</span>
    <span class="tok-o">.</span><span class="tok-n">filter</span><span class="tok-o">(</span> <span class="tok-n">r</span> <span class="tok-k">=&gt;</span>  <span class="tok-n">r</span><span class="tok-o">.</span><span class="tok-n">temperature</span> <span class="tok-o">&gt;=</span> <span class="tok-mi">25</span> <span class="tok-o">)</span></code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="images/filter.png" alt="filter">
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_keyedstream_transformations键控流转换算子">6.4. KeyedStream Transformations(键控流转换算子)</h3>
<div class="sect3">
<h4 id="_keyby">6.4.1. keyBy</h4>
<div class="paragraph">
<p>分流算子, 流的类型改变了</p>
</div>
<div class="paragraph">
<p>DataStream &#8594; KeyedStream</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/keyby.png" alt="keyby">
</div>
</div>
<div class="paragraph">
<p>黑色去一条流，剩下的去另一条流</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-c1">// 以数据的id为key分流</span>
<span class="tok-n">stream</span><span class="tok-o">.</span><span class="tok-n">keyBy</span><span class="tok-o">(</span><span class="tok-n">r</span> <span class="tok-k">=&gt;</span> <span class="tok-n">r</span><span class="tok-o">.</span><span class="tok-n">id</span><span class="tok-o">)</span>
<span class="tok-c1">// 以case class的word字段为key分流</span>
<span class="tok-n">stream</span><span class="tok-o">.</span><span class="tok-n">keyBy</span><span class="tok-o">(</span><span class="tok-s">&quot;word&quot;</span><span class="tok-o">)</span>
<span class="tok-c1">// 以Tuple的第0个元素为key分流</span>
<span class="tok-n">stream</span><span class="tok-o">.</span><span class="tok-n">keyBy</span><span class="tok-o">(</span><span class="tok-mi">0</span><span class="tok-o">)</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_rolling_aggregations">6.4.2. Rolling Aggregations</h4>
<div class="paragraph">
<p>针对KeyedStream的每一条流做聚合</p>
</div>
<div class="ulist">
<ul>
<li>
<p>sum()</p>
</li>
<li>
<p>min()</p>
</li>
<li>
<p>max()</p>
</li>
<li>
<p>minBy()</p>
</li>
<li>
<p>maxBy()</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">val</span> <span class="tok-n">inputStream</span><span class="tok-k">:</span> <span class="tok-kt">DataStream</span><span class="tok-o">[(</span><span class="tok-kt">Int</span>, <span class="tok-kt">Int</span>, <span class="tok-kt">Int</span><span class="tok-o">)]</span> <span class="tok-k">=</span> <span class="tok-n">env</span><span class="tok-o">.</span><span class="tok-n">fromElements</span><span class="tok-o">(</span>
  <span class="tok-o">(</span><span class="tok-mi">1</span><span class="tok-o">,</span> <span class="tok-mi">2</span><span class="tok-o">,</span> <span class="tok-mi">2</span><span class="tok-o">),</span> <span class="tok-o">(</span><span class="tok-mi">2</span><span class="tok-o">,</span> <span class="tok-mi">3</span><span class="tok-o">,</span> <span class="tok-mi">1</span><span class="tok-o">),</span> <span class="tok-o">(</span><span class="tok-mi">2</span><span class="tok-o">,</span> <span class="tok-mi">2</span><span class="tok-o">,</span> <span class="tok-mi">4</span><span class="tok-o">),</span> <span class="tok-o">(</span><span class="tok-mi">1</span><span class="tok-o">,</span> <span class="tok-mi">5</span><span class="tok-o">,</span> <span class="tok-mi">3</span><span class="tok-o">))</span>

<span class="tok-k">val</span> <span class="tok-n">resultStream</span><span class="tok-k">:</span> <span class="tok-kt">DataStream</span><span class="tok-o">[(</span><span class="tok-kt">Int</span>, <span class="tok-kt">Int</span>, <span class="tok-kt">Int</span><span class="tok-o">)]</span> <span class="tok-k">=</span> <span class="tok-n">inputStream</span>
  <span class="tok-o">.</span><span class="tok-n">keyBy</span><span class="tok-o">(</span><span class="tok-mi">0</span><span class="tok-o">)</span> <span class="tok-c1">// key on first field of the tuple</span>
  <span class="tok-o">.</span><span class="tok-n">sum</span><span class="tok-o">(</span><span class="tok-mi">1</span><span class="tok-o">)</span>   <span class="tok-c1">// sum the second field of the tuple in place</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_reduce">6.4.3. Reduce</h4>
<div class="paragraph">
<p>我们需要实现<code>ReduceFunction</code>接口</p>
</div>
<div class="listingblock">
<div class="content">
<pre>// T: the element type
ReduceFunction[T]
    &gt; reduce(T, T): T</pre>
</div>
</div>
<div class="paragraph">
<p>流的类型转换, KeyedStream &#8594; DataStream：一个分组数据流的聚合操作，合并当前的元素和上次聚合的结果，产生一个新的值，返回的流中包含每一次聚合的结果，而不是只返回最后一次聚合的最终结果。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">val</span> <span class="tok-n">inputStream</span><span class="tok-k">:</span> <span class="tok-kt">DataStream</span><span class="tok-o">[(</span><span class="tok-kt">String</span>, <span class="tok-kt">List</span><span class="tok-o">[</span><span class="tok-kt">String</span><span class="tok-o">])]</span> <span class="tok-k">=</span> <span class="tok-n">env</span><span class="tok-o">.</span><span class="tok-n">fromElements</span><span class="tok-o">(</span>
  <span class="tok-o">(</span><span class="tok-s">&quot;en&quot;</span><span class="tok-o">,</span> <span class="tok-nc">List</span><span class="tok-o">(</span><span class="tok-s">&quot;tea&quot;</span><span class="tok-o">)),</span> <span class="tok-o">(</span><span class="tok-s">&quot;fr&quot;</span><span class="tok-o">,</span> <span class="tok-nc">List</span><span class="tok-o">(</span><span class="tok-s">&quot;vin&quot;</span><span class="tok-o">)),</span> <span class="tok-o">(</span><span class="tok-s">&quot;en&quot;</span><span class="tok-o">,</span> <span class="tok-nc">List</span><span class="tok-o">(</span><span class="tok-s">&quot;cake&quot;</span><span class="tok-o">)))</span>

<span class="tok-k">val</span> <span class="tok-n">resultStream</span><span class="tok-k">:</span> <span class="tok-kt">DataStream</span><span class="tok-o">[(</span><span class="tok-kt">String</span>, <span class="tok-kt">List</span><span class="tok-o">[</span><span class="tok-kt">String</span><span class="tok-o">])]</span> <span class="tok-k">=</span> <span class="tok-n">inputStream</span>
  <span class="tok-o">.</span><span class="tok-n">keyBy</span><span class="tok-o">(</span><span class="tok-mi">0</span><span class="tok-o">)</span>
  <span class="tok-o">.</span><span class="tok-n">reduce</span><span class="tok-o">((</span><span class="tok-n">x</span><span class="tok-o">,</span> <span class="tok-n">y</span><span class="tok-o">)</span> <span class="tok-k">=&gt;</span> <span class="tok-o">(</span><span class="tok-n">x</span><span class="tok-o">.</span><span class="tok-n">_1</span><span class="tok-o">,</span> <span class="tok-n">x</span><span class="tok-o">.</span><span class="tok-n">_2</span> <span class="tok-o">:::</span> <span class="tok-n">y</span><span class="tok-o">.</span><span class="tok-n">_2</span><span class="tok-o">))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>reduce匿名函数将连续两个tuple的第一个字段(key字段)继续发送出去，然后将两个tuple的第二个字段List[String]连接。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_multistream_transformations多流转换算子">6.5. Multistream Transformations(多流转换算子)</h3>
<div class="sect3">
<h4 id="_union">6.5.1. Union</h4>
<div class="imageblock">
<div class="content">
<img src="images/union.png" alt="union">
</div>
</div>
<div class="paragraph">
<p>将事件类型相同的多条DataStream合并到一起，在进入到合流时，使用FIFO先进先出的原则。Union算子不会对事件的顺序做处理。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">val</span> <span class="tok-n">parisStream</span><span class="tok-k">:</span> <span class="tok-kt">DataStream</span><span class="tok-o">[</span><span class="tok-kt">SensorReading</span><span class="tok-o">]</span> <span class="tok-k">=</span> <span class="tok-o">...</span>
<span class="tok-k">val</span> <span class="tok-n">tokyoStream</span><span class="tok-k">:</span> <span class="tok-kt">DataStream</span><span class="tok-o">[</span><span class="tok-kt">SensorReading</span><span class="tok-o">]</span> <span class="tok-k">=</span> <span class="tok-o">...</span>
<span class="tok-k">val</span> <span class="tok-n">rioStream</span><span class="tok-k">:</span> <span class="tok-kt">DataStream</span><span class="tok-o">[</span><span class="tok-kt">SensorReading</span><span class="tok-o">]</span> <span class="tok-k">=</span> <span class="tok-o">...</span>
<span class="tok-k">val</span> <span class="tok-n">allCities</span><span class="tok-k">:</span> <span class="tok-kt">DataStream</span><span class="tok-o">[</span><span class="tok-kt">SensorRreading</span><span class="tok-o">]</span> <span class="tok-k">=</span> <span class="tok-n">parisStream</span>
  <span class="tok-o">.</span><span class="tok-n">union</span><span class="tok-o">(</span><span class="tok-n">tokyoStream</span><span class="tok-o">,</span> <span class="tok-n">rioStream</span><span class="tok-o">)</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_connect_comap_and_coflatmap">6.5.2. Connect, Comap and Coflatmap</h4>
<div class="paragraph">
<p>联合两条流的事件是非常常见的流处理需求。例如监控一片森林然后发出高危的火警警报。报警的Application接收两条流，一条是温度传感器传回来的数据，一条是烟雾传感器传回来的数据。当两条流都超过各自的阈值时，报警。</p>
</div>
<div class="paragraph">
<p>DataStream.connect()方法就实现了这个功能。流的类型转换: DataStream &#8594; ConnectedStreams。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-c1">// first stream</span>
<span class="tok-k">val</span> <span class="tok-n">first</span><span class="tok-k">:</span> <span class="tok-kt">DataStream</span><span class="tok-o">[</span><span class="tok-kt">Int</span><span class="tok-o">]</span> <span class="tok-k">=</span> <span class="tok-o">...</span>
<span class="tok-c1">// second stream</span>
<span class="tok-k">val</span> <span class="tok-n">second</span><span class="tok-k">:</span> <span class="tok-kt">DataStream</span><span class="tok-o">[</span><span class="tok-kt">String</span><span class="tok-o">]</span> <span class="tok-k">=</span> <span class="tok-o">...</span>

<span class="tok-c1">// connect streams</span>
<span class="tok-k">val</span> <span class="tok-n">connected</span><span class="tok-k">:</span> <span class="tok-kt">ConnectedStreams</span><span class="tok-o">[</span><span class="tok-kt">Int</span>, <span class="tok-kt">String</span><span class="tok-o">]</span> <span class="tok-k">=</span>
<span class="tok-n">first</span><span class="tok-o">.</span><span class="tok-n">connect</span><span class="tok-o">(</span><span class="tok-n">second</span><span class="tok-o">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>ConnectedStream提供了map和flatMap方法。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>map: 需要CoMapFunction作为参数</p>
</li>
<li>
<p>flatMap: 需要CoFlatMapFunction作为参数</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>CoMapFunction和CoFlatMapFunction都需要两条输入流的类型，还需要输出流的类型，还需要定义两个方法，一个方法对应一条流。map1()和flatMap1()处理第一条流，map2()和flatMap2()处理第二条流。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>// IN1: 第一条流的事件类型
// IN2: 第二条流的事件类型
// OUT: 输出流的事件类型
CoMapFunction[IN1, IN2, OUT]
    &gt; map1(IN1): OUT
    &gt; map2(IN2): OUT

CoFlatMapFunction[IN1, IN2, OUT]
    &gt; flatMap1(IN1, Collector[OUT]): Unit
    &gt; flatMap2(IN2, Collector[OUT]): Unit</pre>
</div>
</div>
<div class="paragraph">
<p>两条流直接connect，其实是没有意义的。因为我们相当于将两条流随机的合并成了一条流，结果没什么价值。为了获得确定性的结果，connect必须和keyBy或者broadcast一起使用。</p>
</div>
<div class="paragraph">
<p><strong>keyBy</strong></p>
</div>
<div class="paragraph">
<p>以两条流的事件的第一个元素为key，做连接join</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">val</span> <span class="tok-n">one</span><span class="tok-k">:</span> <span class="tok-kt">DataStream</span><span class="tok-o">[(</span><span class="tok-kt">Int</span>, <span class="tok-kt">Long</span><span class="tok-o">)]</span> <span class="tok-k">=</span> <span class="tok-o">...</span>
<span class="tok-k">val</span> <span class="tok-n">two</span><span class="tok-k">:</span> <span class="tok-kt">DataStream</span><span class="tok-o">[(</span><span class="tok-kt">Int</span>, <span class="tok-kt">String</span><span class="tok-o">)]</span> <span class="tok-k">=</span> <span class="tok-o">...</span>

<span class="tok-c1">// keyBy two connected streams</span>
<span class="tok-k">val</span> <span class="tok-n">keyedConnect1</span><span class="tok-k">:</span> <span class="tok-kt">ConnectedStreams</span><span class="tok-o">[(</span><span class="tok-kt">Int</span>, <span class="tok-kt">Long</span><span class="tok-o">)</span>, <span class="tok-o">(</span><span class="tok-kt">Int</span>, <span class="tok-kt">String</span><span class="tok-o">)]</span> <span class="tok-k">=</span> <span class="tok-n">one</span>
  <span class="tok-o">.</span><span class="tok-n">connect</span><span class="tok-o">(</span><span class="tok-n">two</span><span class="tok-o">)</span>
  <span class="tok-o">.</span><span class="tok-n">keyBy</span><span class="tok-o">(</span><span class="tok-mi">0</span><span class="tok-o">,</span> <span class="tok-mi">0</span><span class="tok-o">)</span> <span class="tok-c1">// key both input streams on first attribute</span>

<span class="tok-c1">// alternative: connect two keyed streams</span>
<span class="tok-k">val</span> <span class="tok-n">keyedConnect2</span><span class="tok-k">:</span> <span class="tok-kt">ConnectedStreams</span><span class="tok-o">[(</span><span class="tok-kt">Int</span>, <span class="tok-kt">Long</span><span class="tok-o">)</span>, <span class="tok-o">(</span><span class="tok-kt">Int</span>, <span class="tok-kt">String</span><span class="tok-o">)]</span> <span class="tok-k">=</span> <span class="tok-n">one</span><span class="tok-o">.</span><span class="tok-n">keyBy</span><span class="tok-o">(</span><span class="tok-mi">0</span><span class="tok-o">)</span>
  <span class="tok-o">.</span><span class="tok-n">connect</span><span class="tok-o">(</span><span class="tok-n">two</span><span class="tok-o">.</span><span class="tok-n">keyBy</span><span class="tok-o">(</span><span class="tok-mi">0</span><span class="tok-o">))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>无论使用keyBy()算子操作ConnectedStreams还是使用connect()算子连接两条KeyedStreams，connect()算子会将两条流的含有相同Key的所有事件都发送到相同的算子。两条流的key必须是一样的类型和值，就像SQL中的JOIN。select * from A join B on A.id=B.id。connect()算子操作以后的Keyed Streams可以访问keyed state状态。</p>
</div>
<div class="paragraph">
<p><strong>broadcast</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">val</span> <span class="tok-n">first</span><span class="tok-k">:</span> <span class="tok-kt">DataStream</span><span class="tok-o">[(</span><span class="tok-kt">Int</span>, <span class="tok-kt">Long</span><span class="tok-o">)]</span> <span class="tok-k">=</span> <span class="tok-o">...</span>
<span class="tok-k">val</span> <span class="tok-n">second</span><span class="tok-k">:</span> <span class="tok-kt">DataStream</span><span class="tok-o">[(</span><span class="tok-kt">Int</span>, <span class="tok-kt">String</span><span class="tok-o">)]</span> <span class="tok-k">=</span> <span class="tok-o">...</span>

<span class="tok-c1">// connect streams with broadcast</span>
<span class="tok-k">val</span> <span class="tok-n">keyedConnect</span><span class="tok-k">:</span> <span class="tok-kt">ConnectedStreams</span><span class="tok-o">[(</span><span class="tok-kt">Int</span>, <span class="tok-kt">Long</span><span class="tok-o">)</span>, <span class="tok-o">(</span><span class="tok-kt">Int</span>, <span class="tok-kt">String</span><span class="tok-o">)]</span> <span class="tok-k">=</span> <span class="tok-n">first</span>
  <span class="tok-c1">// broadcast second input stream</span>
  <span class="tok-o">.</span><span class="tok-n">connect</span><span class="tok-o">(</span><span class="tok-n">second</span><span class="tok-o">.</span><span class="tok-n">broadcast</span><span class="tok-o">())</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的例子显示了如何将一条为分流的数据流和一条广播流进行连接。</p>
</div>
<div class="paragraph">
<p>被广播的流中的所有事件都将被复制并发送到接下来的Process Function的所有的并行算子实例中去，未被广播的流直接向前发送。</p>
</div>
<div class="paragraph">
<p>一条流如果broadcast, 将会广播到所有的分布式节点，如果不广播，将会向前发送，并不会广播。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>详细请参考: https://www.ververica.com/blog/a-practical-guide-to-broadcast-state-in-apache-flink</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_split_and_select">6.5.3. Split and Select</h4>
<div class="paragraph">
<p>Split是Union的反函数。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>// IN: the type of the split elements
OutputSelector[IN]
    &gt; select(IN): Iterable[String]</pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="images/split.png" alt="split">
</div>
</div>
<div class="paragraph">
<p>流的类型转换: DataStream &#8594; SplitStream</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">val</span> <span class="tok-n">inputStream</span><span class="tok-k">:</span> <span class="tok-kt">DataStream</span><span class="tok-o">[(</span><span class="tok-kt">Int</span>, <span class="tok-kt">String</span><span class="tok-o">)]</span> <span class="tok-k">=</span> <span class="tok-o">...</span>

<span class="tok-k">val</span> <span class="tok-n">splitted</span><span class="tok-k">:</span> <span class="tok-kt">SplitStream</span><span class="tok-o">[(</span><span class="tok-kt">Int</span>, <span class="tok-kt">String</span><span class="tok-o">)]</span> <span class="tok-k">=</span> <span class="tok-n">inputStream</span>
  <span class="tok-o">.</span><span class="tok-n">split</span><span class="tok-o">(</span><span class="tok-n">t</span> <span class="tok-k">=&gt;</span> <span class="tok-k">if</span> <span class="tok-o">(</span><span class="tok-n">t</span><span class="tok-o">.</span><span class="tok-n">_1</span> <span class="tok-o">&gt;</span> <span class="tok-mi">1000</span><span class="tok-o">)</span> <span class="tok-nc">Seq</span><span class="tok-o">(</span><span class="tok-s">&quot;large&quot;</span><span class="tok-o">)</span> <span class="tok-k">else</span> <span class="tok-nc">Seq</span><span class="tok-o">(</span><span class="tok-s">&quot;small&quot;</span><span class="tok-o">))</span>

<span class="tok-k">val</span> <span class="tok-n">large</span><span class="tok-k">:</span> <span class="tok-kt">DataStream</span><span class="tok-o">[(</span><span class="tok-kt">Int</span>, <span class="tok-kt">String</span><span class="tok-o">)]</span> <span class="tok-k">=</span> <span class="tok-n">splitted</span><span class="tok-o">.</span><span class="tok-n">select</span><span class="tok-o">(</span><span class="tok-s">&quot;large&quot;</span><span class="tok-o">)</span>
<span class="tok-k">val</span> <span class="tok-n">small</span><span class="tok-k">:</span> <span class="tok-kt">DataStream</span><span class="tok-o">[(</span><span class="tok-kt">Int</span>, <span class="tok-kt">String</span><span class="tok-o">)]</span> <span class="tok-k">=</span> <span class="tok-n">splitted</span><span class="tok-o">.</span><span class="tok-n">select</span><span class="tok-o">(</span><span class="tok-s">&quot;small&quot;</span><span class="tok-o">)</span>
<span class="tok-k">val</span> <span class="tok-n">all</span><span class="tok-k">:</span> <span class="tok-kt">DataStream</span><span class="tok-o">[(</span><span class="tok-kt">Int</span>, <span class="tok-kt">String</span><span class="tok-o">)]</span> <span class="tok-k">=</span> <span class="tok-n">splitted</span><span class="tok-o">.</span><span class="tok-n">select</span><span class="tok-o">(</span><span class="tok-s">&quot;small&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;large&quot;</span><span class="tok-o">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Connect与Union区别：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Union之前两个流的类型必须是一样，Connect可以不一样，在之后的CoMapFunction中再去调整成为一样的。</p>
</li>
<li>
<p>Connect只能操作两个流，Union可以操作多个。</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_支持的数据类型">6.6. 支持的数据类型</h3>
<div class="sect3">
<h4 id="_primitives基础数据类型">6.6.1. Primitives(基础数据类型)</h4>
<div class="paragraph">
<p>所有的基础数据类型都支持，Int, Double, Long, String, &#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">val</span> <span class="tok-n">numbers</span><span class="tok-k">:</span> <span class="tok-kt">DataStream</span><span class="tok-o">[</span><span class="tok-kt">Long</span><span class="tok-o">]</span> <span class="tok-k">=</span> <span class="tok-n">env</span><span class="tok-o">.</span><span class="tok-n">fromElements</span><span class="tok-o">(</span><span class="tok-mi">1L</span><span class="tok-o">,</span> <span class="tok-mi">2L</span><span class="tok-o">,</span> <span class="tok-mi">3L</span><span class="tok-o">,</span> <span class="tok-mi">4L</span><span class="tok-o">)</span>
<span class="tok-n">numbers</span><span class="tok-o">.</span><span class="tok-n">map</span><span class="tok-o">(</span> <span class="tok-n">n</span> <span class="tok-k">=&gt;</span> <span class="tok-n">n</span> <span class="tok-o">+</span> <span class="tok-mi">1</span> <span class="tok-o">)</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_tuples">6.6.2. Tuples</h4>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">val</span> <span class="tok-n">persons</span><span class="tok-k">:</span> <span class="tok-kt">DataStream</span><span class="tok-o">[(</span><span class="tok-kt">String</span>, <span class="tok-kt">Integer</span><span class="tok-o">)]</span> <span class="tok-k">=</span>
<span class="tok-n">env</span><span class="tok-o">.</span><span class="tok-n">fromElements</span><span class="tok-o">(</span>
  <span class="tok-o">(</span><span class="tok-s">&quot;Adam&quot;</span><span class="tok-o">,</span> <span class="tok-mi">17</span><span class="tok-o">),</span>
  <span class="tok-o">(</span><span class="tok-s">&quot;Sarah&quot;</span><span class="tok-o">,</span> <span class="tok-mi">23</span><span class="tok-o">)</span>
<span class="tok-o">)</span>

<span class="tok-n">persons</span><span class="tok-o">.</span><span class="tok-n">filter</span><span class="tok-o">(</span><span class="tok-n">p</span> <span class="tok-k">=&gt;</span> <span class="tok-n">p</span><span class="tok-o">.</span><span class="tok-n">_2</span> <span class="tok-o">&gt;</span> <span class="tok-mi">18</span><span class="tok-o">)</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_scala_case_classes">6.6.3. Scala case classes</h4>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">case</span> <span class="tok-k">class</span> <span class="tok-nc">Person</span><span class="tok-o">(</span><span class="tok-n">name</span><span class="tok-k">:</span> <span class="tok-kt">String</span><span class="tok-o">,</span> <span class="tok-n">age</span><span class="tok-k">:</span> <span class="tok-kt">Int</span><span class="tok-o">)</span>

<span class="tok-k">val</span> <span class="tok-n">persons</span><span class="tok-k">:</span> <span class="tok-kt">DataStream</span><span class="tok-o">[</span><span class="tok-kt">Person</span><span class="tok-o">]</span> <span class="tok-k">=</span> <span class="tok-n">env</span><span class="tok-o">.</span><span class="tok-n">fromElements</span><span class="tok-o">(</span>
  <span class="tok-nc">Person</span><span class="tok-o">(</span><span class="tok-s">&quot;Adam&quot;</span><span class="tok-o">,</span> <span class="tok-mi">17</span><span class="tok-o">),</span>
  <span class="tok-nc">Person</span><span class="tok-o">(</span><span class="tok-s">&quot;Sarah&quot;</span><span class="tok-o">,</span> <span class="tok-mi">23</span><span class="tok-o">)</span>
<span class="tok-o">)</span>

<span class="tok-n">persons</span><span class="tok-o">.</span><span class="tok-n">filter</span><span class="tok-o">(</span><span class="tok-n">p</span> <span class="tok-k">=&gt;</span> <span class="tok-n">p</span><span class="tok-o">.</span><span class="tok-n">age</span> <span class="tok-o">&gt;</span> <span class="tok-mi">18</span><span class="tok-o">)</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_others">6.6.4. others</h4>
<div class="ulist">
<ul>
<li>
<p>Hadoop Writable types</p>
</li>
<li>
<p>Java&#8217;s POJOs, ArrayList, HashMap, Enum</p>
</li>
<li>
<p>&#8230;&#8203;</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_keyby相关用法">6.7. keyBy相关用法</h3>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">val</span> <span class="tok-n">input</span><span class="tok-k">:</span> <span class="tok-kt">DataStream</span><span class="tok-o">[(</span><span class="tok-kt">Int</span>, <span class="tok-kt">String</span>, <span class="tok-kt">Long</span><span class="tok-o">)]</span> <span class="tok-k">=</span> <span class="tok-o">...</span>
<span class="tok-k">val</span> <span class="tok-n">keyed</span> <span class="tok-k">=</span> <span class="tok-n">input</span><span class="tok-o">.</span><span class="tok-n">keyBy</span><span class="tok-o">(</span><span class="tok-mi">1</span><span class="tok-o">)</span>
<span class="tok-k">val</span> <span class="tok-n">keyed2</span> <span class="tok-k">=</span> <span class="tok-n">input</span><span class="tok-o">.</span><span class="tok-n">keyBy</span><span class="tok-o">(</span><span class="tok-mi">1</span><span class="tok-o">,</span> <span class="tok-mi">2</span><span class="tok-o">)</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">case</span> <span class="tok-k">class</span> <span class="tok-nc">SensorReading</span><span class="tok-o">(</span>
  <span class="tok-n">id</span><span class="tok-k">:</span> <span class="tok-kt">String</span><span class="tok-o">,</span>
  <span class="tok-n">timestamp</span><span class="tok-k">:</span> <span class="tok-kt">Long</span><span class="tok-o">,</span>
  <span class="tok-n">temperature</span><span class="tok-k">:</span> <span class="tok-kt">Double</span>
<span class="tok-o">)</span>

<span class="tok-k">val</span> <span class="tok-n">sensorStream</span><span class="tok-k">:</span> <span class="tok-kt">DataStream</span><span class="tok-o">[</span><span class="tok-kt">SensorReading</span><span class="tok-o">]</span> <span class="tok-k">=</span> <span class="tok-o">...</span>
<span class="tok-k">val</span> <span class="tok-n">keyedSensors</span> <span class="tok-k">=</span> <span class="tok-n">sensorStream</span><span class="tok-o">.</span><span class="tok-n">keyBy</span><span class="tok-o">(</span><span class="tok-s">&quot;id&quot;</span><span class="tok-o">)</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">val</span> <span class="tok-n">input</span><span class="tok-k">:</span> <span class="tok-kt">DataStream</span><span class="tok-o">[(</span><span class="tok-kt">Int</span>, <span class="tok-kt">String</span>, <span class="tok-kt">Long</span><span class="tok-o">)]</span> <span class="tok-k">=</span> <span class="tok-o">...</span>
<span class="tok-k">val</span> <span class="tok-n">keyed1</span> <span class="tok-k">=</span> <span class="tok-n">input</span><span class="tok-o">.</span><span class="tok-n">keyBy</span><span class="tok-o">(</span><span class="tok-s">&quot;2&quot;</span><span class="tok-o">)</span> <span class="tok-c1">// key by 3rd field</span>
<span class="tok-k">val</span> <span class="tok-n">keyed2</span> <span class="tok-k">=</span> <span class="tok-n">input</span><span class="tok-o">.</span><span class="tok-n">keyBy</span><span class="tok-o">(</span><span class="tok-s">&quot;_1&quot;</span><span class="tok-o">)</span> <span class="tok-c1">// key by 1st field</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">case</span> <span class="tok-k">class</span> <span class="tok-nc">Address</span> <span class="tok-o">(</span>
  <span class="tok-n">address</span><span class="tok-k">:</span> <span class="tok-kt">String</span><span class="tok-o">,</span>
  <span class="tok-n">zip</span><span class="tok-k">:</span> <span class="tok-kt">String</span><span class="tok-o">,</span>
  <span class="tok-n">country</span><span class="tok-k">:</span> <span class="tok-kt">String</span>
<span class="tok-o">)</span>

<span class="tok-k">case</span> <span class="tok-k">class</span> <span class="tok-nc">Person</span> <span class="tok-o">(</span>
  <span class="tok-n">name</span><span class="tok-k">:</span> <span class="tok-kt">String</span><span class="tok-o">,</span>
  <span class="tok-n">birthday</span><span class="tok-k">:</span> <span class="tok-o">(</span><span class="tok-kt">Int</span><span class="tok-o">,</span> <span class="tok-kt">Int</span><span class="tok-o">,</span> <span class="tok-nc">Int</span><span class="tok-o">),</span> <span class="tok-c1">// year, month, day</span>
  <span class="tok-n">address</span><span class="tok-k">:</span> <span class="tok-kt">Address</span>
<span class="tok-o">)</span>

<span class="tok-k">val</span> <span class="tok-n">persons</span><span class="tok-k">:</span> <span class="tok-kt">DataStream</span><span class="tok-o">[</span><span class="tok-kt">Person</span><span class="tok-o">]</span> <span class="tok-k">=</span> <span class="tok-o">...</span>
<span class="tok-n">persons</span><span class="tok-o">.</span><span class="tok-n">keyBy</span><span class="tok-o">(</span><span class="tok-s">&quot;address.zip&quot;</span><span class="tok-o">)</span> <span class="tok-c1">// key by nested POJO field</span>
<span class="tok-n">persons</span><span class="tok-o">.</span><span class="tok-n">keyBy</span><span class="tok-o">(</span><span class="tok-s">&quot;birthday._1&quot;</span><span class="tok-o">)</span> <span class="tok-c1">// key by field of nested tuple</span>
<span class="tok-n">persons</span><span class="tok-o">.</span><span class="tok-n">keyBy</span><span class="tok-o">(</span><span class="tok-s">&quot;birthday._&quot;</span><span class="tok-o">)</span> <span class="tok-c1">// key by all fields of nested tuple</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">val</span> <span class="tok-n">sensorData</span><span class="tok-k">:</span> <span class="tok-kt">DataStream</span><span class="tok-o">[</span><span class="tok-kt">SensorReading</span><span class="tok-o">]</span> <span class="tok-k">=</span> <span class="tok-o">...</span>
<span class="tok-k">val</span> <span class="tok-n">byId</span><span class="tok-k">:</span> <span class="tok-kt">KeyedStream</span><span class="tok-o">[</span><span class="tok-kt">SensorReading</span>, <span class="tok-kt">String</span><span class="tok-o">]</span> <span class="tok-k">=</span> <span class="tok-n">sensorData</span><span class="tok-o">.</span><span class="tok-n">keyBy</span><span class="tok-o">(</span><span class="tok-n">r</span> <span class="tok-k">=&gt;</span> <span class="tok-n">r</span><span class="tok-o">.</span><span class="tok-n">id</span><span class="tok-o">)</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">val</span> <span class="tok-n">input</span><span class="tok-k">:</span> <span class="tok-kt">DataStream</span><span class="tok-o">[(</span><span class="tok-kt">Int</span>, <span class="tok-kt">Int</span><span class="tok-o">)]</span> <span class="tok-k">=</span> <span class="tok-o">...</span>
<span class="tok-k">val</span> <span class="tok-n">keyedStream</span> <span class="tok-k">=</span> <span class="tok-n">input</span><span class="tok-o">.</span><span class="tok-n">keyBy</span><span class="tok-o">(</span><span class="tok-n">value</span> <span class="tok-k">=&gt;</span> <span class="tok-n">math</span><span class="tok-o">.</span><span class="tok-n">max</span><span class="tok-o">(</span><span class="tok-n">value</span><span class="tok-o">.</span><span class="tok-n">_1</span><span class="tok-o">,</span> <span class="tok-n">value</span><span class="tok-o">.</span><span class="tok-n">_2</span><span class="tok-o">))</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_实现udf函数更细粒度的控制流">6.8. 实现UDF函数，更细粒度的控制流</h3>
<div class="sect3">
<h4 id="_function_classes">6.8.1. Function Classes</h4>
<div class="paragraph">
<p>Flink暴露了所有udf函数的接口(实现方式为接口或者抽象类)。例如MapFunction, FilterFunction, ProcessFunction等等。</p>
</div>
<div class="paragraph">
<p>例子实现了FilterFunction接口</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">class</span> <span class="tok-nc">FilterFilter</span> <span class="tok-k">extends</span> <span class="tok-nc">FilterFunction</span><span class="tok-o">[</span><span class="tok-kt">String</span><span class="tok-o">]</span> <span class="tok-o">{</span>
  <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">filter</span><span class="tok-o">(</span><span class="tok-n">value</span><span class="tok-k">:</span> <span class="tok-kt">String</span><span class="tok-o">)</span><span class="tok-k">:</span> <span class="tok-kt">Boolean</span> <span class="tok-o">=</span> <span class="tok-o">{</span>
    <span class="tok-n">value</span><span class="tok-o">.</span><span class="tok-n">contains</span><span class="tok-o">(</span><span class="tok-s">&quot;flink&quot;</span><span class="tok-o">)</span>
  <span class="tok-o">}</span>
<span class="tok-o">}</span>

<span class="tok-k">val</span> <span class="tok-n">flinkTweets</span> <span class="tok-k">=</span> <span class="tok-n">tweets</span><span class="tok-o">.</span><span class="tok-n">filter</span><span class="tok-o">(</span><span class="tok-k">new</span> <span class="tok-nc">FlinkFilter</span><span class="tok-o">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>还可以将函数实现成匿名类</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">val</span> <span class="tok-n">flinkTweets</span> <span class="tok-k">=</span> <span class="tok-n">tweets</span><span class="tok-o">.</span><span class="tok-n">filter</span><span class="tok-o">(</span>
  <span class="tok-k">new</span> <span class="tok-nc">RichFilterFunction</span><span class="tok-o">[</span><span class="tok-kt">String</span><span class="tok-o">]</span> <span class="tok-o">{</span>
    <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">filter</span><span class="tok-o">(</span><span class="tok-n">value</span><span class="tok-k">:</span> <span class="tok-kt">String</span><span class="tok-o">)</span><span class="tok-k">:</span> <span class="tok-kt">Boolean</span> <span class="tok-o">=</span> <span class="tok-o">{</span>
      <span class="tok-n">value</span><span class="tok-o">.</span><span class="tok-n">contains</span><span class="tok-o">(</span><span class="tok-s">&quot;flink&quot;</span><span class="tok-o">)</span>
    <span class="tok-o">}</span>
  <span class="tok-o">}</span>
<span class="tok-o">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>我们filter的字符串"flink"还可以当作参数传进去。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">val</span> <span class="tok-n">tweets</span><span class="tok-k">:</span> <span class="tok-kt">DataStream</span><span class="tok-o">[</span><span class="tok-kt">String</span><span class="tok-o">]</span> <span class="tok-k">=</span> <span class="tok-o">...</span>
<span class="tok-k">val</span> <span class="tok-n">flinkTweets</span> <span class="tok-k">=</span> <span class="tok-n">tweets</span><span class="tok-o">.</span><span class="tok-n">filter</span><span class="tok-o">(</span><span class="tok-k">new</span> <span class="tok-nc">KeywordFilter</span><span class="tok-o">(</span><span class="tok-s">&quot;flink&quot;</span><span class="tok-o">))</span>

<span class="tok-k">class</span> <span class="tok-nc">KeywordFilter</span><span class="tok-o">(</span><span class="tok-n">keyWord</span><span class="tok-k">:</span> <span class="tok-kt">String</span><span class="tok-o">)</span> <span class="tok-k">extends</span> <span class="tok-nc">FilterFunction</span><span class="tok-o">[</span><span class="tok-kt">String</span><span class="tok-o">]</span> <span class="tok-o">{</span>
  <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">filter</span><span class="tok-o">(</span><span class="tok-n">value</span><span class="tok-k">:</span> <span class="tok-kt">String</span><span class="tok-o">)</span><span class="tok-k">:</span> <span class="tok-kt">Boolean</span> <span class="tok-o">=</span> <span class="tok-o">{</span>
    <span class="tok-n">value</span><span class="tok-o">.</span><span class="tok-n">contains</span><span class="tok-o">(</span><span class="tok-n">keyWord</span><span class="tok-o">)</span>
  <span class="tok-o">}</span>
<span class="tok-o">}</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_lambda_functions">6.8.2. Lambda Functions</h4>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">val</span> <span class="tok-n">tweets</span><span class="tok-k">:</span> <span class="tok-kt">DataStream</span><span class="tok-o">[</span><span class="tok-kt">String</span><span class="tok-o">]</span> <span class="tok-k">=</span> <span class="tok-o">...</span>
<span class="tok-k">val</span> <span class="tok-n">flinkTweets</span> <span class="tok-k">=</span> <span class="tok-n">tweets</span><span class="tok-o">.</span><span class="tok-n">filter</span><span class="tok-o">(</span><span class="tok-k">_</span><span class="tok-o">.</span><span class="tok-n">contains</span><span class="tok-o">(</span><span class="tok-s">&quot;flink&quot;</span><span class="tok-o">))</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_rich_functions">6.8.3. Rich Functions</h4>
<div class="ulist">
<ul>
<li>
<p>RichMapFunction</p>
</li>
<li>
<p>RichFlatMapFunction</p>
</li>
<li>
<p>RichFilterFunction</p>
</li>
<li>
<p>&#8230;&#8203;</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>所有Flink提供的Function都有Rich版本，提供了更丰富的功能。</p>
</div>
<div class="paragraph">
<p>Rich Function有一个生命周期的概念</p>
</div>
<div class="ulist">
<ul>
<li>
<p>open()方法是rich function的初始化方法，当一个算子例如map或者filter被调用之前open()会被调用。</p>
</li>
<li>
<p>close()方法是生命周期中的最后一个调用的方法，做一些清理工作。</p>
</li>
<li>
<p>getRuntimeContext()方法提供了函数的RuntimeContext的一些信息，例如函数执行的并行度，任务的名字，以及state状态</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">class</span> <span class="tok-nc">MyFlatMap</span> <span class="tok-k">extends</span> <span class="tok-nc">RichFlatMapFunction</span><span class="tok-o">[</span><span class="tok-kt">Int</span>, <span class="tok-o">(</span><span class="tok-kt">Int</span>, <span class="tok-kt">Int</span><span class="tok-o">)]</span> <span class="tok-o">{</span>
  <span class="tok-k">var</span> <span class="tok-n">subTaskIndex</span> <span class="tok-k">=</span> <span class="tok-mi">0</span>

  <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">open</span><span class="tok-o">(</span><span class="tok-n">configuration</span><span class="tok-k">:</span> <span class="tok-kt">Configuration</span><span class="tok-o">)</span><span class="tok-k">:</span> <span class="tok-kt">Unit</span> <span class="tok-o">=</span> <span class="tok-o">{</span>
    <span class="tok-n">subTaskIndex</span> <span class="tok-k">=</span> <span class="tok-n">getRuntimeContext</span><span class="tok-o">.</span><span class="tok-n">getIndexOfThisSubtask</span>
    <span class="tok-c1">// 做一些初始化工作</span>
    <span class="tok-c1">// 例如建立一个和HDFS的连接</span>
  <span class="tok-o">}</span>

  <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">flatMap</span><span class="tok-o">(</span><span class="tok-n">in</span><span class="tok-k">:</span> <span class="tok-kt">Int</span><span class="tok-o">,</span> <span class="tok-n">out</span><span class="tok-k">:</span> <span class="tok-kt">Collector</span><span class="tok-o">[(</span><span class="tok-kt">Int</span>, <span class="tok-kt">Int</span><span class="tok-o">)])</span><span class="tok-k">:</span> <span class="tok-kt">Unit</span> <span class="tok-o">=</span> <span class="tok-o">{</span>
    <span class="tok-k">if</span> <span class="tok-o">(</span><span class="tok-n">in</span> <span class="tok-o">%</span> <span class="tok-mi">2</span> <span class="tok-o">==</span> <span class="tok-n">subTaskIndex</span><span class="tok-o">)</span> <span class="tok-o">{</span>
      <span class="tok-n">out</span><span class="tok-o">.</span><span class="tok-n">collect</span><span class="tok-o">((</span><span class="tok-n">subTaskIndex</span><span class="tok-o">,</span> <span class="tok-n">in</span><span class="tok-o">))</span>
    <span class="tok-o">}</span>
  <span class="tok-o">}</span>

  <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">close</span><span class="tok-o">()</span><span class="tok-k">:</span> <span class="tok-kt">Unit</span> <span class="tok-o">=</span> <span class="tok-o">{</span>
    <span class="tok-c1">// 清理工作，断开和HDFS的连接。</span>
  <span class="tok-o">}</span>
<span class="tok-o">}</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_sink">6.9. Sink</h3>
<div class="paragraph">
<p>Flink没有类似于Spark中foreach方法，让用户进行迭代的操作。所有对外的输出操作都要利用Sink完成。最后通过类似如下方式完成整个任务最终输出操作。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-n">stream</span><span class="tok-o">.</span><span class="tok-n">addSink</span><span class="tok-o">(</span><span class="tok-k">new</span> <span class="tok-nc">MySink</span><span class="tok-o">(</span><span class="tok-n">xxxx</span><span class="tok-o">))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>官方提供了一部分的框架的sink。除此以外，需要用户自定义实现sink。</p>
</div>
<div class="sect3">
<h4 id="_elasticsearch">6.9.1. Elasticsearch</h4>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="xml"><span></span><span class="tok-nt">&lt;dependency&gt;</span>
    <span class="tok-nt">&lt;groupId&gt;</span>org.apache.flink<span class="tok-nt">&lt;/groupId&gt;</span>
    <span class="tok-nt">&lt;artifactId&gt;</span>flink-connector-elasticsearch6_${scala.binary.version}<span class="tok-nt">&lt;/artifactId&gt;</span>
    <span class="tok-nt">&lt;version&gt;</span>${flink.version}<span class="tok-nt">&lt;/version&gt;</span>
<span class="tok-nt">&lt;/dependency&gt;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">package</span> <span class="tok-nn">com.atguigu</span>

<span class="tok-k">import</span> <span class="tok-nn">org.apache.flink.streaming.api.scala.StreamExecutionEnvironment</span>
<span class="tok-k">import</span> <span class="tok-nn">org.apache.flink.streaming.connectors.elasticsearch.ElasticsearchSinkFunction</span>
<span class="tok-k">import</span> <span class="tok-nn">org.apache.flink.streaming.connectors.elasticsearch6.ElasticsearchSink</span>
<span class="tok-k">import</span> <span class="tok-nn">org.apache.http.HttpHost</span>
<span class="tok-k">import</span> <span class="tok-nn">org.elasticsearch.action.index.IndexRequest</span>
<span class="tok-k">import</span> <span class="tok-nn">org.elasticsearch.client.Requests</span>
<span class="tok-k">import</span> <span class="tok-nn">org.apache.flink.api.common.functions.RuntimeContext</span>
<span class="tok-k">import</span> <span class="tok-nn">org.apache.flink.streaming.connectors.elasticsearch.RequestIndexer</span>

<span class="tok-k">import</span> <span class="tok-nn">org.apache.flink.streaming.api.scala._</span>

<span class="tok-k">object</span> <span class="tok-nc">StreamingJob</span> <span class="tok-o">{</span>
  <span class="tok-k">def</span> <span class="tok-n">main</span><span class="tok-o">(</span><span class="tok-n">args</span><span class="tok-k">:</span> <span class="tok-kt">Array</span><span class="tok-o">[</span><span class="tok-kt">String</span><span class="tok-o">])</span><span class="tok-k">:</span> <span class="tok-kt">Unit</span> <span class="tok-o">=</span> <span class="tok-o">{</span>
    <span class="tok-k">val</span> <span class="tok-n">env</span> <span class="tok-k">=</span> <span class="tok-nc">StreamExecutionEnvironment</span><span class="tok-o">.</span><span class="tok-n">getExecutionEnvironment</span>
    <span class="tok-n">env</span><span class="tok-o">.</span><span class="tok-n">setParallelism</span><span class="tok-o">(</span><span class="tok-mi">1</span><span class="tok-o">)</span>

    <span class="tok-k">val</span> <span class="tok-n">stream</span> <span class="tok-k">=</span> <span class="tok-n">env</span><span class="tok-o">.</span><span class="tok-n">fromCollection</span><span class="tok-o">(</span><span class="tok-nc">List</span><span class="tok-o">(</span>
      <span class="tok-s">&quot;a&quot;</span><span class="tok-o">,</span>
      <span class="tok-s">&quot;b&quot;</span>
    <span class="tok-o">))</span>

    <span class="tok-k">val</span> <span class="tok-n">httpHosts</span> <span class="tok-k">=</span> <span class="tok-k">new</span> <span class="tok-n">java</span><span class="tok-o">.</span><span class="tok-n">util</span><span class="tok-o">.</span><span class="tok-nc">ArrayList</span><span class="tok-o">[</span><span class="tok-kt">HttpHost</span><span class="tok-o">]</span>
    <span class="tok-n">httpHosts</span><span class="tok-o">.</span><span class="tok-n">add</span><span class="tok-o">(</span><span class="tok-k">new</span> <span class="tok-nc">HttpHost</span><span class="tok-o">(</span><span class="tok-s">&quot;127.0.0.1&quot;</span><span class="tok-o">,</span> <span class="tok-mi">9200</span><span class="tok-o">,</span> <span class="tok-s">&quot;http&quot;</span><span class="tok-o">))</span>

    <span class="tok-k">val</span> <span class="tok-n">esSinkBuilder</span> <span class="tok-k">=</span> <span class="tok-k">new</span> <span class="tok-nc">ElasticsearchSink</span><span class="tok-o">.</span><span class="tok-nc">Builder</span><span class="tok-o">[</span><span class="tok-kt">String</span><span class="tok-o">](</span>
      <span class="tok-n">httpHosts</span><span class="tok-o">,</span>
      <span class="tok-k">new</span> <span class="tok-nc">ElasticsearchSinkFunction</span><span class="tok-o">[</span><span class="tok-kt">String</span><span class="tok-o">]</span> <span class="tok-o">{</span>
        <span class="tok-k">def</span> <span class="tok-n">createIndexRequest</span><span class="tok-o">(</span><span class="tok-n">element</span><span class="tok-k">:</span> <span class="tok-kt">String</span><span class="tok-o">)</span><span class="tok-k">:</span> <span class="tok-kt">IndexRequest</span> <span class="tok-o">=</span> <span class="tok-o">{</span>
          <span class="tok-k">val</span> <span class="tok-n">json</span> <span class="tok-k">=</span> <span class="tok-k">new</span> <span class="tok-n">java</span><span class="tok-o">.</span><span class="tok-n">util</span><span class="tok-o">.</span><span class="tok-nc">HashMap</span><span class="tok-o">[</span><span class="tok-kt">String</span>, <span class="tok-kt">String</span><span class="tok-o">]</span>
          <span class="tok-n">json</span><span class="tok-o">.</span><span class="tok-n">put</span><span class="tok-o">(</span><span class="tok-s">&quot;data&quot;</span><span class="tok-o">,</span> <span class="tok-n">element</span><span class="tok-o">)</span>

          <span class="tok-nc">Requests</span><span class="tok-o">.</span><span class="tok-n">indexRequest</span><span class="tok-o">()</span>
                  <span class="tok-o">.</span><span class="tok-n">index</span><span class="tok-o">(</span><span class="tok-s">&quot;my-index&quot;</span><span class="tok-o">)</span>
                  <span class="tok-o">.</span><span class="tok-n">`type`</span><span class="tok-o">(</span><span class="tok-s">&quot;my-type&quot;</span><span class="tok-o">)</span>
                  <span class="tok-o">.</span><span class="tok-n">source</span><span class="tok-o">(</span><span class="tok-n">json</span><span class="tok-o">)</span>
        <span class="tok-o">}</span>

        <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">process</span><span class="tok-o">(</span><span class="tok-n">element</span><span class="tok-k">:</span> <span class="tok-kt">String</span><span class="tok-o">,</span> <span class="tok-n">ctx</span><span class="tok-k">:</span> <span class="tok-kt">RuntimeContext</span><span class="tok-o">,</span> <span class="tok-n">indexer</span><span class="tok-k">:</span> <span class="tok-kt">RequestIndexer</span><span class="tok-o">)</span><span class="tok-k">:</span> <span class="tok-kt">Unit</span> <span class="tok-o">=</span> <span class="tok-o">{</span>
          <span class="tok-n">indexer</span><span class="tok-o">.</span><span class="tok-n">add</span><span class="tok-o">(</span><span class="tok-n">createIndexRequest</span><span class="tok-o">(</span><span class="tok-n">element</span><span class="tok-o">))</span>
        <span class="tok-o">}</span>
      <span class="tok-o">}</span>
    <span class="tok-o">)</span>

    <span class="tok-c1">// finally, build and add the sink to the job&#39;s pipeline</span>
    <span class="tok-n">stream</span><span class="tok-o">.</span><span class="tok-n">addSink</span><span class="tok-o">(</span><span class="tok-n">esSinkBuilder</span><span class="tok-o">.</span><span class="tok-n">build</span><span class="tok-o">)</span>

    <span class="tok-n">env</span><span class="tok-o">.</span><span class="tok-n">execute</span>
  <span class="tok-o">}</span>

<span class="tok-o">}</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_distribution_transformations分布式转换算子">6.10. Distribution Transformations(分布式转换算子)</h3>
<div class="paragraph">
<p><strong>Random</strong></p>
</div>
<div class="paragraph">
<p>随机数据交换由DataStream.shuffle()方法实现。shuffle方法将数据随机的分配到并行的任务中去。</p>
</div>
<div class="paragraph">
<p><strong>Round-Robin</strong></p>
</div>
<div class="paragraph">
<p>Round-Robin是一种负载均衡算法。可以将数据平均分配到并行的任务中去。</p>
</div>
<div class="paragraph">
<p><strong>Rescale</strong></p>
</div>
<div class="paragraph">
<p>rescale方法使用的也是round-robin算法，但只会将数据发送到接下来的task slots中的一部分task slots中。</p>
</div>
<div class="paragraph">
<p><strong>Broadcast</strong></p>
</div>
<div class="paragraph">
<p>broadcast方法将数据复制并发送到所有的并行任务中去。</p>
</div>
<div class="paragraph">
<p><strong>Global</strong></p>
</div>
<div class="paragraph">
<p>global方法将所有的数据都发送到下游算子的第一个并行任务中去。这个操作需要很谨慎，因为将所有数据发送到同一个task，将会对应用造成很大的压力。</p>
</div>
<div class="paragraph">
<p><strong>Custom</strong></p>
</div>
<div class="paragraph">
<p>自定义数据分配策略。</p>
</div>
<div class="paragraph">
<p>下面的例子将一条整数流做partition，使得所有的负整数都发送到第一个任务中，剩下的数随机分配。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">val</span> <span class="tok-n">numbers</span><span class="tok-k">:</span> <span class="tok-kt">DataStream</span><span class="tok-o">[(</span><span class="tok-kt">Int</span><span class="tok-o">)]</span> <span class="tok-k">=</span> <span class="tok-o">...</span>
<span class="tok-n">numbers</span><span class="tok-o">.</span><span class="tok-n">partitionCustom</span><span class="tok-o">(</span><span class="tok-n">myPartitioner</span><span class="tok-o">,</span> <span class="tok-mi">0</span><span class="tok-o">)</span>

<span class="tok-k">object</span> <span class="tok-nc">myPartitioner</span> <span class="tok-k">extends</span> <span class="tok-nc">Partitioner</span><span class="tok-o">[</span><span class="tok-kt">Int</span><span class="tok-o">]</span> <span class="tok-o">{</span>
  <span class="tok-k">val</span> <span class="tok-n">r</span> <span class="tok-k">=</span> <span class="tok-n">scala</span><span class="tok-o">.</span><span class="tok-n">util</span><span class="tok-o">.</span><span class="tok-nc">Random</span>

  <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">partition</span><span class="tok-o">(</span><span class="tok-n">key</span><span class="tok-k">:</span> <span class="tok-kt">Int</span><span class="tok-o">,</span> <span class="tok-n">numPartitions</span><span class="tok-k">:</span> <span class="tok-kt">Int</span><span class="tok-o">)</span><span class="tok-k">:</span> <span class="tok-kt">Int</span> <span class="tok-o">=</span> <span class="tok-o">{</span>
    <span class="tok-k">if</span> <span class="tok-o">(</span><span class="tok-n">key</span> <span class="tok-o">&lt;</span> <span class="tok-mi">0</span><span class="tok-o">)</span> <span class="tok-mi">0</span> <span class="tok-k">else</span> <span class="tok-n">r</span><span class="tok-o">.</span><span class="tok-n">nextInt</span><span class="tok-o">(</span><span class="tok-n">numPartitions</span><span class="tok-o">)</span>
  <span class="tok-o">}</span>
<span class="tok-o">}</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_time与window">7. Time与Window</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_time">7.1. Time</h3>
<div class="paragraph">
<p>在Flink的流式处理中，会涉及到时间的不同概念，如下图所示：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/event_ingestion_processing_time.png" alt="event ingestion processing time">
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Event Time</strong>：是事件创建的时间。它通常由事件中的时间戳描述，例如采集的日志数据中，每一条日志都会记录自己的生成时间，Flink通过时间戳分配器访问事件时间戳。</p>
</li>
<li>
<p><strong>Ingestion Time</strong>：是数据进入Flink的时间。</p>
</li>
<li>
<p><strong>Processing Time</strong>：是每一个执行基于时间操作的算子的本地系统时间，与机器相关，默认的时间属性就是Processing Time。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>著名的星球大战的例子</strong></p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/starwars.png" alt="starwars">
</div>
</div>
<div class="paragraph">
<p>例如，一条日志进入Flink的时间为<code>2017-11-12 10:00:00.123</code>，到达Window的系统时间为<code>2017-11-12 10:00:01.234</code>，日志的内容如下:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>2017-11-02 18:37:15.624 INFO Fail over to rm2</pre>
</div>
</div>
<div class="paragraph">
<p>对于业务来说，要统计1min内的故障日志个数，哪个时间是最有意义的？—— Event Time，因为我们要根据日志的生成时间进行统计。</p>
</div>
<div class="paragraph">
<p>设置时间：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">object</span> <span class="tok-nc">AverageSensorReadings</span> <span class="tok-o">{</span>
    <span class="tok-k">def</span> <span class="tok-n">main</span><span class="tok-o">(</span><span class="tok-n">args</span><span class="tok-k">:</span> <span class="tok-kt">Array</span><span class="tok-o">[</span><span class="tok-kt">String</span><span class="tok-o">])</span> <span class="tok-o">{</span>
        <span class="tok-k">val</span> <span class="tok-n">env</span> <span class="tok-k">=</span> <span class="tok-nc">StreamExecutionEnvironment</span><span class="tok-o">.</span><span class="tok-n">getExecutionEnvironment</span>

        <span class="tok-n">env</span><span class="tok-o">.</span><span class="tok-n">setStreamTimeCharacteristic</span><span class="tok-o">(</span><span class="tok-nc">TimeCharacteristic</span><span class="tok-o">.</span><span class="tok-nc">EventTime</span><span class="tok-o">)</span>

        <span class="tok-k">val</span> <span class="tok-n">sensorData</span><span class="tok-k">:</span> <span class="tok-kt">DataStream</span><span class="tok-o">[</span><span class="tok-kt">SensorReading</span><span class="tok-o">]</span> <span class="tok-k">=</span> <span class="tok-n">env</span><span class="tok-o">.</span><span class="tok-n">addSource</span><span class="tok-o">(...)</span>
    <span class="tok-o">}</span>
<span class="tok-o">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果想设置为Processing Time，将TimeCharacteristic.EventTime替换为TimeCharacteristic.ProcessingTime即可。</p>
</div>
</div>
<div class="sect2">
<h3 id="_window">7.2. Window</h3>
<div class="sect3">
<h4 id="_window概述">7.2.1. Window概述</h4>
<div class="paragraph">
<p>Streaming流式计算是一种被设计用于处理无限数据集的数据处理引擎，而无限数据集是指一种不断增长的本质上无限的数据集，而Window是一种切割无限数据为有限块进行处理的手段。</p>
</div>
<div class="paragraph">
<p>Window是无限数据流处理的核心，Window将一个无限的Stream拆分成有限大小的”Buckets”桶，我们可以在这些桶上做计算操作。</p>
</div>
</div>
<div class="sect3">
<h4 id="_window类型">7.2.2. Window类型</h4>
<div class="paragraph">
<p>Window可以分成两类：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>CountWindow</strong>：按照指定的数据条数生成一个Window，与时间无关。</p>
</li>
<li>
<p><strong>TimeWindow</strong>：按照时间生成Window。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>对于TimeWindow，可以根据窗口实现原理的不同分成三类：滚动窗口(Tumbling Window)、滑动窗口(Sliding Window)和会话窗口(Session Window)。</p>
</div>
<div class="paragraph">
<p><strong>滚动窗口(Tumbling Windows)</strong></p>
</div>
<div class="paragraph">
<p>将数据依据固定的窗口长度对数据进行切片。</p>
</div>
<div class="paragraph">
<p>特点：时间对齐，窗口长度固定，没有重叠。</p>
</div>
<div class="paragraph">
<p>滚动窗口分配器将每个元素分配到一个指定窗口大小的窗口中，滚动窗口有一个固定的大小，并且不会出现重叠。例如：如果你指定了一个5分钟大小的滚动窗口，窗口的创建如下图所示：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/tumbling-windows.png" alt="tumbling windows">
</div>
</div>
<div class="paragraph">
<p>适用场景：适合做BI统计等(做每个时间段的聚合计算)。</p>
</div>
<div class="paragraph">
<p><strong>滑动窗口(Sliding Windows)</strong></p>
</div>
<div class="paragraph">
<p>滑动窗口是固定窗口的更广义的一种形式，滑动窗口由固定的窗口长度和滑动间隔组成。</p>
</div>
<div class="paragraph">
<p>特点：时间对齐，窗口长度固定，有重叠。</p>
</div>
<div class="paragraph">
<p>滑动窗口分配器将元素分配到固定长度的窗口中，与滚动窗口类似，窗口的大小由窗口大小参数来配置，另一个窗口滑动参数控制滑动窗口开始的频率。因此，滑动窗口如果滑动参数小于窗口大小的话，窗口是可以重叠的，在这种情况下元素会被分配到多个窗口中。</p>
</div>
<div class="paragraph">
<p>例如，你有10分钟的窗口和5分钟的滑动，那么每个窗口中5分钟的窗口里包含着上个10分钟产生的数据，如下图所示：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/sliding-windows.png" alt="sliding windows">
</div>
</div>
<div class="paragraph">
<p>适用场景：对最近一个时间段内的统计(求某接口最近5min的失败率来决定是否要报警)。</p>
</div>
<div class="paragraph">
<p><strong>会话窗口(Session Windows)</strong></p>
</div>
<div class="paragraph">
<p>由一系列事件组合一个指定时间长度的timeout间隙组成，类似于web应用的session，也就是一段时间没有接收到新数据就会生成新的窗口。</p>
</div>
<div class="paragraph">
<p>特点：时间无对齐。</p>
</div>
<div class="paragraph">
<p>session窗口分配器通过session活动来对元素进行分组，session窗口跟滚动窗口和滑动窗口相比，不会有重叠和固定的开始时间和结束时间的情况，相反，当它在一个固定的时间周期内不再收到元素，即非活动间隔产生，那个这个窗口就会关闭。一个session窗口通过一个session间隔来配置，这个session间隔定义了非活跃周期的长度，当这个非活跃周期产生，那么当前的session将关闭并且后续的元素将被分配到新的session窗口中去。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/session-windows.png" alt="session windows">
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_window_api">7.3. Window API</h3>
<div class="paragraph">
<p><strong>TimeWindow</strong></p>
</div>
<div class="paragraph">
<p>TimeWindow是将指定时间范围内的所有数据组成一个Window，一次对一个Window里面的所有数据进行计算。</p>
</div>
<div class="paragraph">
<p><strong>滚动窗口</strong></p>
</div>
<div class="paragraph">
<p>Flink默认的时间窗口根据<strong>Processing Time</strong>进行窗口的划分，将Flink获取到的数据根据进入Flink的时间划分到不同的窗口中。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-c1">// 每个传感器每个滚动窗口(15s)的最小温度值</span>
<span class="tok-k">val</span> <span class="tok-n">minTempPerWindow</span><span class="tok-k">:</span> <span class="tok-kt">DataStream</span><span class="tok-o">[(</span><span class="tok-kt">String</span>, <span class="tok-kt">Double</span><span class="tok-o">)]</span> <span class="tok-k">=</span> <span class="tok-n">sensorData</span>
  <span class="tok-o">.</span><span class="tok-n">map</span><span class="tok-o">(</span><span class="tok-n">r</span> <span class="tok-k">=&gt;</span> <span class="tok-o">(</span><span class="tok-n">r</span><span class="tok-o">.</span><span class="tok-n">id</span><span class="tok-o">,</span> <span class="tok-n">r</span><span class="tok-o">.</span><span class="tok-n">temperature</span><span class="tok-o">))</span>
  <span class="tok-c1">// 按照传感器id分流</span>
  <span class="tok-o">.</span><span class="tok-n">keyBy</span><span class="tok-o">(</span><span class="tok-k">_</span><span class="tok-o">.</span><span class="tok-n">_1</span><span class="tok-o">)</span>
  <span class="tok-o">.</span><span class="tok-n">timeWindow</span><span class="tok-o">(</span><span class="tok-nc">Time</span><span class="tok-o">.</span><span class="tok-n">seconds</span><span class="tok-o">(</span><span class="tok-mi">15</span><span class="tok-o">))</span>
  <span class="tok-o">.</span><span class="tok-n">reduce</span><span class="tok-o">((</span><span class="tok-n">r1</span><span class="tok-o">,</span> <span class="tok-n">r2</span><span class="tok-o">)</span> <span class="tok-k">=&gt;</span> <span class="tok-o">(</span><span class="tok-n">r1</span><span class="tok-o">.</span><span class="tok-n">_1</span><span class="tok-o">,</span> <span class="tok-n">r1</span><span class="tok-o">.</span><span class="tok-n">_2</span><span class="tok-o">.</span><span class="tok-n">min</span><span class="tok-o">(</span><span class="tok-n">r2</span><span class="tok-o">.</span><span class="tok-n">_2</span><span class="tok-o">)))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>时间间隔可以通过Time.milliseconds(x)，Time.seconds(x)，Time.minutes(x)等其中的一个来指定。</p>
</div>
<div class="paragraph">
<p><strong>滑动窗口</strong></p>
</div>
<div class="paragraph">
<p>滑动窗口和滚动窗口的函数名是完全一致的，只是在传参数时需要传入两个参数，一个是window_size，一个是sliding_size。</p>
</div>
<div class="paragraph">
<p>下面代码中的sliding_size设置为了5s，也就是说，窗口每5s就计算一次，每一次计算的window范围是15s内的所有元素。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">val</span> <span class="tok-n">minTempPerWindow</span><span class="tok-k">:</span> <span class="tok-kt">DataStream</span><span class="tok-o">[(</span><span class="tok-kt">String</span>, <span class="tok-kt">Double</span><span class="tok-o">)]</span> <span class="tok-k">=</span> <span class="tok-n">sensorData</span>
  <span class="tok-o">.</span><span class="tok-n">map</span><span class="tok-o">(</span><span class="tok-n">r</span> <span class="tok-k">=&gt;</span> <span class="tok-o">(</span><span class="tok-n">r</span><span class="tok-o">.</span><span class="tok-n">id</span><span class="tok-o">,</span> <span class="tok-n">r</span><span class="tok-o">.</span><span class="tok-n">temperature</span><span class="tok-o">))</span>
  <span class="tok-c1">// 按照传感器id分流</span>
  <span class="tok-o">.</span><span class="tok-n">keyBy</span><span class="tok-o">(</span><span class="tok-k">_</span><span class="tok-o">.</span><span class="tok-n">_1</span><span class="tok-o">)</span>
  <span class="tok-o">.</span><span class="tok-n">timeWindow</span><span class="tok-o">(</span><span class="tok-nc">Time</span><span class="tok-o">.</span><span class="tok-n">seconds</span><span class="tok-o">(</span><span class="tok-mi">15</span><span class="tok-o">),</span> <span class="tok-nc">Time</span><span class="tok-o">.</span><span class="tok-n">seconds</span><span class="tok-o">(</span><span class="tok-mi">5</span><span class="tok-o">))</span>
  <span class="tok-o">.</span><span class="tok-n">reduce</span><span class="tok-o">((</span><span class="tok-n">r1</span><span class="tok-o">,</span> <span class="tok-n">r2</span><span class="tok-o">)</span> <span class="tok-k">=&gt;</span> <span class="tok-o">(</span><span class="tok-n">r1</span><span class="tok-o">.</span><span class="tok-n">_1</span><span class="tok-o">,</span> <span class="tok-n">r1</span><span class="tok-o">.</span><span class="tok-n">_2</span><span class="tok-o">.</span><span class="tok-n">min</span><span class="tok-o">(</span><span class="tok-n">r2</span><span class="tok-o">.</span><span class="tok-n">_2</span><span class="tok-o">)))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>时间间隔可以通过Time.milliseconds(x)，Time.seconds(x)，Time.minutes(x)等其中的一个来指定。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_event_time与window">8. Event Time与Window</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_configure_time_characteristic">8.1. Configure Time Characteristic</h3>
<div class="sect3">
<h4 id="_event_time的引入">8.1.1. Event Time的引入</h4>
<div class="paragraph">
<p>在Flink的流式处理中，绝大部分的业务都会使用Event Time，一般只在Event Time无法使用时，才会被迫使用Processing Time或者Ingestion Time。
如果要使用Event Time，那么需要引入Event Time的时间属性，引入方式如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">val</span> <span class="tok-n">env</span> <span class="tok-k">=</span> <span class="tok-nc">StreamExecutionEnvironment</span><span class="tok-o">.</span><span class="tok-n">getExecutionEnvironment</span>

<span class="tok-c1">// 从调用时刻开始给env创建的每一个stream追加时间特征</span>
<span class="tok-n">env</span><span class="tok-o">.</span><span class="tok-n">setStreamTimeCharacteristic</span><span class="tok-o">(</span><span class="tok-nc">TimeCharacteristic</span><span class="tok-o">.</span><span class="tok-nc">EventTime</span><span class="tok-o">)</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_watermark">8.1.2. Watermark</h4>
<div class="sect4">
<h5 id="_基本概念">基本概念</h5>
<div class="paragraph">
<p>我们知道，流处理从事件产生，到流经source，再到operator，中间是有一个过程和时间的，虽然大部分情况下，流到operator的数据都是按照事件产生的时间顺序来的，但是也不排除由于网络、分布式等原因，导致乱序的产生，所谓乱序，就是指Flink接收到的事件的先后顺序不是严格按照事件的Event Time顺序排列的。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/stream_watermark_in_order.png" alt="stream watermark in order">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="images/stream_watermark_out_of_order.png" alt="stream watermark out of order">
</div>
</div>
<div class="paragraph">
<p>那么此时出现一个问题，一旦出现乱序，如果只根据Event Time决定Window的运行，我们不能明确数据是否全部到位，但又不能无限期的等下去，此时必须要有个机制来保证一个特定的时间后，必须触发Window去进行计算了，这个特别的机制，就是Watermark。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Watermark是一种衡量Event Time进展的机制，它是数据本身的一个隐藏属性，数据本身携带着对应的Watermark。</p>
</li>
<li>
<p>Watermark是用于处理乱序事件的，而正确的处理乱序事件，通常用Watermark机制结合Window来实现。</p>
</li>
<li>
<p>数据流中的Watermark用于表示timestamp小于Watermark的数据，都已经到达了，因此，Window的执行也是由Watermark触发的。</p>
</li>
<li>
<p>Watermark可以理解成一个延迟触发机制，我们可以设置Watermark的延时时长t，每次系统会校验已经到达的数据中最大的maxEventTime，然后认定Event Time小于maxEventTime - t的所有数据都已经到达，如果有窗口的停止时间等于maxEventTime – t，那么这个窗口被触发执行。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>有序流的Watermarker如下图所示：(Watermark的延时时长设置为0)</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/inorderdata.png" alt="inorderdata">
</div>
</div>
<div class="paragraph">
<p>乱序流的Watermarker如下图所示：(Watermark的延时时长设置为2)</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/outorderdata.png" alt="outorderdata">
</div>
</div>
<div class="paragraph">
<p>Watermark就等于当前所有到达数据中的maxEventTime - 延迟时长，也就是说，Watermark是由数据携带的，一旦数据携带的Watermark比当前未触发的窗口的停止时间要晚，那么就会触发相应窗口的执行。由于Watermark是由数据携带的，因此，如果运行过程中无法获取新的数据，那么没有被触发的窗口将永远都不被触发。</p>
</div>
<div class="paragraph">
<p>上图中，我们设置的允许最大延迟到达时间为2s，所以时间戳为7s的事件对应的Watermark是5s，时间戳为12s的事件的Watermark是10s，如果我们的窗口1是1s～5s，窗口2是6s～10s，那么时间戳为7s的事件到达时的Watermarker恰好触发窗口1，时间戳为12s的事件到达时的Watermark恰好触发窗口2。</p>
</div>
<div class="paragraph">
<p>Watermark就是触发前一窗口的"关窗时间"，一旦触发关门那么以当前时刻为准在窗口范围内的所有数据都会收入窗中。</p>
</div>
<div class="paragraph">
<p>只要没有达到水位那么不管现实中的时间推进了多久都不会触发关窗。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_watermark的引入">8.1.3. Watermark的引入</h4>
<div class="paragraph">
<p>Event Time的使用一定要<strong>指定数据源中的时间戳</strong>。否则程序无法知道事件的事件时间是什么(数据源里的数据没有时间戳的话，就只能使用Processing Time了)。</p>
</div>
<div class="paragraph">
<p>Flink暴露了TimestampAssigner接口供我们实现，使我们可以自定义如何从事件数据中抽取时间戳。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">val</span> <span class="tok-n">env</span> <span class="tok-k">=</span> <span class="tok-nc">StreamExecutionEnvironment</span><span class="tok-o">.</span><span class="tok-n">getExecutionEnvironment</span>

<span class="tok-c1">// 从调用时刻开始给env创建的每一个stream追加时间特征</span>
<span class="tok-n">env</span><span class="tok-o">.</span><span class="tok-n">setStreamTimeCharacteristic</span><span class="tok-o">(</span><span class="tok-nc">TimeCharacteristic</span><span class="tok-o">.</span><span class="tok-nc">EventTime</span><span class="tok-o">)</span>

<span class="tok-k">val</span> <span class="tok-n">readings</span><span class="tok-k">:</span> <span class="tok-kt">DataStream</span><span class="tok-o">[</span><span class="tok-kt">SensorReading</span><span class="tok-o">]</span> <span class="tok-k">=</span> <span class="tok-n">env</span>
  <span class="tok-o">.</span><span class="tok-n">addSource</span><span class="tok-o">(</span><span class="tok-k">new</span> <span class="tok-nc">SensorSource</span><span class="tok-o">)</span>
  <span class="tok-o">.</span><span class="tok-n">assignTimestampsAndWatermarks</span><span class="tok-o">(</span><span class="tok-k">new</span> <span class="tok-nc">MyAssigner</span><span class="tok-o">())</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>MyAssigner有两种类型</p>
</div>
<div class="ulist">
<ul>
<li>
<p>AssignerWithPeriodicWatermarks</p>
</li>
<li>
<p>AssignerWithPunctuatedWatermarks</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>以上两个接口都继承自TimestampAssigner。</p>
</div>
<div class="paragraph">
<p><strong>Assigner with periodic watermarks</strong></p>
</div>
<div class="paragraph">
<p>周期性的生成水印：系统会周期性的将水印插入到流中（水印也是一种特殊的事件!）。默认周期是200毫秒。可以使用ExecutionConfig.setAutoWatermarkInterval()方法进行设置。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">val</span> <span class="tok-n">env</span> <span class="tok-k">=</span> <span class="tok-nc">StreamExecutionEnvironment</span><span class="tok-o">.</span><span class="tok-n">getExecutionEnvironment</span>
<span class="tok-n">env</span><span class="tok-o">.</span><span class="tok-n">setStreamTimeCharacteristic</span><span class="tok-o">(</span><span class="tok-nc">TimeCharacteristic</span><span class="tok-o">.</span><span class="tok-nc">EventTime</span><span class="tok-o">)</span>
<span class="tok-c1">// 每隔5秒产生一个水印</span>
<span class="tok-n">env</span><span class="tok-o">.</span><span class="tok-n">getConfig</span><span class="tok-o">.</span><span class="tok-n">setAutoWatermarkInterval</span><span class="tok-o">(</span><span class="tok-mi">5000</span><span class="tok-o">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>产生水印的逻辑：每隔5秒钟，Flink会调用AssignerWithPeriodicWatermarks的getCurrentWatermark()方法。如果方法返回一个时间戳大于之前水印的时间戳，新的水印会被插入到流中。这个检查保证了水印是单调递增的。如果方法返回的时间戳小于等于之前水印的时间戳，则不会产生新的水印。</p>
</div>
<div class="paragraph">
<p>例子，自定义一个周期性的时间戳抽取</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">class</span> <span class="tok-nc">PeriodicAssigner</span> <span class="tok-k">extends</span> <span class="tok-nc">AssignerWithPeriodicWatermarks</span><span class="tok-o">[</span><span class="tok-kt">SensorReading</span><span class="tok-o">]</span> <span class="tok-o">{</span>
  <span class="tok-k">val</span> <span class="tok-n">bound</span><span class="tok-k">:</span> <span class="tok-kt">Long</span> <span class="tok-o">=</span> <span class="tok-mi">60</span> <span class="tok-o">*</span> <span class="tok-mi">1000</span> <span class="tok-c1">// 延时为1分钟</span>
  <span class="tok-k">var</span> <span class="tok-n">maxTs</span><span class="tok-k">:</span> <span class="tok-kt">Long</span> <span class="tok-o">=</span> <span class="tok-nc">Long</span><span class="tok-o">.</span><span class="tok-nc">MinValue</span> <span class="tok-c1">// 观察到的最大时间戳</span>

  <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">getCurrentWatermark</span><span class="tok-k">:</span> <span class="tok-kt">Watermark</span> <span class="tok-o">=</span> <span class="tok-o">{</span>
    <span class="tok-k">new</span> <span class="tok-nc">Watermark</span><span class="tok-o">(</span><span class="tok-n">maxTs</span> <span class="tok-o">-</span> <span class="tok-n">bound</span><span class="tok-o">)</span>
  <span class="tok-o">}</span>

  <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">extractTimestamp</span><span class="tok-o">(</span><span class="tok-n">r</span><span class="tok-k">:</span> <span class="tok-kt">SensorReading</span><span class="tok-o">,</span> <span class="tok-n">previousTS</span><span class="tok-k">:</span> <span class="tok-kt">Long</span><span class="tok-o">)</span> <span class="tok-k">=</span> <span class="tok-o">{</span>
    <span class="tok-n">maxTs</span> <span class="tok-k">=</span> <span class="tok-n">maxTs</span><span class="tok-o">.</span><span class="tok-n">max</span><span class="tok-o">(</span><span class="tok-n">r</span><span class="tok-o">.</span><span class="tok-n">timestamp</span><span class="tok-o">)</span>
    <span class="tok-n">r</span><span class="tok-o">.</span><span class="tok-n">timestamp</span>
  <span class="tok-o">}</span>
<span class="tok-o">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果我们事先得知数据流的时间戳是单调递增的，也就是说没有乱序。我们可以使用assignAscendingTimestamps，方法会直接使用数据的时间戳生成水印。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">val</span> <span class="tok-n">stream</span><span class="tok-k">:</span> <span class="tok-kt">DataStream</span><span class="tok-o">[</span><span class="tok-kt">SensorReading</span><span class="tok-o">]</span> <span class="tok-k">=</span> <span class="tok-o">...</span>
<span class="tok-k">val</span> <span class="tok-n">withTimestampsAndWatermarks</span> <span class="tok-k">=</span> <span class="tok-n">stream</span>
  <span class="tok-o">.</span><span class="tok-n">assignAscendingTimestamps</span><span class="tok-o">(</span><span class="tok-n">e</span> <span class="tok-k">=&gt;</span> <span class="tok-n">e</span><span class="tok-o">.</span><span class="tok-n">timestamp</span><span class="tok-o">)</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>E(1), W(1), E(2), W(2), ...</pre>
</div>
</div>
<div class="paragraph">
<p>如果我们能大致估算出数据流中的事件的最大延迟时间，可以使用如下代码</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">val</span> <span class="tok-n">stream</span><span class="tok-k">:</span> <span class="tok-kt">DataStream</span><span class="tok-o">[</span><span class="tok-kt">SensorReading</span><span class="tok-o">]</span> <span class="tok-k">=</span> <span class="tok-o">...</span>
<span class="tok-k">val</span> <span class="tok-n">withTimestampsAndWatermarks</span> <span class="tok-k">=</span> <span class="tok-n">stream</span><span class="tok-o">.</span><span class="tok-n">assignTimestampsAndWatermarks</span><span class="tok-o">(</span>
  <span class="tok-k">new</span> <span class="tok-nc">SensorTimeAssigner</span>
<span class="tok-o">)</span>

<span class="tok-k">class</span> <span class="tok-nc">SensorTimeAssigner</span>
  <span class="tok-k">extends</span> <span class="tok-nc">BoundedOutOfOrdernessTimestampExtractor</span><span class="tok-o">[</span><span class="tok-kt">SensorReading</span><span class="tok-o">](</span><span class="tok-nc">Time</span><span class="tok-o">.</span><span class="tok-n">seconds</span><span class="tok-o">(</span><span class="tok-mi">5</span><span class="tok-o">))</span> <span class="tok-o">{</span>

  <span class="tok-c1">// 抽取时间戳</span>
  <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">extractTimestamp</span><span class="tok-o">(</span><span class="tok-n">r</span><span class="tok-k">:</span> <span class="tok-kt">SensorReading</span><span class="tok-o">)</span><span class="tok-k">:</span> <span class="tok-kt">Long</span> <span class="tok-o">=</span> <span class="tok-n">r</span><span class="tok-o">.</span><span class="tok-n">timestamp</span>
<span class="tok-o">}</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>E(10), W(0), E(8), E(7), E(11), W(1), ...</pre>
</div>
</div>
<div class="paragraph">
<p><strong>Assigner with punctuated watermarks</strong></p>
</div>
<div class="paragraph">
<p>直接上代码，只给sensor_1的传感器的数据流插入水印</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">class</span> <span class="tok-nc">PunctuatedAssigner</span> <span class="tok-k">extends</span> <span class="tok-nc">AssignerWithPunctuatedWatermarks</span><span class="tok-o">[</span><span class="tok-kt">SensorReading</span><span class="tok-o">]</span> <span class="tok-o">{</span>
  <span class="tok-k">val</span> <span class="tok-n">bound</span><span class="tok-k">:</span> <span class="tok-kt">Long</span> <span class="tok-o">=</span> <span class="tok-mi">60</span> <span class="tok-o">*</span> <span class="tok-mi">1000</span>

  <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">checkAndGetNextWatermark</span><span class="tok-o">(</span><span class="tok-n">r</span><span class="tok-k">:</span> <span class="tok-kt">SensorReading</span><span class="tok-o">,</span> <span class="tok-n">extractedTS</span><span class="tok-k">:</span> <span class="tok-kt">Long</span><span class="tok-o">)</span><span class="tok-k">:</span> <span class="tok-kt">Watermark</span> <span class="tok-o">=</span> <span class="tok-o">{</span>
    <span class="tok-k">if</span> <span class="tok-o">(</span><span class="tok-n">r</span><span class="tok-o">.</span><span class="tok-n">id</span> <span class="tok-o">==</span> <span class="tok-s">&quot;sensor_1&quot;</span><span class="tok-o">)</span> <span class="tok-o">{</span>
      <span class="tok-k">new</span> <span class="tok-nc">Watermark</span><span class="tok-o">(</span><span class="tok-n">extractedTS</span> <span class="tok-o">-</span> <span class="tok-n">bound</span><span class="tok-o">)</span>
    <span class="tok-o">}</span> <span class="tok-k">else</span> <span class="tok-o">{</span>
      <span class="tok-kc">null</span>
    <span class="tok-o">}</span>
  <span class="tok-o">}</span>

  <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">extractTimestamp</span><span class="tok-o">(</span><span class="tok-n">r</span><span class="tok-k">:</span> <span class="tok-kt">SensorReading</span><span class="tok-o">,</span> <span class="tok-n">previousTS</span><span class="tok-k">:</span> <span class="tok-kt">Long</span><span class="tok-o">)</span><span class="tok-k">:</span> <span class="tok-kt">Long</span> <span class="tok-o">=</span> <span class="tok-o">{</span>
    <span class="tok-n">r</span><span class="tok-o">.</span><span class="tok-n">timestamp</span>
  <span class="tok-o">}</span>
<span class="tok-o">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在Flink中，水印由应用程序开发人员生成，这通常需要对相应的领域有一定的了解。完美的水印永远不会错：时间戳小于水印标记时间的事件不会再出现。在特殊情况下(例如非乱序事件流)，最近一次事件的时间戳就可能是完美的水印。启发式水印则相反，它只估计时间，因此有可能出错，即迟到的事件(其时间戳小于水印标记时间)晚于水印出现。针对启发式水印，Flink提供了处理迟到元素的机制。</p>
</div>
<div class="paragraph">
<p>设定水印通常需要用到领域知识。举例来说，如果知道事件的迟到时间不会超过5秒，就可以将水印标记时间设为收到的最大时间戳减去5秒。另一种做法是，采用一个Flink作业监控事件流，学习事件的迟到规律，并以此构建水印生成模型。</p>
</div>
<div class="paragraph">
<p>如果水印迟到得太久，收到结果的速度可能就会很慢，解决办法是在水印到达之前输出近似结果(Flink可以实现)。如果水印到达得太早，则可能收到错误结果，不过Flink处理迟到数据的机制可以解决这个问题。上述问题看起来很复杂，但是恰恰符合现实世界的规律——大部分真实的事件流都是乱序的，并且通常无法了解它们的乱序程度(因为理论上不能预见未来)。水印是唯一让我们直面乱序事件流并保证正确性的机制; 否则只能选择忽视事实，假装错误的结果是正确的。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_process_functionlow_level_api">8.2. Process Function(Low-Level API)</h3>
<div class="paragraph">
<p>我们之前学习的转换算子是无法访问事件的时间戳信息和水印信息的。而这在一些应用场景下，极为重要。例如MapFunction这样的map转换算子就无法访问时间戳或者当前事件的事件时间。</p>
</div>
<div class="paragraph">
<p>基于此，DataStream API提供了一系列的Low-Level转换算子。可以访问时间戳、水印以及注册定时事件。还可以输出特定的一些事件，例如超时事件等。Process Function用来构建事件驱动的应用以及实现自定义的业务逻辑(使用之前的window函数和转换算子无法实现)。例如，Flink-SQL就是使用Process Function实现的。</p>
</div>
<div class="paragraph">
<p>Flink提供了8个Process Function：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>ProcessFunction</p>
</li>
<li>
<p>KeyedProcessFunction</p>
</li>
<li>
<p>CoProcessFunction</p>
</li>
<li>
<p>ProcessJoinFunction</p>
</li>
<li>
<p>BroadcastProcessFunction</p>
</li>
<li>
<p>KeyedBroadcastProcessFunction</p>
</li>
<li>
<p>ProcessWindowFunction</p>
</li>
<li>
<p>ProcessAllWindowFunction</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>重点介绍KeyedProcessFunction</p>
</div>
<div class="paragraph">
<p>KeyedProcessFunction用来操作KeyedStream。KeyedProcessFunction会处理流的每一个元素，输出为0个、1个或者多个元素。所有的Process Function都继承自RichFunction接口，所以都有open()、close()和getRuntimeContext()等方法。而KeyedProcessFunction[KEY, IN, OUT]还额外提供了两个方法:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>processElement(v: IN, ctx: Context, out: Collector[OUT]), 流中的每一个元素都会调用这个方法，调用结果将会放在Collector数据类型中输出。Context可以访问元素的时间戳，元素的key，以及TimerService时间服务。Context还可以将结果输出到别的流(side outputs)。</p>
</li>
<li>
<p>onTimer(timestamp: Long, ctx: OnTimerContext, out: Collector[OUT])是一个回调函数。当之前注册的定时器触发时调用。参数timestamp为定时器所设定的触发的时间戳。Collector为输出结果的集合。OnTimerContext和processElement的Context参数一样，提供了上下文的一些信息，例如firing trigger的时间信息(事件时间或者处理时间)。</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_timerservice_and_timers">8.2.1. TimerService and Timers</h4>
<div class="paragraph">
<p>Context和OnTimerContext所持有的TimerService对象拥有以下方法:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>currentProcessingTime(): Long 返回当前处理时间</p>
</li>
<li>
<p>currentWatermark(): Long 返回当前水印的时间戳</p>
</li>
<li>
<p>registerProcessingTimeTimer(timestamp: Long): Unit 会注册当前key的processing time的timer。当processing time到达定时时间时，触发timer。</p>
</li>
<li>
<p>registerEventTimeTimer(timestamp: Long): Unit 会注册当前key的event time timer。当水印大于等于定时器注册的时间时，触发定时器执行回调函数。</p>
</li>
<li>
<p>deleteProcessingTimeTimer(timestamp: Long): Unit 删除之前注册处理时间定时器。如果没有这个时间戳的定时器，则不执行。</p>
</li>
<li>
<p>deleteEventTimeTimer(timestamp: Long): Unit 删除之前注册的事件时间定时器，如果没有此时间戳的定时器，则不执行。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>当定时器timer触发时，执行回调函数onTimer()。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
定时器timer只能在keyed streams上面使用。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>举个例子说明KeyedProcessFunction如何操作KeyedStream。</p>
</div>
<div class="paragraph">
<p>需求：监控温度传感器的温度值，如果温度值在一秒钟之内(processing time)连续上升，报警。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">val</span> <span class="tok-n">warnings</span> <span class="tok-k">=</span> <span class="tok-n">readings</span>
  <span class="tok-c1">// key by sensor id</span>
  <span class="tok-o">.</span><span class="tok-n">keyBy</span><span class="tok-o">(</span><span class="tok-k">_</span><span class="tok-o">.</span><span class="tok-n">id</span><span class="tok-o">)</span>
  <span class="tok-c1">// apply ProcessFunction to monitor temperatures</span>
  <span class="tok-o">.</span><span class="tok-n">process</span><span class="tok-o">(</span><span class="tok-k">new</span> <span class="tok-nc">TempIncreaseAlertFunction</span><span class="tok-o">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>看一下TempIncreaseAlertFunction如何实现, 程序中使用了ValueState这样一个状态变量, 后面会详细讲解。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">class</span> <span class="tok-nc">TempIncreaseAlertFunction</span> <span class="tok-k">extends</span> <span class="tok-nc">KeyedProcessFunction</span><span class="tok-o">[</span><span class="tok-kt">String</span>, <span class="tok-kt">SensorReading</span>, <span class="tok-kt">String</span><span class="tok-o">]</span> <span class="tok-o">{</span>
  <span class="tok-c1">// 保存上一个传感器温度值</span>
  <span class="tok-k">lazy</span> <span class="tok-k">val</span> <span class="tok-n">lastTemp</span><span class="tok-k">:</span> <span class="tok-kt">ValueState</span><span class="tok-o">[</span><span class="tok-kt">Double</span><span class="tok-o">]</span> <span class="tok-k">=</span> <span class="tok-n">getRuntimeContext</span><span class="tok-o">.</span><span class="tok-n">getState</span><span class="tok-o">(</span>
    <span class="tok-k">new</span> <span class="tok-nc">ValueStateDescriptor</span><span class="tok-o">[</span><span class="tok-kt">Double</span><span class="tok-o">](</span><span class="tok-s">&quot;lastTemp&quot;</span><span class="tok-o">,</span> <span class="tok-nc">Types</span><span class="tok-o">.</span><span class="tok-n">of</span><span class="tok-o">[</span><span class="tok-kt">Double</span><span class="tok-o">])</span>
  <span class="tok-o">)</span>

  <span class="tok-c1">// 保存注册的定时器的时间戳</span>
  <span class="tok-k">lazy</span> <span class="tok-k">val</span> <span class="tok-n">currentTimer</span><span class="tok-k">:</span> <span class="tok-kt">ValueState</span><span class="tok-o">[</span><span class="tok-kt">Long</span><span class="tok-o">]</span> <span class="tok-k">=</span> <span class="tok-n">getRuntimeContext</span><span class="tok-o">.</span><span class="tok-n">getState</span><span class="tok-o">(</span>
    <span class="tok-k">new</span> <span class="tok-nc">ValueStateDescriptor</span><span class="tok-o">[</span><span class="tok-kt">Long</span><span class="tok-o">](</span><span class="tok-s">&quot;timer&quot;</span><span class="tok-o">,</span> <span class="tok-nc">Types</span><span class="tok-o">.</span><span class="tok-n">of</span><span class="tok-o">[</span><span class="tok-kt">Long</span><span class="tok-o">])</span>
  <span class="tok-o">)</span>

  <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">processElement</span><span class="tok-o">(</span><span class="tok-n">r</span><span class="tok-k">:</span> <span class="tok-kt">SensorReading</span><span class="tok-o">,</span>
                              <span class="tok-n">ctx</span><span class="tok-k">:</span> <span class="tok-kt">KeyedProcessFunction</span><span class="tok-o">[</span><span class="tok-kt">String</span>, <span class="tok-kt">SensorReading</span>, <span class="tok-kt">String</span><span class="tok-o">]</span><span class="tok-k">#</span><span class="tok-nc">Context</span><span class="tok-o">,</span>
                              <span class="tok-n">out</span><span class="tok-k">:</span> <span class="tok-kt">Collector</span><span class="tok-o">[</span><span class="tok-kt">String</span><span class="tok-o">])</span><span class="tok-k">:</span> <span class="tok-kt">Unit</span> <span class="tok-o">=</span> <span class="tok-o">{</span>
    <span class="tok-c1">// get previous temperature</span>
    <span class="tok-c1">// 取出上一次的温度</span>
    <span class="tok-k">val</span> <span class="tok-n">prevTemp</span> <span class="tok-k">=</span> <span class="tok-n">lastTemp</span><span class="tok-o">.</span><span class="tok-n">value</span><span class="tok-o">()</span>
    <span class="tok-c1">// update last temperature</span>
    <span class="tok-c1">// 将当前温度更新到上一次的温度这个变量中</span>
    <span class="tok-n">lastTemp</span><span class="tok-o">.</span><span class="tok-n">update</span><span class="tok-o">(</span><span class="tok-n">r</span><span class="tok-o">.</span><span class="tok-n">temperature</span><span class="tok-o">)</span>

    <span class="tok-k">val</span> <span class="tok-n">curTimerTimestamp</span> <span class="tok-k">=</span> <span class="tok-n">currentTimer</span><span class="tok-o">.</span><span class="tok-n">value</span><span class="tok-o">()</span>
    <span class="tok-k">if</span> <span class="tok-o">(</span><span class="tok-n">prevTemp</span> <span class="tok-o">==</span> <span class="tok-mf">0.0</span> <span class="tok-o">||</span> <span class="tok-n">r</span><span class="tok-o">.</span><span class="tok-n">temperature</span> <span class="tok-o">&lt;</span> <span class="tok-n">prevTemp</span><span class="tok-o">)</span> <span class="tok-o">{</span>
      <span class="tok-c1">// temperature decreased; delete current timer</span>
      <span class="tok-c1">// 温度下降或者是第一个温度值，删除定时器</span>
      <span class="tok-n">ctx</span><span class="tok-o">.</span><span class="tok-n">timerService</span><span class="tok-o">().</span><span class="tok-n">deleteProcessingTimeTimer</span><span class="tok-o">(</span><span class="tok-n">curTimerTimestamp</span><span class="tok-o">)</span>
      <span class="tok-c1">// 清空状态变量</span>
      <span class="tok-n">currentTimer</span><span class="tok-o">.</span><span class="tok-n">clear</span><span class="tok-o">()</span>
    <span class="tok-o">}</span> <span class="tok-k">else</span> <span class="tok-k">if</span> <span class="tok-o">(</span><span class="tok-n">r</span><span class="tok-o">.</span><span class="tok-n">temperature</span> <span class="tok-o">&gt;</span> <span class="tok-n">prevTemp</span> <span class="tok-o">&amp;&amp;</span> <span class="tok-n">curTimerTimestamp</span> <span class="tok-o">==</span> <span class="tok-mi">0</span><span class="tok-o">)</span> <span class="tok-o">{</span>
      <span class="tok-c1">// temperature increased and we have not set a timer yet</span>
      <span class="tok-c1">// set processing time timer for now + 1 second</span>
      <span class="tok-c1">// 温度上升且我们并没有设置定时器</span>
      <span class="tok-k">val</span> <span class="tok-n">timerTs</span> <span class="tok-k">=</span> <span class="tok-n">ctx</span><span class="tok-o">.</span><span class="tok-n">timerService</span><span class="tok-o">().</span><span class="tok-n">currentProcessingTime</span><span class="tok-o">()</span> <span class="tok-o">+</span> <span class="tok-mi">1000</span>
      <span class="tok-n">ctx</span><span class="tok-o">.</span><span class="tok-n">timerService</span><span class="tok-o">().</span><span class="tok-n">registerProcessingTimeTimer</span><span class="tok-o">(</span><span class="tok-n">timerTs</span><span class="tok-o">)</span>
      <span class="tok-c1">// remember current timer</span>
      <span class="tok-n">currentTimer</span><span class="tok-o">.</span><span class="tok-n">update</span><span class="tok-o">(</span><span class="tok-n">timerTs</span><span class="tok-o">)</span>
    <span class="tok-o">}</span>
  <span class="tok-o">}</span>

  <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">onTimer</span><span class="tok-o">(</span><span class="tok-n">ts</span><span class="tok-k">:</span> <span class="tok-kt">Long</span><span class="tok-o">,</span>
                       <span class="tok-n">ctx</span><span class="tok-k">:</span> <span class="tok-kt">KeyedProcessFunction</span><span class="tok-o">[</span><span class="tok-kt">String</span>, <span class="tok-kt">SensorReading</span>, <span class="tok-kt">String</span><span class="tok-o">]</span><span class="tok-k">#</span><span class="tok-nc">OnTimerContext</span><span class="tok-o">,</span>
                       <span class="tok-n">out</span><span class="tok-k">:</span> <span class="tok-kt">Collector</span><span class="tok-o">[</span><span class="tok-kt">String</span><span class="tok-o">])</span><span class="tok-k">:</span> <span class="tok-kt">Unit</span> <span class="tok-o">=</span> <span class="tok-o">{</span>
    <span class="tok-n">out</span><span class="tok-o">.</span><span class="tok-n">collect</span><span class="tok-o">(</span><span class="tok-s">&quot;传感器id为: &quot;</span> <span class="tok-o">+</span> <span class="tok-n">ctx</span><span class="tok-o">.</span><span class="tok-n">getCurrentKey</span> <span class="tok-o">+</span> <span class="tok-s">&quot;的传感器温度值已经连续1s上升了。&quot;</span><span class="tok-o">)</span>
    <span class="tok-n">currentTimer</span><span class="tok-o">.</span><span class="tok-n">clear</span><span class="tok-o">()</span>
  <span class="tok-o">}</span>
<span class="tok-o">}</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_emitting_to_side_outputs侧输出">8.2.2. Emitting to Side Outputs(侧输出)</h4>
<div class="paragraph">
<p>大部分的DataStream API的算子的输出是单一输出，也就是某种数据类型的流。除了split算子，可以将一条流分成多条流，这些流的数据类型也都相同。process function的side outputs功能可以产生多条流，并且这些流的数据类型可以不一样。一个side output可以定义为OutputTag[X]对象，X是输出流的数据类型。process function可以通过Context对象发射一个事件到一个或者多个side outputs。</p>
</div>
<div class="paragraph">
<p>例子</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">val</span> <span class="tok-n">monitoredReadings</span><span class="tok-k">:</span> <span class="tok-kt">DataStream</span><span class="tok-o">[</span><span class="tok-kt">SensorReading</span><span class="tok-o">]</span> <span class="tok-k">=</span> <span class="tok-n">readings</span>
  <span class="tok-o">.</span><span class="tok-n">process</span><span class="tok-o">(</span><span class="tok-k">new</span> <span class="tok-nc">FreezingMonitor</span><span class="tok-o">)</span>

<span class="tok-n">monitoredReadings</span>
  <span class="tok-o">.</span><span class="tok-n">getSideOutput</span><span class="tok-o">(</span><span class="tok-k">new</span> <span class="tok-nc">OutputTag</span><span class="tok-o">[</span><span class="tok-kt">String</span><span class="tok-o">](</span><span class="tok-s">&quot;freezing-alarms&quot;</span><span class="tok-o">))</span>
  <span class="tok-o">.</span><span class="tok-n">print</span><span class="tok-o">()</span>

<span class="tok-n">readings</span><span class="tok-o">.</span><span class="tok-n">print</span><span class="tok-o">()</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>接下来我们实现FreezingMonitor函数，用来监控传感器温度值，将温度值低于32F的温度输出到side output。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">class</span> <span class="tok-nc">FreezingMonitor</span> <span class="tok-k">extends</span> <span class="tok-nc">ProcessFunction</span><span class="tok-o">[</span><span class="tok-kt">SensorReading</span>, <span class="tok-kt">SensorReading</span><span class="tok-o">]</span> <span class="tok-o">{</span>
  <span class="tok-c1">// define a side output tag</span>
  <span class="tok-c1">// 定义一个侧输出标签</span>
  <span class="tok-k">lazy</span> <span class="tok-k">val</span> <span class="tok-n">freezingAlarmOutput</span><span class="tok-k">:</span> <span class="tok-kt">OutputTag</span><span class="tok-o">[</span><span class="tok-kt">String</span><span class="tok-o">]</span> <span class="tok-k">=</span>
    <span class="tok-k">new</span> <span class="tok-nc">OutputTag</span><span class="tok-o">[</span><span class="tok-kt">String</span><span class="tok-o">](</span><span class="tok-s">&quot;freezing-alarms&quot;</span><span class="tok-o">)</span>

  <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">processElement</span><span class="tok-o">(</span><span class="tok-n">r</span><span class="tok-k">:</span> <span class="tok-kt">SensorReading</span><span class="tok-o">,</span>
                              <span class="tok-n">ctx</span><span class="tok-k">:</span> <span class="tok-kt">ProcessFunction</span><span class="tok-o">[</span><span class="tok-kt">SensorReading</span>, <span class="tok-kt">SensorReading</span><span class="tok-o">]</span><span class="tok-k">#</span><span class="tok-nc">Context</span><span class="tok-o">,</span>
                              <span class="tok-n">out</span><span class="tok-k">:</span> <span class="tok-kt">Collector</span><span class="tok-o">[</span><span class="tok-kt">SensorReading</span><span class="tok-o">])</span><span class="tok-k">:</span> <span class="tok-kt">Unit</span> <span class="tok-o">=</span> <span class="tok-o">{</span>
    <span class="tok-c1">// emit freezing alarm if temperature is below 32F</span>
    <span class="tok-k">if</span> <span class="tok-o">(</span><span class="tok-n">r</span><span class="tok-o">.</span><span class="tok-n">temperature</span> <span class="tok-o">&lt;</span> <span class="tok-mf">32.0</span><span class="tok-o">)</span> <span class="tok-o">{</span>
      <span class="tok-n">ctx</span><span class="tok-o">.</span><span class="tok-n">output</span><span class="tok-o">(</span><span class="tok-n">freezingAlarmOutput</span><span class="tok-o">,</span> <span class="tok-s">s&quot;Freezing Alarm for </span><span class="tok-si">${</span><span class="tok-n">r</span><span class="tok-o">.</span><span class="tok-n">id</span><span class="tok-si">}</span><span class="tok-s">&quot;</span><span class="tok-o">)</span>
    <span class="tok-o">}</span>
    <span class="tok-c1">// forward all readings to the regular output</span>
    <span class="tok-n">out</span><span class="tok-o">.</span><span class="tok-n">collect</span><span class="tok-o">(</span><span class="tok-n">r</span><span class="tok-o">)</span>
  <span class="tok-o">}</span>
<span class="tok-o">}</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_coprocessfunction">8.2.3. CoProcessFunction</h4>
<div class="paragraph">
<p>对于两条输入流，DataStream API提供了CoProcessFunction这样的low-level操作。CoProcessFunction提供了操作每一个输入流的方法: processElement1()和processElement2()。类似于ProcessFunction，这两种方法都通过Context对象来调用。这个Context对象可以访问事件数据，定时器时间戳，TimerService，以及side outputs。CoProcessFunction也提供了onTimer()回调函数。下面的例子展示了如何使用CoProcessFunction来合并两条流。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-c1">// ingest sensor stream</span>
<span class="tok-k">val</span> <span class="tok-n">readings</span><span class="tok-k">:</span> <span class="tok-kt">DataStream</span><span class="tok-o">[</span><span class="tok-kt">SensorReading</span><span class="tok-o">]</span> <span class="tok-k">=</span> <span class="tok-o">...</span>

<span class="tok-c1">// filter switches enable forwarding of readings</span>
<span class="tok-k">val</span> <span class="tok-n">filterSwitches</span><span class="tok-k">:</span> <span class="tok-kt">DataStream</span><span class="tok-o">[(</span><span class="tok-kt">String</span>, <span class="tok-kt">Long</span><span class="tok-o">)]</span> <span class="tok-k">=</span> <span class="tok-n">env</span>
  <span class="tok-o">.</span><span class="tok-n">fromCollection</span><span class="tok-o">(</span><span class="tok-nc">Seq</span><span class="tok-o">(</span>
    <span class="tok-o">(</span><span class="tok-s">&quot;sensor_2&quot;</span><span class="tok-o">,</span> <span class="tok-mi">10</span> <span class="tok-o">*</span> <span class="tok-mi">1000L</span><span class="tok-o">),</span>
    <span class="tok-o">(</span><span class="tok-s">&quot;sensor_7&quot;</span><span class="tok-o">,</span> <span class="tok-mi">60</span> <span class="tok-o">*</span> <span class="tok-mi">1000L</span><span class="tok-o">)</span>
  <span class="tok-o">))</span>

<span class="tok-k">val</span> <span class="tok-n">forwardedReadings</span> <span class="tok-k">=</span> <span class="tok-n">readings</span>
  <span class="tok-c1">// connect readings and switches</span>
  <span class="tok-o">.</span><span class="tok-n">connect</span><span class="tok-o">(</span><span class="tok-n">filterSwitches</span><span class="tok-o">)</span>
  <span class="tok-c1">// key by sensor ids</span>
  <span class="tok-o">.</span><span class="tok-n">keyBy</span><span class="tok-o">(</span><span class="tok-k">_</span><span class="tok-o">.</span><span class="tok-n">id</span><span class="tok-o">,</span> <span class="tok-k">_</span><span class="tok-o">.</span><span class="tok-n">_1</span><span class="tok-o">)</span>
  <span class="tok-c1">// apply filtering CoProcessFunction</span>
  <span class="tok-o">.</span><span class="tok-n">process</span><span class="tok-o">(</span><span class="tok-k">new</span> <span class="tok-nc">ReadingFilter</span><span class="tok-o">)</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">class</span> <span class="tok-nc">ReadingFilter</span> <span class="tok-k">extends</span> <span class="tok-nc">CoProcessFunction</span><span class="tok-o">[</span><span class="tok-kt">SensorReading</span>, <span class="tok-o">(</span><span class="tok-kt">String</span>, <span class="tok-kt">Long</span><span class="tok-o">)</span>, <span class="tok-kt">SensorReading</span><span class="tok-o">]</span> <span class="tok-o">{</span>
  <span class="tok-c1">// switch to enable forwarding</span>
  <span class="tok-c1">// 传送数据的开关</span>
  <span class="tok-k">lazy</span> <span class="tok-k">val</span> <span class="tok-n">forwardingEnabled</span><span class="tok-k">:</span> <span class="tok-kt">ValueState</span><span class="tok-o">[</span><span class="tok-kt">Boolean</span><span class="tok-o">]</span> <span class="tok-k">=</span> <span class="tok-n">getRuntimeContext</span><span class="tok-o">.</span><span class="tok-n">getState</span><span class="tok-o">(</span>
    <span class="tok-k">new</span> <span class="tok-nc">ValueStateDescriptor</span><span class="tok-o">[</span><span class="tok-kt">Boolean</span><span class="tok-o">](</span><span class="tok-s">&quot;filterSwitch&quot;</span><span class="tok-o">,</span> <span class="tok-nc">Types</span><span class="tok-o">.</span><span class="tok-n">of</span><span class="tok-o">[</span><span class="tok-kt">Boolean</span><span class="tok-o">]))</span>

  <span class="tok-c1">// hold timestamp of currently active disable timer</span>
  <span class="tok-k">lazy</span> <span class="tok-k">val</span> <span class="tok-n">disableTimer</span><span class="tok-k">:</span> <span class="tok-kt">ValueState</span><span class="tok-o">[</span><span class="tok-kt">Long</span><span class="tok-o">]</span> <span class="tok-k">=</span> <span class="tok-n">getRuntimeContext</span><span class="tok-o">.</span><span class="tok-n">getState</span><span class="tok-o">(</span><span class="tok-k">new</span> <span class="tok-nc">ValueStateDescriptor</span><span class="tok-o">[</span><span class="tok-kt">Long</span><span class="tok-o">](</span><span class="tok-s">&quot;timer&quot;</span><span class="tok-o">,</span> <span class="tok-nc">Types</span><span class="tok-o">.</span><span class="tok-n">of</span><span class="tok-o">[</span><span class="tok-kt">Long</span><span class="tok-o">]))</span>

  <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">processElement1</span><span class="tok-o">(</span><span class="tok-n">reading</span><span class="tok-k">:</span> <span class="tok-kt">SensorReading</span><span class="tok-o">,</span>
                               <span class="tok-n">ctx</span><span class="tok-k">:</span> <span class="tok-kt">CoProcessFunction</span><span class="tok-o">[</span><span class="tok-kt">SensorReading</span>, <span class="tok-o">(</span><span class="tok-kt">String</span>, <span class="tok-kt">Long</span><span class="tok-o">)</span>, <span class="tok-kt">SensorReading</span><span class="tok-o">]</span><span class="tok-k">#</span><span class="tok-nc">Context</span><span class="tok-o">,</span>
                               <span class="tok-n">out</span><span class="tok-k">:</span> <span class="tok-kt">Collector</span><span class="tok-o">[</span><span class="tok-kt">SensorReading</span><span class="tok-o">])</span><span class="tok-k">:</span> <span class="tok-kt">Unit</span> <span class="tok-o">=</span> <span class="tok-o">{</span>
    <span class="tok-c1">// check if we may forward the reading</span>
    <span class="tok-c1">// 决定我们是否要将数据继续传下去</span>
    <span class="tok-k">if</span> <span class="tok-o">(</span><span class="tok-n">forwardingEnabled</span><span class="tok-o">.</span><span class="tok-n">value</span><span class="tok-o">())</span> <span class="tok-o">{</span>
      <span class="tok-n">out</span><span class="tok-o">.</span><span class="tok-n">collect</span><span class="tok-o">(</span><span class="tok-n">reading</span><span class="tok-o">)</span>
    <span class="tok-o">}</span>
  <span class="tok-o">}</span>

  <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">processElement2</span><span class="tok-o">(</span><span class="tok-n">switch</span><span class="tok-k">:</span> <span class="tok-o">(</span><span class="tok-kt">String</span><span class="tok-o">,</span> <span class="tok-kt">Long</span><span class="tok-o">),</span>
                               <span class="tok-n">ctx</span><span class="tok-k">:</span> <span class="tok-kt">CoProcessFunction</span><span class="tok-o">[</span><span class="tok-kt">SensorReading</span>, <span class="tok-o">(</span><span class="tok-kt">String</span>, <span class="tok-kt">Long</span><span class="tok-o">)</span>, <span class="tok-kt">SensorReading</span><span class="tok-o">]</span><span class="tok-k">#</span><span class="tok-nc">Context</span><span class="tok-o">,</span>
                               <span class="tok-n">out</span><span class="tok-k">:</span> <span class="tok-kt">Collector</span><span class="tok-o">[</span><span class="tok-kt">SensorReading</span><span class="tok-o">])</span><span class="tok-k">:</span> <span class="tok-kt">Unit</span> <span class="tok-o">=</span> <span class="tok-o">{</span>
    <span class="tok-c1">// enable reading forwarding</span>
    <span class="tok-c1">// 允许继续传输数据</span>
    <span class="tok-n">forwardingEnabled</span><span class="tok-o">.</span><span class="tok-n">update</span><span class="tok-o">(</span><span class="tok-kc">true</span><span class="tok-o">)</span>
    <span class="tok-c1">// set disable forward timer</span>
    <span class="tok-k">val</span> <span class="tok-n">timerTimestamp</span> <span class="tok-k">=</span> <span class="tok-n">ctx</span><span class="tok-o">.</span><span class="tok-n">timerService</span><span class="tok-o">().</span><span class="tok-n">currentProcessingTime</span><span class="tok-o">()</span> <span class="tok-o">+</span> <span class="tok-n">switch</span><span class="tok-o">.</span><span class="tok-n">_2</span>
    <span class="tok-k">val</span> <span class="tok-n">curTimerTimestamp</span> <span class="tok-k">=</span> <span class="tok-n">disableTimer</span><span class="tok-o">.</span><span class="tok-n">value</span><span class="tok-o">()</span>

    <span class="tok-k">if</span> <span class="tok-o">(</span><span class="tok-n">timerTimestamp</span> <span class="tok-o">&gt;</span> <span class="tok-n">curTimerTimestamp</span><span class="tok-o">)</span> <span class="tok-o">{</span>
      <span class="tok-c1">// remove current timer and register new timer</span>
      <span class="tok-n">ctx</span><span class="tok-o">.</span><span class="tok-n">timerService</span><span class="tok-o">().</span><span class="tok-n">deleteProcessingTimeTimer</span><span class="tok-o">(</span><span class="tok-n">curTimerTimestamp</span><span class="tok-o">)</span>
      <span class="tok-n">ctx</span><span class="tok-o">.</span><span class="tok-n">timerService</span><span class="tok-o">().</span><span class="tok-n">registerProcessingTimeTimer</span><span class="tok-o">(</span><span class="tok-n">timerTimestamp</span><span class="tok-o">)</span>
      <span class="tok-n">disableTimer</span><span class="tok-o">.</span><span class="tok-n">update</span><span class="tok-o">(</span><span class="tok-n">timerTimestamp</span><span class="tok-o">)</span>
    <span class="tok-o">}</span>
  <span class="tok-o">}</span>

  <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">onTimer</span><span class="tok-o">(</span><span class="tok-n">ts</span><span class="tok-k">:</span> <span class="tok-kt">Long</span><span class="tok-o">,</span>
                       <span class="tok-n">ctx</span><span class="tok-k">:</span> <span class="tok-kt">CoProcessFunction</span><span class="tok-o">[</span><span class="tok-kt">SensorReading</span>, <span class="tok-o">(</span><span class="tok-kt">String</span>, <span class="tok-kt">Long</span><span class="tok-o">)</span>, <span class="tok-kt">SensorReading</span><span class="tok-o">]</span><span class="tok-k">#</span><span class="tok-nc">OnTimerContext</span><span class="tok-o">,</span>
                       <span class="tok-n">out</span><span class="tok-k">:</span> <span class="tok-kt">Collector</span><span class="tok-o">[</span><span class="tok-kt">SensorReading</span><span class="tok-o">])</span><span class="tok-k">:</span> <span class="tok-kt">Unit</span> <span class="tok-o">=</span> <span class="tok-o">{</span>
     <span class="tok-c1">// remove all state; forward switch will be false by default</span>
     <span class="tok-n">forwardingEnabled</span><span class="tok-o">.</span><span class="tok-n">clear</span><span class="tok-o">()</span>
     <span class="tok-n">disableTimer</span><span class="tok-o">.</span><span class="tok-n">clear</span><span class="tok-o">()</span>
  <span class="tok-o">}</span>
<span class="tok-o">}</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_window_operators窗口操作符">8.3. Window Operators(窗口操作符)</h3>
<div class="sect3">
<h4 id="_define_window_operators定义窗口操作符">8.3.1. define window operators(定义窗口操作符)</h4>
<div class="paragraph">
<p>window算子可以在keyed stream或者nokeyed stream上面使用。</p>
</div>
<div class="paragraph">
<p>创建一个window算子，需要指定两个部分：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>window assigner定义了流的元素如何分配到window中。window assigner将会产生一条WindowedStream(或者AllWindowedStream，如果是nonkeyed DataStream的话)</p>
</li>
<li>
<p>window function用来处理WindowedStream(AllWindowedStream)中的元素。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-n">stream</span>
  <span class="tok-o">.</span><span class="tok-n">keyBy</span><span class="tok-o">(...)</span>
  <span class="tok-o">.</span><span class="tok-n">window</span><span class="tok-o">(...)</span>  <span class="tok-c1">// 指定window assigner</span>
  <span class="tok-o">.</span><span class="tok-n">reduce</span><span class="tok-o">/</span><span class="tok-n">aggregate</span><span class="tok-o">/</span><span class="tok-n">process</span><span class="tok-o">(...)</span> <span class="tok-c1">// 指定window function</span>

<span class="tok-n">stream</span>
  <span class="tok-o">.</span><span class="tok-n">windowAll</span><span class="tok-o">(...)</span> <span class="tok-c1">// 指定window assigner</span>
  <span class="tok-o">.</span><span class="tok-n">reduce</span><span class="tok-o">/</span><span class="tok-n">aggregate</span><span class="tok-o">/</span><span class="tok-n">process</span><span class="tok-o">(...)</span> <span class="tok-c1">// 指定window function</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_内置的window_assigner窗口分配器">8.3.2. 内置的window assigner(窗口分配器)</h4>
<div class="sect4">
<h5 id="_tumbling_windows滚动窗口">tumbling windows(滚动窗口)</h5>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">val</span> <span class="tok-n">sensorData</span><span class="tok-k">:</span> <span class="tok-kt">DataStream</span><span class="tok-o">[</span><span class="tok-kt">SensorReading</span><span class="tok-o">]</span> <span class="tok-k">=</span> <span class="tok-o">...</span>

<span class="tok-k">val</span> <span class="tok-n">avgTemp</span> <span class="tok-k">=</span> <span class="tok-n">sensorData</span>
  <span class="tok-o">.</span><span class="tok-n">keyBy</span><span class="tok-o">(</span><span class="tok-k">_</span><span class="tok-o">.</span><span class="tok-n">id</span><span class="tok-o">)</span>
  <span class="tok-c1">// group readings in 1s event-time windows</span>
  <span class="tok-o">.</span><span class="tok-n">window</span><span class="tok-o">(</span><span class="tok-nc">TumblingEventTimeWindows</span><span class="tok-o">.</span><span class="tok-n">of</span><span class="tok-o">(</span><span class="tok-nc">Time</span><span class="tok-o">.</span><span class="tok-n">seconds</span><span class="tok-o">(</span><span class="tok-mi">1</span><span class="tok-o">)))</span>
  <span class="tok-o">.</span><span class="tok-n">process</span><span class="tok-o">(</span><span class="tok-k">new</span> <span class="tok-nc">TemperatureAverager</span><span class="tok-o">)</span>

<span class="tok-k">val</span> <span class="tok-n">avgTemp</span> <span class="tok-k">=</span> <span class="tok-n">sensorData</span>
  <span class="tok-o">.</span><span class="tok-n">keyBy</span><span class="tok-o">(</span><span class="tok-k">_</span><span class="tok-o">.</span><span class="tok-n">id</span><span class="tok-o">)</span>
  <span class="tok-c1">// group readings in 1s processing-time windows</span>
  <span class="tok-o">.</span><span class="tok-n">window</span><span class="tok-o">(</span><span class="tok-nc">TumblingProcessingTimeWindows</span><span class="tok-o">.</span><span class="tok-n">of</span><span class="tok-o">(</span><span class="tok-nc">Time</span><span class="tok-o">.</span><span class="tok-n">seconds</span><span class="tok-o">(</span><span class="tok-mi">1</span><span class="tok-o">)))</span>
  <span class="tok-o">.</span><span class="tok-n">process</span><span class="tok-o">(</span><span class="tok-k">new</span> <span class="tok-nc">TemperatureAverager</span><span class="tok-o">)</span>

<span class="tok-c1">// 其实就是之前的</span>
<span class="tok-c1">// shortcut for window.(TumblingEventTimeWindows.of(size))</span>
<span class="tok-k">val</span> <span class="tok-n">avgTemp</span> <span class="tok-k">=</span> <span class="tok-n">sensorData</span>
  <span class="tok-o">.</span><span class="tok-n">keyBy</span><span class="tok-o">(</span><span class="tok-k">_</span><span class="tok-o">.</span><span class="tok-n">id</span><span class="tok-o">)</span>
  <span class="tok-o">.</span><span class="tok-n">timeWindow</span><span class="tok-o">(</span><span class="tok-nc">Time</span><span class="tok-o">.</span><span class="tok-n">seconds</span><span class="tok-o">(</span><span class="tok-mi">1</span><span class="tok-o">))</span>
  <span class="tok-o">.</span><span class="tok-n">process</span><span class="tok-o">(</span><span class="tok-k">new</span> <span class="tok-nc">TemperatureAverager</span><span class="tok-o">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果滚动窗口的时间长度为1小时，那么默认设定的窗口为：[00:00, 01:00), [01:00, 02:00), &#8230;&#8203;</p>
</div>
</div>
<div class="sect4">
<h5 id="_sliding_window滑动窗口">sliding window(滑动窗口)</h5>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">val</span> <span class="tok-n">slidingAvgTemp</span> <span class="tok-k">=</span> <span class="tok-n">sensorData</span>
  <span class="tok-o">.</span><span class="tok-n">keyBy</span><span class="tok-o">(</span><span class="tok-k">_</span><span class="tok-o">.</span><span class="tok-n">id</span><span class="tok-o">)</span>
  <span class="tok-o">.</span><span class="tok-n">window</span><span class="tok-o">(</span><span class="tok-nc">SlidingEventTimeWindows</span><span class="tok-o">.</span><span class="tok-n">of</span><span class="tok-o">(</span><span class="tok-nc">Time</span><span class="tok-o">.</span><span class="tok-n">hours</span><span class="tok-o">(</span><span class="tok-mi">1</span><span class="tok-o">),</span> <span class="tok-nc">Time</span><span class="tok-o">.</span><span class="tok-n">minutes</span><span class="tok-o">(</span><span class="tok-mi">15</span><span class="tok-o">)))</span>
  <span class="tok-o">.</span><span class="tok-n">process</span><span class="tok-o">(</span><span class="tok-k">new</span> <span class="tok-nc">TemperatureAverager</span><span class="tok-o">)</span>

<span class="tok-k">val</span> <span class="tok-n">slidingAvgTemp</span> <span class="tok-k">=</span> <span class="tok-n">sensorData</span>
  <span class="tok-o">.</span><span class="tok-n">keyBy</span><span class="tok-o">(</span><span class="tok-k">_</span><span class="tok-o">.</span><span class="tok-n">id</span><span class="tok-o">)</span>
  <span class="tok-o">.</span><span class="tok-n">window</span><span class="tok-o">(</span><span class="tok-nc">SlidingProcessingTimeWindows</span><span class="tok-o">.</span><span class="tok-n">of</span><span class="tok-o">(</span><span class="tok-nc">Time</span><span class="tok-o">.</span><span class="tok-n">hours</span><span class="tok-o">(</span><span class="tok-mi">1</span><span class="tok-o">),</span> <span class="tok-nc">Time</span><span class="tok-o">.</span><span class="tok-n">minutes</span><span class="tok-o">(</span><span class="tok-mi">15</span><span class="tok-o">)))</span>
  <span class="tok-o">.</span><span class="tok-n">process</span><span class="tok-o">(</span><span class="tok-k">new</span> <span class="tok-nc">TemperatureAverager</span><span class="tok-o">)</span>

<span class="tok-k">val</span> <span class="tok-n">slidingAvgTemp</span> <span class="tok-k">=</span> <span class="tok-n">sensorData</span>
  <span class="tok-o">.</span><span class="tok-n">keyBy</span><span class="tok-o">(</span><span class="tok-k">_</span><span class="tok-o">.</span><span class="tok-n">id</span><span class="tok-o">)</span>
  <span class="tok-o">.</span><span class="tok-n">timeWindow</span><span class="tok-o">(</span><span class="tok-nc">Time</span><span class="tok-o">.</span><span class="tok-n">hours</span><span class="tok-o">(</span><span class="tok-mi">1</span><span class="tok-o">),</span> <span class="tok-nc">Time</span><span class="tok-o">.</span><span class="tok-n">minutes</span><span class="tok-o">(</span><span class="tok-mi">15</span><span class="tok-o">))</span>
  <span class="tok-o">.</span><span class="tok-n">process</span><span class="tok-o">(</span><span class="tok-k">new</span> <span class="tok-nc">TemperatureAverager</span><span class="tok-o">)</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_session_windows会话窗口">session windows(会话窗口)</h5>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">val</span> <span class="tok-n">sessionWindows</span> <span class="tok-k">=</span> <span class="tok-n">sensorData</span>
  <span class="tok-o">.</span><span class="tok-n">keyBy</span><span class="tok-o">(</span><span class="tok-k">_</span><span class="tok-o">.</span><span class="tok-n">id</span><span class="tok-o">)</span>
  <span class="tok-o">.</span><span class="tok-n">window</span><span class="tok-o">(</span><span class="tok-nc">EventTimeSessionWindows</span><span class="tok-o">.</span><span class="tok-n">withGap</span><span class="tok-o">(</span><span class="tok-nc">Time</span><span class="tok-o">.</span><span class="tok-n">minutes</span><span class="tok-o">(</span><span class="tok-mi">15</span><span class="tok-o">)))</span>
  <span class="tok-o">.</span><span class="tok-n">process</span><span class="tok-o">(...)</span>

<span class="tok-k">val</span> <span class="tok-n">sessionWindows</span> <span class="tok-k">=</span> <span class="tok-n">sensorData</span>
  <span class="tok-o">.</span><span class="tok-n">keyBy</span><span class="tok-o">(</span><span class="tok-k">_</span><span class="tok-o">.</span><span class="tok-n">id</span><span class="tok-o">)</span>
  <span class="tok-o">.</span><span class="tok-n">window</span><span class="tok-o">(</span><span class="tok-nc">ProcessingTimeSessionWindows</span><span class="tok-o">.</span><span class="tok-n">withGap</span><span class="tok-o">(</span><span class="tok-nc">Time</span><span class="tok-o">.</span><span class="tok-n">minutes</span><span class="tok-o">(</span><span class="tok-mi">15</span><span class="tok-o">)))</span>
  <span class="tok-o">.</span><span class="tok-n">process</span><span class="tok-o">(...)</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_applying_functions_on_windows在窗口上应用函数">8.3.3. Applying Functions on Windows(在窗口上应用函数)</h4>
<div class="paragraph">
<p>window functions定义了窗口中数据的计算逻辑。有两种计算逻辑：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>增量聚合函数(Incremental aggregation functions)：当一个事件被添加到窗口时，触发函数计算，并且更新window的状态(单个值)。最终聚合的结果将作为输出。ReduceFunction和AggregateFunction是增量聚合函数。</p>
</li>
<li>
<p>全窗口函数(Full window functions)：这个函数将会收集窗口中所有的元素，可以做一些复杂计算。ProcessWindowFunction是window function。</p>
</li>
</ol>
</div>
<div class="sect4">
<h5 id="_reducefunction">ReduceFunction</h5>
<div class="paragraph">
<p>例子: 计算每个传感器15s窗口中的温度最小值</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">val</span> <span class="tok-n">minTempPerWindow</span><span class="tok-k">:</span> <span class="tok-kt">DataStream</span><span class="tok-o">[(</span><span class="tok-kt">String</span>, <span class="tok-kt">Double</span><span class="tok-o">)]</span> <span class="tok-k">=</span> <span class="tok-n">sensorData</span>
  <span class="tok-o">.</span><span class="tok-n">map</span><span class="tok-o">(</span><span class="tok-n">r</span> <span class="tok-k">=&gt;</span> <span class="tok-o">(</span><span class="tok-n">r</span><span class="tok-o">.</span><span class="tok-n">id</span><span class="tok-o">,</span> <span class="tok-n">r</span><span class="tok-o">.</span><span class="tok-n">temperature</span><span class="tok-o">))</span>
  <span class="tok-o">.</span><span class="tok-n">keyBy</span><span class="tok-o">(</span><span class="tok-k">_</span><span class="tok-o">.</span><span class="tok-n">_1</span><span class="tok-o">)</span>
  <span class="tok-o">.</span><span class="tok-n">timeWindow</span><span class="tok-o">(</span><span class="tok-nc">Time</span><span class="tok-o">.</span><span class="tok-n">seconds</span><span class="tok-o">(</span><span class="tok-mi">15</span><span class="tok-o">))</span>
  <span class="tok-o">.</span><span class="tok-n">reduce</span><span class="tok-o">((</span><span class="tok-n">r1</span><span class="tok-o">,</span> <span class="tok-n">r2</span><span class="tok-o">)</span> <span class="tok-k">=&gt;</span> <span class="tok-o">(</span><span class="tok-n">r1</span><span class="tok-o">.</span><span class="tok-n">_1</span><span class="tok-o">,</span> <span class="tok-n">r1</span><span class="tok-o">.</span><span class="tok-n">_2</span><span class="tok-o">.</span><span class="tok-n">min</span><span class="tok-o">(</span><span class="tok-n">r2</span><span class="tok-o">.</span><span class="tok-n">_2</span><span class="tok-o">)))</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_aggregatefunction">AggregateFunction</h5>
<div class="paragraph">
<p>先来看接口定义</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="java"><span></span><span class="tok-kd">public</span> <span class="tok-kd">interface</span> <span class="tok-nc">AggregateFunction</span><span class="tok-o">&lt;</span><span class="tok-n">IN</span><span class="tok-o">,</span> <span class="tok-n">ACC</span><span class="tok-o">,</span> <span class="tok-n">OUT</span><span class="tok-o">&gt;</span> <span class="tok-kd">extends</span> <span class="tok-n">Function</span><span class="tok-o">,</span> <span class="tok-n">Serializable</span> <span class="tok-o">{</span>

  <span class="tok-c1">// create a new accumulator to start a new aggregate</span>
  <span class="tok-n">ACC</span> <span class="tok-nf">createAccumulator</span><span class="tok-o">();</span>

  <span class="tok-c1">// add an input element to the accumulator and return the accumulator</span>
  <span class="tok-n">ACC</span> <span class="tok-nf">add</span><span class="tok-o">(</span><span class="tok-n">IN</span> <span class="tok-n">value</span><span class="tok-o">,</span> <span class="tok-n">ACC</span> <span class="tok-n">accumulator</span><span class="tok-o">);</span>

  <span class="tok-c1">// compute the result from the accumulator and return it.</span>
  <span class="tok-n">OUT</span> <span class="tok-nf">getResult</span><span class="tok-o">(</span><span class="tok-n">ACC</span> <span class="tok-n">accumulator</span><span class="tok-o">);</span>

  <span class="tok-c1">// merge two accumulators and return the result.</span>
  <span class="tok-n">ACC</span> <span class="tok-nf">merge</span><span class="tok-o">(</span><span class="tok-n">ACC</span> <span class="tok-n">a</span><span class="tok-o">,</span> <span class="tok-n">ACC</span> <span class="tok-n">b</span><span class="tok-o">);</span>
<span class="tok-o">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>IN是输入元素的类型，ACC是累加器的类型，OUT是输出元素的类型。</p>
</div>
<div class="paragraph">
<p>例子</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">val</span> <span class="tok-n">avgTempPerWindow</span><span class="tok-k">:</span> <span class="tok-kt">DataStream</span><span class="tok-o">[(</span><span class="tok-kt">String</span>, <span class="tok-kt">Double</span><span class="tok-o">)]</span> <span class="tok-k">=</span> <span class="tok-n">sensorData</span>
  <span class="tok-o">.</span><span class="tok-n">map</span><span class="tok-o">(</span><span class="tok-n">r</span> <span class="tok-k">=&gt;</span> <span class="tok-o">(</span><span class="tok-n">r</span><span class="tok-o">.</span><span class="tok-n">id</span><span class="tok-o">,</span> <span class="tok-n">r</span><span class="tok-o">.</span><span class="tok-n">temperature</span><span class="tok-o">))</span>
  <span class="tok-o">.</span><span class="tok-n">keyBy</span><span class="tok-o">(</span><span class="tok-k">_</span><span class="tok-o">.</span><span class="tok-n">_1</span><span class="tok-o">)</span>
  <span class="tok-o">.</span><span class="tok-n">timeWindow</span><span class="tok-o">(</span><span class="tok-nc">Timeseconds</span><span class="tok-o">(</span><span class="tok-mi">15</span><span class="tok-o">))</span>
  <span class="tok-o">.</span><span class="tok-n">aggregate</span><span class="tok-o">(</span><span class="tok-k">new</span> <span class="tok-nc">AvgTempFunction</span><span class="tok-o">)</span>

<span class="tok-c1">// An AggregateFunction to compute the average temperature per sensor.</span>
<span class="tok-c1">// The accumulator holds the sum of temperatures and an event count.</span>
<span class="tok-k">class</span> <span class="tok-nc">AvgTempFunction</span> <span class="tok-k">extends</span> <span class="tok-nc">AggregateFunction</span><span class="tok-o">[(</span><span class="tok-kt">String</span>, <span class="tok-kt">Double</span><span class="tok-o">)</span>, <span class="tok-o">(</span><span class="tok-kt">String</span>, <span class="tok-kt">Double</span>, <span class="tok-kt">Int</span><span class="tok-o">)</span>, <span class="tok-o">(</span><span class="tok-kt">String</span>, <span class="tok-kt">Double</span><span class="tok-o">)]</span> <span class="tok-o">{</span>

  <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">createAccumulator</span><span class="tok-o">()</span> <span class="tok-k">=</span> <span class="tok-o">{</span>
    <span class="tok-o">(</span><span class="tok-s">&quot;&quot;</span><span class="tok-o">,</span> <span class="tok-mf">0.0</span><span class="tok-o">,</span> <span class="tok-mi">0</span><span class="tok-o">)</span>
  <span class="tok-o">}</span>

  <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">add</span><span class="tok-o">(</span><span class="tok-n">in</span><span class="tok-k">:</span> <span class="tok-o">(</span><span class="tok-kt">String</span><span class="tok-o">,</span> <span class="tok-kt">Double</span><span class="tok-o">),</span> <span class="tok-n">acc</span><span class="tok-k">:</span> <span class="tok-o">(</span><span class="tok-kt">String</span><span class="tok-o">,</span> <span class="tok-kt">Double</span><span class="tok-o">,</span> <span class="tok-nc">Int</span><span class="tok-o">))</span> <span class="tok-k">=</span> <span class="tok-o">{</span>
    <span class="tok-o">(</span><span class="tok-n">in</span><span class="tok-o">.</span><span class="tok-n">_1</span><span class="tok-o">,</span> <span class="tok-n">in</span><span class="tok-o">.</span><span class="tok-n">_2</span> <span class="tok-o">+</span> <span class="tok-n">acc</span><span class="tok-o">.</span><span class="tok-n">_2</span><span class="tok-o">,</span> <span class="tok-mi">1</span> <span class="tok-o">+</span> <span class="tok-n">acc</span><span class="tok-o">.</span><span class="tok-n">_3</span><span class="tok-o">)</span>
  <span class="tok-o">}</span>

  <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">getResult</span><span class="tok-o">(</span><span class="tok-n">acc</span><span class="tok-k">:</span> <span class="tok-o">(</span><span class="tok-kt">String</span><span class="tok-o">,</span> <span class="tok-kt">Double</span><span class="tok-o">,</span> <span class="tok-nc">Int</span><span class="tok-o">))</span> <span class="tok-k">=</span> <span class="tok-o">{</span>
    <span class="tok-o">(</span><span class="tok-n">acc</span><span class="tok-o">.</span><span class="tok-n">_1</span><span class="tok-o">,</span> <span class="tok-n">acc</span><span class="tok-o">.</span><span class="tok-n">_2</span> <span class="tok-o">/</span> <span class="tok-n">acc</span><span class="tok-o">.</span><span class="tok-n">_3</span><span class="tok-o">)</span>
  <span class="tok-o">}</span>

  <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">merge</span><span class="tok-o">(</span><span class="tok-n">acc1</span><span class="tok-k">:</span> <span class="tok-o">(</span><span class="tok-kt">String</span><span class="tok-o">,</span> <span class="tok-kt">Double</span><span class="tok-o">,</span> <span class="tok-nc">Int</span><span class="tok-o">),</span> <span class="tok-n">acc2</span><span class="tok-k">:</span> <span class="tok-o">(</span><span class="tok-kt">String</span><span class="tok-o">,</span> <span class="tok-kt">Double</span><span class="tok-o">,</span> <span class="tok-nc">Int</span><span class="tok-o">))</span> <span class="tok-k">=</span> <span class="tok-o">{</span>
    <span class="tok-o">(</span><span class="tok-n">acc1</span><span class="tok-o">.</span><span class="tok-n">_1</span><span class="tok-o">,</span> <span class="tok-n">acc1</span><span class="tok-o">.</span><span class="tok-n">_2</span> <span class="tok-o">+</span> <span class="tok-n">acc2</span><span class="tok-o">.</span><span class="tok-n">_2</span><span class="tok-o">,</span> <span class="tok-n">acc1</span><span class="tok-o">.</span><span class="tok-n">_3</span> <span class="tok-o">+</span> <span class="tok-n">acc2</span><span class="tok-o">.</span><span class="tok-n">_3</span><span class="tok-o">)</span>
  <span class="tok-o">}</span>
<span class="tok-o">}</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_processwindowfunction">ProcessWindowFunction</h5>
<div class="paragraph">
<p>一些业务场景，我们需要收集窗口内所有的数据进行计算，例如计算窗口数据的中位数，或者计算窗口数据中出现频率最高的值。这样的需求，使用ReduceFunction和AggregateFunction就无法实现了。这个时候就需要ProcessWindowFunction了。</p>
</div>
<div class="paragraph">
<p>先来看接口定义</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="java"><span></span><span class="tok-kd">public</span> <span class="tok-kd">abstract</span> <span class="tok-kd">class</span> <span class="tok-nc">ProcessWindowFunction</span><span class="tok-o">&lt;</span><span class="tok-n">IN</span><span class="tok-o">,</span> <span class="tok-n">OUT</span><span class="tok-o">,</span> <span class="tok-n">KEY</span><span class="tok-o">,</span> <span class="tok-n">W</span> <span class="tok-kd">extends</span> <span class="tok-n">Window</span><span class="tok-o">&gt;</span> <span class="tok-kd">extends</span> <span class="tok-n">AbstractRichFunction</span> <span class="tok-o">{</span>

  <span class="tok-c1">// Evaluates the window</span>
  <span class="tok-kt">void</span> <span class="tok-nf">process</span><span class="tok-o">(</span><span class="tok-n">KEY</span> <span class="tok-n">key</span><span class="tok-o">,</span> <span class="tok-n">Context</span> <span class="tok-n">ctx</span><span class="tok-o">,</span> <span class="tok-n">Iterable</span><span class="tok-o">&lt;</span><span class="tok-n">IN</span><span class="tok-o">&gt;</span> <span class="tok-n">vals</span><span class="tok-o">,</span> <span class="tok-n">Collector</span><span class="tok-o">&lt;</span><span class="tok-n">OUT</span><span class="tok-o">&gt;</span> <span class="tok-n">out</span><span class="tok-o">)</span> <span class="tok-kd">throws</span> <span class="tok-n">Exception</span><span class="tok-o">;</span>

  <span class="tok-c1">// Deletes any custom per-window state when the window is purged</span>
  <span class="tok-kd">public</span> <span class="tok-kt">void</span> <span class="tok-nf">clear</span><span class="tok-o">(</span><span class="tok-n">Context</span> <span class="tok-n">ctx</span><span class="tok-o">)</span> <span class="tok-kd">throws</span> <span class="tok-n">Exception</span> <span class="tok-o">{}</span>

  <span class="tok-c1">// The context holding window metadata</span>
  <span class="tok-kd">public</span> <span class="tok-kd">abstract</span> <span class="tok-kd">class</span> <span class="tok-nc">Context</span> <span class="tok-kd">implements</span> <span class="tok-n">Serializable</span> <span class="tok-o">{</span>
    <span class="tok-c1">// Returns the metadata of the window</span>
    <span class="tok-kd">public</span> <span class="tok-kd">abstract</span> <span class="tok-n">W</span> <span class="tok-nf">window</span><span class="tok-o">();</span>

    <span class="tok-c1">// Returns the current processing time</span>
    <span class="tok-kd">public</span> <span class="tok-kd">abstract</span> <span class="tok-kt">long</span> <span class="tok-nf">currentProcessingTime</span><span class="tok-o">();</span>

    <span class="tok-c1">// Returns the current event-time watermark</span>
    <span class="tok-kd">public</span> <span class="tok-kd">abstract</span> <span class="tok-kt">long</span> <span class="tok-nf">currentWatermark</span><span class="tok-o">();</span>

    <span class="tok-c1">// State accessor for per-window state</span>
    <span class="tok-kd">public</span> <span class="tok-kd">abstract</span> <span class="tok-n">KeyedStateStore</span> <span class="tok-nf">windowState</span><span class="tok-o">();</span>

    <span class="tok-c1">// State accessor for per-key global state</span>
    <span class="tok-kd">public</span> <span class="tok-kd">abstract</span> <span class="tok-n">KeyedStateStore</span> <span class="tok-nf">globalState</span><span class="tok-o">();</span>

    <span class="tok-c1">// Emits a record to the side output identified by the OutputTag.</span>
    <span class="tok-kd">public</span> <span class="tok-kd">abstract</span> <span class="tok-o">&lt;</span><span class="tok-n">X</span><span class="tok-o">&gt;</span> <span class="tok-kt">void</span> <span class="tok-nf">output</span><span class="tok-o">(</span><span class="tok-n">OutputTag</span><span class="tok-o">&lt;</span><span class="tok-n">X</span><span class="tok-o">&gt;</span> <span class="tok-n">outputTag</span><span class="tok-o">,</span> <span class="tok-n">X</span> <span class="tok-n">value</span><span class="tok-o">);</span>
  <span class="tok-o">}</span>
<span class="tok-o">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>process()方法接受的参数为：window的key，Iterable迭代器包含窗口的所有元素，Collector用于输出结果流。Context参数和别的process方法一样。而ProcessWindowFunction的Context对象还可以访问window的元数据(窗口开始和结束时间)，当前处理时间和水印，per-window state和per-key global state，side outputs。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>per-window state: 用于保存一些信息，这些信息可以被process()访问，只要process所处理的元素属于这个窗口。</p>
</li>
<li>
<p>per-key global state: 同一个key，也就是在一条KeyedStream上，不同的window可以访问per-key global state保存的值。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>例子：计算5s滚动窗口中的最低和最高的温度。输出的元素包含了(流的Key, 最低温度, 最高温度, 窗口结束时间)。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">val</span> <span class="tok-n">minMaxTempPerWindow</span><span class="tok-k">:</span> <span class="tok-kt">DataStream</span><span class="tok-o">[</span><span class="tok-kt">MinMaxTemp</span><span class="tok-o">]</span> <span class="tok-k">=</span> <span class="tok-n">sensorData</span>
  <span class="tok-o">.</span><span class="tok-n">keyBy</span><span class="tok-o">(</span><span class="tok-k">_</span><span class="tok-o">.</span><span class="tok-n">id</span><span class="tok-o">)</span>
  <span class="tok-o">.</span><span class="tok-n">timeWindow</span><span class="tok-o">(</span><span class="tok-nc">Time</span><span class="tok-o">.</span><span class="tok-n">seconds</span><span class="tok-o">(</span><span class="tok-mi">5</span><span class="tok-o">))</span>
  <span class="tok-o">.</span><span class="tok-n">process</span><span class="tok-o">(</span><span class="tok-k">new</span> <span class="tok-nc">HighAndLowTempProcessFunction</span><span class="tok-o">)</span>

<span class="tok-k">case</span> <span class="tok-k">class</span> <span class="tok-nc">MinMaxTemp</span><span class="tok-o">(</span><span class="tok-n">id</span><span class="tok-k">:</span> <span class="tok-kt">String</span><span class="tok-o">,</span> <span class="tok-n">min</span><span class="tok-k">:</span> <span class="tok-kt">Double</span><span class="tok-o">,</span> <span class="tok-n">max</span><span class="tok-k">:</span> <span class="tok-kt">Double</span><span class="tok-o">,</span> <span class="tok-n">endTs</span><span class="tok-k">:</span> <span class="tok-kt">Long</span><span class="tok-o">)</span>

<span class="tok-k">class</span> <span class="tok-nc">HighAndLowTempProcessFunction</span> <span class="tok-k">extends</span> <span class="tok-nc">ProcessWindowFunction</span><span class="tok-o">[</span><span class="tok-kt">SensorReading</span>, <span class="tok-kt">MinMaxTemp</span>, <span class="tok-kt">String</span>, <span class="tok-kt">TimeWindow</span><span class="tok-o">]</span> <span class="tok-o">{</span>
  <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">process</span><span class="tok-o">(</span><span class="tok-n">key</span><span class="tok-k">:</span> <span class="tok-kt">String</span><span class="tok-o">,</span>
                       <span class="tok-n">ctx</span><span class="tok-k">:</span> <span class="tok-kt">Context</span><span class="tok-o">,</span>
                       <span class="tok-n">vals</span><span class="tok-k">:</span> <span class="tok-kt">Iterable</span><span class="tok-o">[</span><span class="tok-kt">SensorReading</span><span class="tok-o">],</span>
                       <span class="tok-n">out</span><span class="tok-k">:</span> <span class="tok-kt">Collector</span><span class="tok-o">[</span><span class="tok-kt">MinMaxTemp</span><span class="tok-o">])</span><span class="tok-k">:</span> <span class="tok-kt">Unit</span> <span class="tok-o">=</span> <span class="tok-o">{</span>
    <span class="tok-k">val</span> <span class="tok-n">temps</span> <span class="tok-k">=</span> <span class="tok-n">vals</span><span class="tok-o">.</span><span class="tok-n">map</span><span class="tok-o">(</span><span class="tok-k">_</span><span class="tok-o">.</span><span class="tok-n">temperature</span><span class="tok-o">)</span>
    <span class="tok-k">val</span> <span class="tok-n">windowEnd</span> <span class="tok-k">=</span> <span class="tok-n">ctx</span><span class="tok-o">.</span><span class="tok-n">window</span><span class="tok-o">.</span><span class="tok-n">getEnd</span>

    <span class="tok-n">out</span><span class="tok-o">.</span><span class="tok-n">collect</span><span class="tok-o">(</span><span class="tok-nc">MinMaxTemp</span><span class="tok-o">(</span><span class="tok-n">key</span><span class="tok-o">,</span> <span class="tok-n">temps</span><span class="tok-o">.</span><span class="tok-n">min</span><span class="tok-o">,</span> <span class="tok-n">temps</span><span class="tok-o">.</span><span class="tok-n">max</span><span class="tok-o">,</span> <span class="tok-n">windowEnd</span><span class="tok-o">))</span>
  <span class="tok-o">}</span>
<span class="tok-o">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>我们还可以将ReduceFunction/AggregateFunction和ProcessWindowFunction结合起来使用。ReduceFunction/AggregateFunction做增量聚合，ProcessWindowFunction提供更多的对数据流的访问权限。如果只使用ProcessWindowFunction(底层的实现为将事件都保存在ListState中)，将会非常占用空间。分配到某个窗口的元素将被提前聚合，而当窗口的trigger触发时，也就是窗口收集完数据关闭时，将会把聚合结果发送到ProcessWindowFunction中，这时Iterable参数将会只有一个值，就是前面聚合的值。</p>
</div>
<div class="paragraph">
<p>例子</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-n">input</span>
  <span class="tok-o">.</span><span class="tok-n">keyBy</span><span class="tok-o">(...)</span>
  <span class="tok-o">.</span><span class="tok-n">timeWindow</span><span class="tok-o">(...)</span>
  <span class="tok-o">.</span><span class="tok-n">reduce</span><span class="tok-o">(</span>
    <span class="tok-n">incrAggregator</span><span class="tok-k">:</span> <span class="tok-kt">ReduceFunction</span><span class="tok-o">[</span><span class="tok-kt">IN</span><span class="tok-o">],</span>
    <span class="tok-n">function</span><span class="tok-k">:</span> <span class="tok-kt">ProcessWindowFunction</span><span class="tok-o">[</span><span class="tok-kt">IN</span>, <span class="tok-kt">OUT</span>, <span class="tok-kt">K</span>, <span class="tok-kt">W</span><span class="tok-o">])</span>

<span class="tok-n">input</span>
  <span class="tok-o">.</span><span class="tok-n">keyBy</span><span class="tok-o">(...)</span>
  <span class="tok-o">.</span><span class="tok-n">timeWindow</span><span class="tok-o">(...)</span>
  <span class="tok-o">.</span><span class="tok-n">aggregate</span><span class="tok-o">(</span>
    <span class="tok-n">incrAggregator</span><span class="tok-k">:</span> <span class="tok-kt">AggregateFunction</span><span class="tok-o">[</span><span class="tok-kt">IN</span>, <span class="tok-kt">ACC</span>, <span class="tok-kt">V</span><span class="tok-o">],</span>
    <span class="tok-n">windowFunction</span><span class="tok-k">:</span> <span class="tok-kt">ProcessWindowFunction</span><span class="tok-o">[</span><span class="tok-kt">V</span>, <span class="tok-kt">OUT</span>, <span class="tok-kt">K</span>, <span class="tok-kt">W</span><span class="tok-o">])</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>我们把之前的需求重新使用以上两种方法实现一下。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">case</span> <span class="tok-k">class</span> <span class="tok-nc">MinMaxTemp</span><span class="tok-o">(</span><span class="tok-n">id</span><span class="tok-k">:</span> <span class="tok-kt">String</span><span class="tok-o">,</span> <span class="tok-n">min</span><span class="tok-k">:</span> <span class="tok-kt">Double</span><span class="tok-o">,</span> <span class="tok-n">max</span><span class="tok-k">:</span> <span class="tok-kt">Double</span><span class="tok-o">,</span> <span class="tok-n">endTs</span><span class="tok-k">:</span> <span class="tok-kt">Long</span><span class="tok-o">)</span>

<span class="tok-k">val</span> <span class="tok-n">minMaxTempPerWindow2</span><span class="tok-k">:</span> <span class="tok-kt">DataStream</span><span class="tok-o">[</span><span class="tok-kt">MinMaxTemp</span><span class="tok-o">]</span> <span class="tok-k">=</span> <span class="tok-n">sensorData</span>
  <span class="tok-o">.</span><span class="tok-n">map</span><span class="tok-o">(</span><span class="tok-n">r</span> <span class="tok-k">=&gt;</span> <span class="tok-o">(</span><span class="tok-n">r</span><span class="tok-o">.</span><span class="tok-n">id</span><span class="tok-o">,</span> <span class="tok-n">r</span><span class="tok-o">.</span><span class="tok-n">temperature</span><span class="tok-o">,</span> <span class="tok-n">r</span><span class="tok-o">.</span><span class="tok-n">temperature</span><span class="tok-o">))</span>
  <span class="tok-o">.</span><span class="tok-n">keyBy</span><span class="tok-o">(</span><span class="tok-k">_</span><span class="tok-o">.</span><span class="tok-n">_1</span><span class="tok-o">)</span>
  <span class="tok-o">.</span><span class="tok-n">timeWindow</span><span class="tok-o">(</span><span class="tok-nc">Time</span><span class="tok-o">.</span><span class="tok-n">seconds</span><span class="tok-o">(</span><span class="tok-mi">5</span><span class="tok-o">))</span>
  <span class="tok-o">.</span><span class="tok-n">reduce</span><span class="tok-o">(</span>
    <span class="tok-o">(</span><span class="tok-n">r1</span><span class="tok-k">:</span> <span class="tok-o">(</span><span class="tok-kt">String</span><span class="tok-o">,</span> <span class="tok-kt">Double</span><span class="tok-o">,</span> <span class="tok-nc">Double</span><span class="tok-o">),</span> <span class="tok-n">r2</span><span class="tok-k">:</span> <span class="tok-o">(</span><span class="tok-kt">String</span><span class="tok-o">,</span> <span class="tok-kt">Double</span><span class="tok-o">,</span> <span class="tok-nc">Double</span><span class="tok-o">))</span> <span class="tok-k">=&gt;</span> <span class="tok-o">{</span>
      <span class="tok-o">(</span><span class="tok-n">r1</span><span class="tok-o">.</span><span class="tok-n">_1</span><span class="tok-o">,</span> <span class="tok-n">r1</span><span class="tok-o">.</span><span class="tok-n">_2</span><span class="tok-o">.</span><span class="tok-n">min</span><span class="tok-o">(</span><span class="tok-n">r2</span><span class="tok-o">.</span><span class="tok-n">_2</span><span class="tok-o">),</span> <span class="tok-n">r1</span><span class="tok-o">.</span><span class="tok-n">_3</span><span class="tok-o">.</span><span class="tok-n">max</span><span class="tok-o">(</span><span class="tok-n">r2</span><span class="tok-o">.</span><span class="tok-n">_3</span><span class="tok-o">))</span>
    <span class="tok-o">},</span>
    <span class="tok-k">new</span> <span class="tok-nc">AssignWindowEndProcessFunction</span><span class="tok-o">()</span>
  <span class="tok-o">)</span>

<span class="tok-k">class</span> <span class="tok-nc">AssignWindowEndProcessFunction</span> <span class="tok-k">extends</span> <span class="tok-nc">ProcessWindowFunction</span><span class="tok-o">[(</span><span class="tok-kt">String</span>, <span class="tok-kt">Double</span>, <span class="tok-kt">Double</span><span class="tok-o">)</span>, <span class="tok-kt">MinMaxTemp</span>, <span class="tok-kt">String</span>, <span class="tok-kt">TimeWindow</span><span class="tok-o">]</span> <span class="tok-o">{</span>
  <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">process</span><span class="tok-o">(</span><span class="tok-n">key</span><span class="tok-k">:</span> <span class="tok-kt">String</span><span class="tok-o">,</span>
                       <span class="tok-n">ctx</span><span class="tok-k">:</span> <span class="tok-kt">Context</span><span class="tok-o">,</span>
                       <span class="tok-n">minMaxIt</span><span class="tok-k">:</span> <span class="tok-kt">Iterable</span><span class="tok-o">[(</span><span class="tok-kt">String</span>, <span class="tok-kt">Double</span>, <span class="tok-kt">Double</span><span class="tok-o">)],</span>
                       <span class="tok-n">out</span><span class="tok-k">:</span> <span class="tok-kt">Collector</span><span class="tok-o">[</span><span class="tok-kt">MinMaxTemp</span><span class="tok-o">])</span><span class="tok-k">:</span> <span class="tok-kt">Unit</span> <span class="tok-o">=</span> <span class="tok-o">{</span>
    <span class="tok-k">val</span> <span class="tok-n">minMax</span> <span class="tok-k">=</span> <span class="tok-n">minMaxIt</span><span class="tok-o">.</span><span class="tok-n">head</span>
    <span class="tok-k">val</span> <span class="tok-n">windowEnd</span> <span class="tok-k">=</span> <span class="tok-n">ctx</span><span class="tok-o">.</span><span class="tok-n">window</span><span class="tok-o">.</span><span class="tok-n">getEnd</span>
    <span class="tok-n">out</span><span class="tok-o">.</span><span class="tok-n">collect</span><span class="tok-o">(</span><span class="tok-nc">MinMaxTemp</span><span class="tok-o">(</span><span class="tok-n">key</span><span class="tok-o">,</span> <span class="tok-n">minMax</span><span class="tok-o">.</span><span class="tok-n">_2</span><span class="tok-o">,</span> <span class="tok-n">minMax</span><span class="tok-o">.</span><span class="tok-n">_3</span><span class="tok-o">,</span> <span class="tok-n">windowEnd</span><span class="tok-o">))</span>
  <span class="tok-o">}</span>
<span class="tok-o">}</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_自定义窗口操作符windows_operators">8.4. 自定义窗口操作符(windows operators)</h3>
<div class="paragraph">
<p>Flink内置的window operators分配器已经已经足够应付大多数应用场景。尽管如此，如果我们需要实现一些复杂的窗口逻辑，例如：可以发射早到的事件或者碰到迟到的事件就更新窗口的结果，或者窗口的开始和结束决定于特定事件的接收。</p>
</div>
<div class="paragraph">
<p>DataStream API暴露了接口和方法来自定义窗口操作符。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>自定义窗口分配器</p>
</li>
<li>
<p>自定义窗口计算触发器(trigger)</p>
</li>
<li>
<p>自定义窗口数据清理功能(evictor)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>当一个事件来到窗口操作符，首先将会传给WindowAssigner来处理。WindowAssigner决定了事件将被分配到哪些窗口。如果窗口不存在，WindowAssigner将会创建一个新的窗口。</p>
</div>
<div class="paragraph">
<p>如果一个window operator接受了一个增量聚合函数作为参数，例如ReduceFunction或者AggregateFunction，新到的元素将会立即被聚合，而聚合结果result将存储在window中。如果window operator没有使用增量聚合函数，那么新元素将被添加到ListState中，ListState中保存了所有分配给窗口的元素。</p>
</div>
<div class="paragraph">
<p>新元素被添加到窗口时，这个新元素同时也被传给了window的trigger。trigger定义了window何时准备好求值，何时window被清空。trigger可以基于window被分配的元素和注册的定时器来对窗口的所有元素求值或者在特定事件清空window中所有的元素。</p>
</div>
<div class="paragraph">
<p>当window operator只接收一个增量聚合函数作为参数时：</p>
</div>
<div class="paragraph">
<p>当window operator只接收一个全窗口函数作为参数时：</p>
</div>
<div class="paragraph">
<p>当window operator接收一个增量聚合函数和一个全窗口函数作为参数时：</p>
</div>
<div class="paragraph">
<p>evictor是一个可选的组件，可以被注入到ProcessWindowFunction之前或者之后调用。evictor可以清除掉window中收集的元素。由于evictor需要迭代所有的元素，所以evictor只能使用在没有增量聚合函数作为参数的情况下。</p>
</div>
<div class="paragraph">
<p>下面的代码说明了如果使用自定义的trigger和evictor定义一个window operator：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-n">stream</span>
  <span class="tok-o">.</span><span class="tok-n">keyBy</span><span class="tok-o">(...)</span>
  <span class="tok-o">.</span><span class="tok-n">window</span><span class="tok-o">(...)</span>
 <span class="tok-o">[</span><span class="tok-kt">.trigger</span><span class="tok-o">(</span><span class="tok-kt">...</span><span class="tok-o">)]</span>
 <span class="tok-o">[</span><span class="tok-kt">.evictor</span><span class="tok-o">(</span><span class="tok-kt">...</span><span class="tok-o">)]</span>
  <span class="tok-o">.</span><span class="tok-n">reduce</span><span class="tok-o">/</span><span class="tok-n">aggregate</span><span class="tok-o">/</span><span class="tok-n">process</span><span class="tok-o">(...)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>注意：每个WindowAssigner都有一个默认的trigger。</p>
</div>
</div>
<div class="sect2">
<h3 id="_窗口生命周期">8.5. 窗口生命周期</h3>
<div class="paragraph">
<p>当WindowAssigner分配某个窗口的第一个元素时，这个窗口才会被创建。所以不存在没有元素的窗口。</p>
</div>
<div class="paragraph">
<p>一个窗口包含了如下状态：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Window content</p>
<div class="ulist">
<ul>
<li>
<p>分配到这个窗口的元素</p>
</li>
<li>
<p>增量聚合的结果(如果window operator接收了ReduceFunction或者AggregateFunction作为参数)。</p>
</li>
</ul>
</div>
</li>
<li>
<p>Window object</p>
<div class="ulist">
<ul>
<li>
<p>WindowAssigner返回0个，1个或者多个window object。</p>
</li>
<li>
<p>window operator根据返回的window object来聚合元素。</p>
</li>
<li>
<p>每一个window object包含一个windowEnd时间戳，来区别于其他窗口。</p>
</li>
</ul>
</div>
</li>
<li>
<p>触发器的定时器：一个触发器可以注册定时事件，到了定时的时间可以执行相应的回调函数，例如：对窗口进行求值或者清空窗口。</p>
</li>
<li>
<p>触发器中的自定义状态：触发器可以定义和使用自定义的、per-window或者per-key状态。这个状态完全被触发器所控制。而不是被window operator控制。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>当窗口结束时间来到，window operator将删掉这个窗口。窗口结束时间是由window object的end timestamp所定义的。无论是使用processing time还是event time，窗口结束时间是什么类型可以调用WindowAssigner.isEventTime()方法获得。</p>
</div>
</div>
<div class="sect2">
<h3 id="_窗口分配器window_assigners">8.6. 窗口分配器(window assigners)</h3>
<div class="paragraph">
<p>WindowAssigner将会把元素分配到0个，1个或者多个窗口中去。我们看一下WindowAssigner接口：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="java"><span></span><span class="tok-kd">public</span> <span class="tok-kd">abstract</span> <span class="tok-kd">class</span> <span class="tok-nc">WindowAssigner</span><span class="tok-o">&lt;</span><span class="tok-n">T</span><span class="tok-o">,</span> <span class="tok-n">W</span> <span class="tok-kd">extends</span> <span class="tok-n">Window</span><span class="tok-o">&gt;</span>
    <span class="tok-kd">implements</span> <span class="tok-n">Serializable</span> <span class="tok-o">{</span>

  <span class="tok-kd">public</span> <span class="tok-kd">abstract</span> <span class="tok-n">Collection</span><span class="tok-o">&lt;</span><span class="tok-n">W</span><span class="tok-o">&gt;</span> <span class="tok-nf">assignWindows</span><span class="tok-o">(</span>
    <span class="tok-n">T</span> <span class="tok-n">element</span><span class="tok-o">,</span>
    <span class="tok-kt">long</span> <span class="tok-n">timestamp</span><span class="tok-o">,</span>
    <span class="tok-n">WindowAssignerContext</span> <span class="tok-n">context</span><span class="tok-o">);</span>

  <span class="tok-kd">public</span> <span class="tok-kd">abstract</span> <span class="tok-n">Trigger</span><span class="tok-o">&lt;</span><span class="tok-n">T</span><span class="tok-o">,</span> <span class="tok-n">W</span><span class="tok-o">&gt;</span> <span class="tok-nf">getDefaultTriger</span><span class="tok-o">(</span>
    <span class="tok-n">StreamExecutionEnvironment</span> <span class="tok-n">env</span><span class="tok-o">);</span>

  <span class="tok-kd">public</span> <span class="tok-kd">abstract</span> <span class="tok-n">TypeSerializer</span><span class="tok-o">&lt;</span><span class="tok-n">W</span><span class="tok-o">&gt;</span> <span class="tok-nf">getWindowSerializer</span><span class="tok-o">(</span>
    <span class="tok-n">ExecutionConfig</span> <span class="tok-n">executionConfig</span><span class="tok-o">);</span>

  <span class="tok-kd">public</span> <span class="tok-kd">abstract</span> <span class="tok-kt">boolean</span> <span class="tok-nf">isEventTime</span><span class="tok-o">();</span>

  <span class="tok-kd">public</span> <span class="tok-kd">abstract</span> <span class="tok-kd">static</span> <span class="tok-kd">class</span> <span class="tok-nc">WindowAssignerContext</span> <span class="tok-o">{</span>
    <span class="tok-kd">public</span> <span class="tok-kd">abstract</span> <span class="tok-kt">long</span> <span class="tok-nf">getCurrentProcessingTime</span><span class="tok-o">();</span>
  <span class="tok-o">}</span>
<span class="tok-o">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>WindowAssigner有两个泛型参数：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>T: 事件的数据类型</p>
</li>
<li>
<p>W: 窗口的类型</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>下面的代码创建了一个自定义窗口分配器，是一个30秒的滚动事件时间窗口。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">class</span> <span class="tok-nc">ThirtySecondsWindows</span>
    <span class="tok-k">extends</span> <span class="tok-nc">WindowAssigner</span><span class="tok-o">[</span><span class="tok-kt">Object</span>, <span class="tok-kt">TimeWindow</span><span class="tok-o">]</span> <span class="tok-o">{</span>

  <span class="tok-k">val</span> <span class="tok-n">windowSize</span><span class="tok-k">:</span> <span class="tok-kt">Long</span> <span class="tok-o">=</span> <span class="tok-mi">30</span> <span class="tok-o">*</span> <span class="tok-mi">1000L</span>

  <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">assignWindows</span><span class="tok-o">(</span>
    <span class="tok-n">o</span><span class="tok-k">:</span> <span class="tok-kt">Object</span><span class="tok-o">,</span>
    <span class="tok-n">ts</span><span class="tok-k">:</span> <span class="tok-kt">Long</span><span class="tok-o">,</span>
    <span class="tok-n">ctx</span><span class="tok-k">:</span> <span class="tok-kt">WindowAssigner.WindowAssignerContext</span><span class="tok-o">)</span><span class="tok-k">:</span> <span class="tok-kt">java.util.List</span><span class="tok-o">[</span><span class="tok-kt">TimeWindow</span><span class="tok-o">]</span> <span class="tok-k">=</span> <span class="tok-o">{</span>

    <span class="tok-k">val</span> <span class="tok-n">startTime</span> <span class="tok-k">=</span> <span class="tok-n">ts</span> <span class="tok-o">-</span> <span class="tok-o">(</span><span class="tok-n">ts</span> <span class="tok-o">%</span> <span class="tok-n">windowSize</span><span class="tok-o">)</span>
    <span class="tok-k">val</span> <span class="tok-n">endTime</span> <span class="tok-k">=</span> <span class="tok-n">startTime</span> <span class="tok-o">+</span> <span class="tok-n">windowSize</span>
    <span class="tok-nc">Collections</span><span class="tok-o">.</span><span class="tok-n">singletonList</span><span class="tok-o">(</span><span class="tok-k">new</span> <span class="tok-nc">TimeWindow</span><span class="tok-o">(</span><span class="tok-n">startTime</span><span class="tok-o">,</span> <span class="tok-n">endTime</span><span class="tok-o">))</span>
  <span class="tok-o">}</span>

  <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">getDefaultTrigger</span><span class="tok-o">(</span>
    <span class="tok-n">env</span><span class="tok-k">:</span> <span class="tok-kt">environment.StreamExecutionEnvironment</span><span class="tok-o">)</span><span class="tok-k">:</span> <span class="tok-kt">Trigger</span><span class="tok-o">[</span><span class="tok-kt">Object</span>, <span class="tok-kt">TimeWindow</span><span class="tok-o">]</span> <span class="tok-k">=</span> <span class="tok-o">{</span>
      <span class="tok-nc">EventTimeTrigger</span><span class="tok-o">.</span><span class="tok-n">create</span><span class="tok-o">()</span>
  <span class="tok-o">}</span>

  <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">getWindowSerializer</span><span class="tok-o">(</span>
    <span class="tok-n">executionConfig</span><span class="tok-k">:</span> <span class="tok-kt">ExecutionConfig</span><span class="tok-o">)</span><span class="tok-k">:</span> <span class="tok-kt">TypeSerializer</span><span class="tok-o">[</span><span class="tok-kt">TimeWindow</span><span class="tok-o">]</span> <span class="tok-k">=</span> <span class="tok-o">{</span>
    <span class="tok-k">new</span> <span class="tok-nc">TimeWindow</span><span class="tok-o">.</span><span class="tok-nc">Serializer</span>
  <span class="tok-o">}</span>

  <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">isEventTime</span> <span class="tok-k">=</span> <span class="tok-kc">true</span>
<span class="tok-o">}</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_触发器triggers">8.7. 触发器(Triggers)</h3>
<div class="paragraph">
<p>触发器定义了window何时会被求值以及何时发送求值结果。触发器可以到了特定的时间触发也可以碰到特定的事件触发。例如：观察到事件数量符合一定条件或者观察到了特定的事件。</p>
</div>
<div class="paragraph">
<p>默认的触发器将会在两种情况下触发</p>
</div>
<div class="ulist">
<ul>
<li>
<p>处理时间：机器时间到达处理时间</p>
</li>
<li>
<p>事件时间：水位线超过了窗口的结束时间</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>触发器可以访问流的时间属性以及定时器，还可以对state状态编程。所以触发器和process function一样强大。例如我们可以实现一个触发逻辑：当窗口接收到一定数量的元素时，触发器触发。再比如当窗口接收到一个特定元素时，触发器触发。还有就是当窗口接收到的元素里面包含特定模式(5秒钟内接收到了两个同样类型的事件)，触发器也可以触发。在一个事件时间的窗口中，一个自定义的触发器可以提前(在水位线没过窗口结束时间之前)计算和发射计算结果。这是一个常见的低延迟计算策略，尽管计算不完全，但不像默认的那样需要等待水位线没过窗口结束时间。</p>
</div>
<div class="paragraph">
<p>每次调用触发器都会产生一个TriggerResult来决定窗口接下来发生什么。TriggerResult可以取以下结果：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>CONTINUE：什么都不做</p>
</li>
<li>
<p>FIRE：如果window operator有ProcessWindowFunction这个参数，将会调用这个ProcessWindowFunction。如果窗口仅有增量聚合函数(ReduceFunction或者AggregateFunction)作为参数，那么当前的聚合结果将会被发送。窗口的state不变。</p>
</li>
<li>
<p>PURGE：窗口所有内容包括窗口的元数据都将被丢弃。</p>
</li>
<li>
<p>FIRE_AND_PURGE：先对窗口进行求值，再将窗口中的内容丢弃。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>TriggerResult可能的取值使得我们可以实现很复杂的窗口逻辑。一个自定义触发器可以触发多次，可以计算或者更新结果，可以在发送结果之前清空窗口。</p>
</div>
<div class="paragraph">
<p>接下来我们看一下Trigger API：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="java"><span></span><span class="tok-kd">public</span> <span class="tok-kd">abstract</span> <span class="tok-kd">class</span> <span class="tok-nc">Trigger</span><span class="tok-o">&lt;</span><span class="tok-n">T</span><span class="tok-o">,</span> <span class="tok-n">W</span> <span class="tok-kd">extends</span> <span class="tok-n">Window</span><span class="tok-o">&gt;</span>
    <span class="tok-kd">implements</span> <span class="tok-n">Serializable</span> <span class="tok-o">{</span>

  <span class="tok-n">TriggerResult</span> <span class="tok-nf">onElement</span><span class="tok-o">(</span>
    <span class="tok-kt">long</span> <span class="tok-n">timestamp</span><span class="tok-o">,</span>
    <span class="tok-n">W</span> <span class="tok-n">window</span><span class="tok-o">,</span>
    <span class="tok-n">TriggerContext</span> <span class="tok-n">ctx</span><span class="tok-o">);</span>

  <span class="tok-kd">public</span> <span class="tok-kd">abstract</span> <span class="tok-n">TriggerResult</span> <span class="tok-nf">onProcessingTime</span><span class="tok-o">(</span>
    <span class="tok-kt">long</span> <span class="tok-n">timestamp</span><span class="tok-o">,</span>
    <span class="tok-n">W</span> <span class="tok-n">window</span><span class="tok-o">,</span>
    <span class="tok-n">TriggerContext</span> <span class="tok-n">ctx</span><span class="tok-o">);</span>

  <span class="tok-kd">public</span> <span class="tok-kd">abstract</span> <span class="tok-n">TriggerResult</span> <span class="tok-nf">onEventTime</span><span class="tok-o">(</span>
    <span class="tok-kt">long</span> <span class="tok-n">timestamp</span><span class="tok-o">,</span>
    <span class="tok-n">W</span> <span class="tok-n">window</span><span class="tok-o">,</span>
    <span class="tok-n">TriggerContext</span> <span class="tok-n">ctx</span><span class="tok-o">);</span>

  <span class="tok-kd">public</span> <span class="tok-kt">boolean</span> <span class="tok-nf">canMerge</span><span class="tok-o">();</span>

  <span class="tok-kd">public</span> <span class="tok-kt">void</span> <span class="tok-nf">onMerge</span><span class="tok-o">(</span><span class="tok-n">W</span> <span class="tok-n">window</span><span class="tok-o">,</span> <span class="tok-n">OnMergeContext</span> <span class="tok-n">ctx</span><span class="tok-o">);</span>

  <span class="tok-kd">public</span> <span class="tok-kd">abstract</span> <span class="tok-kt">void</span> <span class="tok-nf">clear</span><span class="tok-o">(</span><span class="tok-n">W</span> <span class="tok-n">window</span><span class="tok-o">,</span> <span class="tok-n">TriggerContext</span> <span class="tok-n">ctx</span><span class="tok-o">);</span>
<span class="tok-o">}</span>

<span class="tok-kd">public</span> <span class="tok-kd">interface</span> <span class="tok-nc">TriggerContext</span> <span class="tok-o">{</span>

  <span class="tok-kt">long</span> <span class="tok-nf">getCurrentProcessingTime</span><span class="tok-o">();</span>

  <span class="tok-kt">long</span> <span class="tok-nf">getCurrentWatermark</span><span class="tok-o">();</span>

  <span class="tok-kt">void</span> <span class="tok-nf">registerProcessingTimeTimer</span><span class="tok-o">(</span><span class="tok-kt">long</span> <span class="tok-n">time</span><span class="tok-o">);</span>

  <span class="tok-kt">void</span> <span class="tok-nf">registerEventTimeTimer</span><span class="tok-o">(</span><span class="tok-kt">long</span> <span class="tok-n">time</span><span class="tok-o">);</span>

  <span class="tok-kt">void</span> <span class="tok-nf">registerEventTimeTimer</span><span class="tok-o">(</span><span class="tok-kt">long</span> <span class="tok-n">time</span><span class="tok-o">);</span>

  <span class="tok-kt">void</span> <span class="tok-nf">deleteProcessingTimeTimer</span><span class="tok-o">(</span><span class="tok-kt">long</span> <span class="tok-n">time</span><span class="tok-o">);</span>

  <span class="tok-kt">void</span> <span class="tok-nf">deleteEventTimeTimer</span><span class="tok-o">(</span><span class="tok-kt">long</span> <span class="tok-n">time</span><span class="tok-o">);</span>

  <span class="tok-o">&lt;</span><span class="tok-n">S</span> <span class="tok-kd">extends</span> <span class="tok-n">State</span><span class="tok-o">&gt;</span> <span class="tok-n">S</span> <span class="tok-nf">getPartitionedState</span><span class="tok-o">(</span>
    <span class="tok-n">StateDescriptor</span><span class="tok-o">&lt;</span><span class="tok-n">S</span><span class="tok-o">,</span> <span class="tok-o">?&gt;</span> <span class="tok-n">stateDescriptor</span><span class="tok-o">);</span>
<span class="tok-o">}</span>

<span class="tok-kd">public</span> <span class="tok-kd">interface</span> <span class="tok-nc">OnMergeContext</span> <span class="tok-kd">extends</span> <span class="tok-n">TriggerContext</span> <span class="tok-o">{</span>

  <span class="tok-kt">void</span> <span class="tok-nf">mergePartitionedState</span><span class="tok-o">(</span>
    <span class="tok-n">StateDescriptor</span><span class="tok-o">&lt;</span><span class="tok-n">S</span><span class="tok-o">,</span> <span class="tok-o">?&gt;</span> <span class="tok-n">stateDescriptor</span>
  <span class="tok-o">);</span>
<span class="tok-o">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这里要注意两个地方：清空state和merging合并触发器。</p>
</div>
<div class="paragraph">
<p>当在触发器中使用per-window state时，这里我们需要保证当窗口被删除时state也要被删除，否则随着时间的推移，window operator将会积累越来越多的数据，最终可能使应用崩溃。</p>
</div>
<div class="paragraph">
<p>当窗口被删除时，为了清空所有状态，触发器的clear()方法需要需要删掉所有的自定义per-window state，以及使用TriggerContext对象将处理时间和事件时间的定时器都删除。</p>
</div>
<div class="paragraph">
<p>下面的例子展示了一个触发器在窗口结束时间之前触发。当第一个事件被分配到窗口时，这个触发器注册了一个定时器，定时时间为水位线之前一秒钟。当定时事件执行，将会注册一个新的定时事件，这样，这个触发器每秒钟最多触发一次。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">class</span> <span class="tok-nc">OneSecondIntervalTrigger</span>
    <span class="tok-k">extends</span> <span class="tok-nc">Trigger</span><span class="tok-o">[</span><span class="tok-kt">SensorReading</span>, <span class="tok-kt">TimeWindow</span><span class="tok-o">]</span> <span class="tok-o">{</span>

  <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">onElement</span><span class="tok-o">(</span>
    <span class="tok-n">r</span><span class="tok-k">:</span> <span class="tok-kt">SensorReading</span><span class="tok-o">,</span>
    <span class="tok-n">timestamp</span><span class="tok-k">:</span> <span class="tok-kt">Long</span><span class="tok-o">,</span>
    <span class="tok-n">window</span><span class="tok-k">:</span> <span class="tok-kt">TimeWindow</span><span class="tok-o">,</span>
    <span class="tok-n">ctx</span><span class="tok-k">:</span> <span class="tok-kt">Trigger.TriggerContext</span>
  <span class="tok-o">)</span><span class="tok-k">:</span> <span class="tok-kt">TriggerResult</span> <span class="tok-o">=</span> <span class="tok-o">{</span>
    <span class="tok-k">val</span> <span class="tok-n">firstSeen</span><span class="tok-k">:</span> <span class="tok-kt">ValueState</span><span class="tok-o">[</span><span class="tok-kt">Boolean</span><span class="tok-o">]</span> <span class="tok-k">=</span> <span class="tok-n">ctx</span>
      <span class="tok-o">.</span><span class="tok-n">getPartitionedState</span><span class="tok-o">(</span>
        <span class="tok-k">new</span> <span class="tok-nc">ValueStateDescriptor</span><span class="tok-o">[</span><span class="tok-kt">Boolean</span><span class="tok-o">](</span>
          <span class="tok-s">&quot;firstSeen&quot;</span><span class="tok-o">,</span> <span class="tok-n">classOf</span><span class="tok-o">[</span><span class="tok-kt">Boolean</span><span class="tok-o">]</span>
        <span class="tok-o">)</span>
      <span class="tok-o">)</span>

    <span class="tok-k">if</span> <span class="tok-o">(!</span><span class="tok-n">firstSeen</span><span class="tok-o">.</span><span class="tok-n">value</span><span class="tok-o">())</span> <span class="tok-o">{</span>
      <span class="tok-k">val</span> <span class="tok-n">t</span> <span class="tok-k">=</span> <span class="tok-n">ctx</span><span class="tok-o">.</span><span class="tok-n">getCurrentWatermark</span> <span class="tok-o">+</span> <span class="tok-o">(</span><span class="tok-mi">1000</span> <span class="tok-o">-</span> <span class="tok-o">(</span><span class="tok-n">ctx</span><span class="tok-o">.</span><span class="tok-n">getCurrentWatermark</span> <span class="tok-o">%</span> <span class="tok-mi">1000</span><span class="tok-o">))</span>
      <span class="tok-n">ctx</span><span class="tok-o">.</span><span class="tok-n">registerEventTimeTimer</span><span class="tok-o">(</span><span class="tok-n">t</span><span class="tok-o">)</span>
      <span class="tok-n">ctx</span><span class="tok-o">.</span><span class="tok-n">registerEventTimeTimer</span><span class="tok-o">(</span><span class="tok-n">window</span><span class="tok-o">.</span><span class="tok-n">getEnd</span><span class="tok-o">)</span>
      <span class="tok-n">firstSeen</span><span class="tok-o">.</span><span class="tok-n">update</span><span class="tok-o">(</span><span class="tok-kc">true</span><span class="tok-o">)</span>
    <span class="tok-o">}</span>

    <span class="tok-nc">TriggerResult</span><span class="tok-o">.</span><span class="tok-nc">CONTINUE</span>
  <span class="tok-o">}</span>

  <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">onEventTime</span><span class="tok-o">(</span>
    <span class="tok-n">timestamp</span><span class="tok-k">:</span> <span class="tok-kt">Long</span><span class="tok-o">,</span>
    <span class="tok-n">window</span><span class="tok-k">:</span> <span class="tok-kt">TimeWindow</span><span class="tok-o">,</span>
    <span class="tok-n">ctx</span><span class="tok-k">:</span> <span class="tok-kt">Trigger.TriggerContext</span>
  <span class="tok-o">)</span><span class="tok-k">:</span> <span class="tok-kt">TriggerResult</span> <span class="tok-o">=</span> <span class="tok-o">{</span>
    <span class="tok-k">if</span> <span class="tok-o">(</span><span class="tok-n">timestamp</span> <span class="tok-o">==</span> <span class="tok-n">window</span><span class="tok-o">.</span><span class="tok-n">getEnd</span><span class="tok-o">)</span> <span class="tok-o">{</span>
      <span class="tok-nc">TriggerResult</span><span class="tok-o">.</span><span class="tok-nc">FIRE_AND_PURGE</span>
    <span class="tok-o">}</span> <span class="tok-k">else</span> <span class="tok-o">{</span>
      <span class="tok-k">val</span> <span class="tok-n">t</span> <span class="tok-k">=</span> <span class="tok-n">ctx</span><span class="tok-o">.</span><span class="tok-n">getCurrentWatermark</span> <span class="tok-o">+</span> <span class="tok-o">(</span><span class="tok-mi">1000</span> <span class="tok-o">-</span> <span class="tok-o">(</span><span class="tok-n">ctx</span><span class="tok-o">.</span><span class="tok-n">getCurrentWatermark</span> <span class="tok-o">%</span> <span class="tok-mi">1000</span><span class="tok-o">))</span>
      <span class="tok-k">if</span> <span class="tok-o">(</span><span class="tok-n">t</span> <span class="tok-o">&lt;</span> <span class="tok-n">window</span><span class="tok-o">.</span><span class="tok-n">getEnd</span><span class="tok-o">)</span> <span class="tok-o">{</span>
        <span class="tok-n">ctx</span><span class="tok-o">.</span><span class="tok-n">registerEventTimeTimer</span><span class="tok-o">(</span><span class="tok-n">t</span><span class="tok-o">)</span>
      <span class="tok-o">}</span>
      <span class="tok-nc">TriggerResult</span><span class="tok-o">.</span><span class="tok-nc">FIRE</span>
    <span class="tok-o">}</span>
  <span class="tok-o">}</span>

  <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">onProcessingTime</span><span class="tok-o">(</span>
    <span class="tok-n">timestamp</span><span class="tok-k">:</span> <span class="tok-kt">Long</span><span class="tok-o">,</span>
    <span class="tok-n">window</span><span class="tok-k">:</span> <span class="tok-kt">TimeWindow</span><span class="tok-o">,</span>
    <span class="tok-n">ctx</span><span class="tok-k">:</span> <span class="tok-kt">Trigger.TriggerContext</span>
  <span class="tok-o">)</span><span class="tok-k">:</span> <span class="tok-kt">TriggerResult</span> <span class="tok-o">=</span> <span class="tok-o">{</span>
    <span class="tok-nc">TriggerResult</span><span class="tok-o">.</span><span class="tok-nc">CONTINUE</span>
  <span class="tok-o">}</span>

  <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">clear</span><span class="tok-o">(</span>
    <span class="tok-n">window</span><span class="tok-k">:</span> <span class="tok-kt">TimeWindow</span><span class="tok-o">,</span>
    <span class="tok-n">ctx</span><span class="tok-k">:</span> <span class="tok-kt">Trigger.TriggerContext</span>
  <span class="tok-o">)</span><span class="tok-k">:</span> <span class="tok-kt">Unit</span> <span class="tok-o">=</span> <span class="tok-o">{</span>
    <span class="tok-k">val</span> <span class="tok-n">firstSeen</span><span class="tok-k">:</span> <span class="tok-kt">ValueState</span><span class="tok-o">[</span><span class="tok-kt">Boolean</span><span class="tok-o">]</span> <span class="tok-k">=</span> <span class="tok-n">ctx</span>
      <span class="tok-o">.</span><span class="tok-n">getPartitionedState</span><span class="tok-o">(</span>
        <span class="tok-k">new</span> <span class="tok-nc">ValueStateDescriptor</span><span class="tok-o">[</span><span class="tok-kt">Boolean</span><span class="tok-o">](</span>
          <span class="tok-s">&quot;firstSeen&quot;</span><span class="tok-o">,</span> <span class="tok-n">classOf</span><span class="tok-o">[</span><span class="tok-kt">Boolean</span><span class="tok-o">]</span>
        <span class="tok-o">)</span>
      <span class="tok-o">)</span>
    <span class="tok-n">firstSeen</span><span class="tok-o">.</span><span class="tok-n">clear</span><span class="tok-o">()</span>
  <span class="tok-o">}</span>
<span class="tok-o">}</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_evictors">8.8. EVICTORS</h3>
<div class="paragraph">
<p>evictor可以在window function求值之前或者之后移除窗口中的元素。</p>
</div>
<div class="paragraph">
<p>我们看一下Evictor的接口定义：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="java"><span></span><span class="tok-kd">public</span> <span class="tok-kd">interface</span> <span class="tok-nc">Evictor</span><span class="tok-o">&lt;</span><span class="tok-n">T</span><span class="tok-o">,</span> <span class="tok-n">W</span> <span class="tok-kd">extends</span> <span class="tok-n">Window</span><span class="tok-o">&gt;</span>
    <span class="tok-kd">extends</span> <span class="tok-n">Serializable</span> <span class="tok-o">{</span>
  <span class="tok-kt">void</span> <span class="tok-nf">evictBefore</span><span class="tok-o">(</span>
    <span class="tok-n">Iterable</span><span class="tok-o">&lt;</span><span class="tok-n">TimestampedValue</span><span class="tok-o">&lt;</span><span class="tok-n">T</span><span class="tok-o">&gt;&gt;</span> <span class="tok-n">elements</span><span class="tok-o">,</span>
    <span class="tok-kt">int</span> <span class="tok-n">size</span><span class="tok-o">,</span>
    <span class="tok-n">W</span> <span class="tok-n">window</span><span class="tok-o">,</span>
    <span class="tok-n">EvictorContext</span> <span class="tok-n">evictorContext</span><span class="tok-o">);</span>

  <span class="tok-kt">void</span> <span class="tok-nf">evictAfter</span><span class="tok-o">(</span>
    <span class="tok-n">Iterable</span><span class="tok-o">&lt;</span><span class="tok-n">TimestampedValue</span><span class="tok-o">&lt;</span><span class="tok-n">T</span><span class="tok-o">&gt;&gt;</span> <span class="tok-n">elements</span><span class="tok-o">,</span>
    <span class="tok-kt">int</span> <span class="tok-n">size</span><span class="tok-o">,</span>
    <span class="tok-n">W</span> <span class="tok-n">window</span><span class="tok-o">,</span>
    <span class="tok-n">EvictorContext</span> <span class="tok-n">evictorContext</span><span class="tok-o">);</span>

  <span class="tok-kd">interface</span> <span class="tok-nc">EvictorContext</span> <span class="tok-o">{</span>

    <span class="tok-kt">long</span> <span class="tok-nf">getCurrentProcessingTime</span><span class="tok-o">();</span>

    <span class="tok-kt">long</span> <span class="tok-nf">getCurrentWatermark</span><span class="tok-o">();</span>
  <span class="tok-o">}</span>
<span class="tok-o">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>evictBefore()和evictAfter()分别在window function计算之前或者之后调用。Iterable迭代器包含了窗口所有的元素，size为窗口中元素的数量，window object和EvictorContext可以访问当前处理时间和水位线。可以对Iterator调用remove()方法来移除窗口中的元素。</p>
</div>
<div class="paragraph">
<p>evictor也经常被用在GlobalWindow上，用来清楚部分元素，而不是将窗口中的元素全部清空。</p>
</div>
</div>
<div class="sect2">
<h3 id="_处理迟到的元素handling_late_data">8.9. 处理迟到的元素(Handling Late Data)</h3>
<div class="paragraph">
<p>水位线可以用来平衡计算的完整性和延迟两方面。除非我们选择一种非常保守的水位线策略(最大延时设置的非常大，以至于包含了所有的元素，但结果是非常大的延迟)，否则我们总需要处理迟到的元素。</p>
</div>
<div class="paragraph">
<p>迟到的元素是指当这个元素来到时，这个元素所对应的窗口已经计算完毕了(也就是说水位线已经没过窗口结束时间了)。这说明迟到这个特性只针对事件时间。</p>
</div>
<div class="paragraph">
<p>DataStream API提供了三种策略来处理迟到元素</p>
</div>
<div class="ulist">
<ul>
<li>
<p>直接抛弃迟到的元素</p>
</li>
<li>
<p>将迟到的元素发送到另一条流中去</p>
</li>
<li>
<p>可以更新窗口已经计算完的结果，并发出计算结果。</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_抛弃迟到元素">8.9.1. 抛弃迟到元素</h4>
<div class="paragraph">
<p>抛弃迟到的元素是event time window operator的默认行为。也就是说一个迟到的元素不会创建一个新的窗口。</p>
</div>
<div class="paragraph">
<p>process function可以通过比较迟到元素的时间戳和当前水位线的大小来很轻易的过滤掉迟到元素。</p>
</div>
</div>
<div class="sect3">
<h4 id="_重定向迟到元素">8.9.2. 重定向迟到元素</h4>
<div class="paragraph">
<p>迟到的元素也可以使用侧输出(side output)特性被重定向到另外的一条流中去。迟到元素所组成的侧输出流可以继续处理或者sink到持久化设施中去。</p>
</div>
<div class="paragraph">
<p>例子</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">val</span> <span class="tok-n">readings</span><span class="tok-k">:</span> <span class="tok-kt">DataStream</span><span class="tok-o">[</span><span class="tok-kt">SensorReading</span><span class="tok-o">]</span> <span class="tok-k">=</span> <span class="tok-o">???</span>

<span class="tok-k">val</span> <span class="tok-n">countPer10Secs</span><span class="tok-k">:</span> <span class="tok-kt">DataStream</span><span class="tok-o">[(</span><span class="tok-kt">String</span>, <span class="tok-kt">Long</span>, <span class="tok-kt">Int</span><span class="tok-o">)]</span> <span class="tok-k">=</span> <span class="tok-n">readings</span>
  <span class="tok-o">.</span><span class="tok-n">keyBy</span><span class="tok-o">(</span><span class="tok-k">_</span><span class="tok-o">.</span><span class="tok-n">id</span><span class="tok-o">)</span>
  <span class="tok-o">.</span><span class="tok-n">timeWindow</span><span class="tok-o">(</span><span class="tok-nc">Time</span><span class="tok-o">.</span><span class="tok-n">seconds</span><span class="tok-o">(</span><span class="tok-mi">10</span><span class="tok-o">))</span>
  <span class="tok-o">.</span><span class="tok-n">sideOutputLateData</span><span class="tok-o">(</span><span class="tok-k">new</span> <span class="tok-nc">OutputTag</span><span class="tok-o">[</span><span class="tok-kt">SensorReading</span><span class="tok-o">](</span><span class="tok-s">&quot;late-readings&quot;</span><span class="tok-o">))</span>
  <span class="tok-o">.</span><span class="tok-n">process</span><span class="tok-o">(</span><span class="tok-k">new</span> <span class="tok-nc">CountFunction</span><span class="tok-o">())</span>

<span class="tok-k">val</span> <span class="tok-n">lateStream</span><span class="tok-k">:</span> <span class="tok-kt">DataStream</span><span class="tok-o">[</span><span class="tok-kt">SensorReading</span><span class="tok-o">]</span> <span class="tok-k">=</span> <span class="tok-n">countPer10Secs</span>
  <span class="tok-o">.</span><span class="tok-n">getSideOutput</span><span class="tok-o">(</span><span class="tok-k">new</span> <span class="tok-nc">OutputTag</span><span class="tok-o">[</span><span class="tok-kt">SensorReading</span><span class="tok-o">](</span><span class="tok-s">&quot;late-readings&quot;</span><span class="tok-o">))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>下面这个例子展示了ProcessFunction如何过滤掉迟到的元素然后将迟到的元素发送到侧输出流中去。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">val</span> <span class="tok-n">readings</span><span class="tok-k">:</span> <span class="tok-kt">DataStream</span><span class="tok-o">[</span><span class="tok-kt">SensorReading</span><span class="tok-o">]</span> <span class="tok-k">=</span> <span class="tok-o">???</span>
<span class="tok-k">val</span> <span class="tok-n">filteredReadings</span><span class="tok-k">:</span> <span class="tok-kt">DataStream</span><span class="tok-o">[</span><span class="tok-kt">SensorReading</span><span class="tok-o">]</span> <span class="tok-k">=</span> <span class="tok-n">readings</span>
  <span class="tok-o">.</span><span class="tok-n">process</span><span class="tok-o">(</span><span class="tok-k">new</span> <span class="tok-nc">LateReadingsFilter</span><span class="tok-o">)</span>

<span class="tok-c1">// retrieve late readings</span>
<span class="tok-k">val</span> <span class="tok-n">lateReadings</span><span class="tok-k">:</span> <span class="tok-kt">DataStream</span><span class="tok-o">[</span><span class="tok-kt">SensorReading</span><span class="tok-o">]</span> <span class="tok-k">=</span> <span class="tok-n">filteredReadings</span>
  <span class="tok-o">.</span><span class="tok-n">getSideOutput</span><span class="tok-o">(</span><span class="tok-k">new</span> <span class="tok-nc">OutputTag</span><span class="tok-o">[</span><span class="tok-kt">SensorReading</span><span class="tok-o">](</span><span class="tok-s">&quot;late-readings&quot;</span><span class="tok-o">))</span>


<span class="tok-cm">/** A ProcessFunction that filters out late sensor readings and</span>
<span class="tok-cm">  * re-directs them to a side output */</span>
<span class="tok-k">class</span> <span class="tok-nc">LateReadingsFilter</span>
    <span class="tok-k">extends</span> <span class="tok-nc">ProcessFunction</span><span class="tok-o">[</span><span class="tok-kt">SensorReading</span>, <span class="tok-kt">SensorReading</span><span class="tok-o">]</span> <span class="tok-o">{</span>

  <span class="tok-k">val</span> <span class="tok-n">lateReadingsOut</span> <span class="tok-k">=</span> <span class="tok-k">new</span> <span class="tok-nc">OutputTag</span><span class="tok-o">[</span><span class="tok-kt">SensorReading</span><span class="tok-o">](</span><span class="tok-s">&quot;late-readings&quot;</span><span class="tok-o">)</span>

  <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">processElement</span><span class="tok-o">(</span>
      <span class="tok-n">r</span><span class="tok-k">:</span> <span class="tok-kt">SensorReading</span><span class="tok-o">,</span>
      <span class="tok-n">ctx</span><span class="tok-k">:</span> <span class="tok-kt">ProcessFunction</span><span class="tok-o">[</span><span class="tok-kt">SensorReading</span>, <span class="tok-kt">SensorReading</span><span class="tok-o">]</span><span class="tok-k">#</span><span class="tok-nc">Context</span><span class="tok-o">,</span>
      <span class="tok-n">out</span><span class="tok-k">:</span> <span class="tok-kt">Collector</span><span class="tok-o">[</span><span class="tok-kt">SensorReading</span><span class="tok-o">])</span><span class="tok-k">:</span> <span class="tok-kt">Unit</span> <span class="tok-o">=</span> <span class="tok-o">{</span>

    <span class="tok-c1">// compare record timestamp with current watermark</span>
    <span class="tok-k">if</span> <span class="tok-o">(</span><span class="tok-n">r</span><span class="tok-o">.</span><span class="tok-n">timestamp</span> <span class="tok-o">&lt;</span> <span class="tok-n">ctx</span><span class="tok-o">.</span><span class="tok-n">timerService</span><span class="tok-o">().</span><span class="tok-n">currentWatermark</span><span class="tok-o">())</span> <span class="tok-o">{</span>
      <span class="tok-c1">// this is a late reading =&gt; redirect it to the side output</span>
      <span class="tok-n">ctx</span><span class="tok-o">.</span><span class="tok-n">output</span><span class="tok-o">(</span><span class="tok-n">lateReadingsOut</span><span class="tok-o">,</span> <span class="tok-n">r</span><span class="tok-o">)</span>
    <span class="tok-o">}</span> <span class="tok-k">else</span> <span class="tok-o">{</span>
      <span class="tok-n">out</span><span class="tok-o">.</span><span class="tok-n">collect</span><span class="tok-o">(</span><span class="tok-n">r</span><span class="tok-o">)</span>
    <span class="tok-o">}</span>
  <span class="tok-o">}</span>
<span class="tok-o">}</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_使用迟到元素更新窗口计算结果updating_results_by_including_late_events">8.9.3. 使用迟到元素更新窗口计算结果(Updating Results by Including Late Events)</h4>
<div class="paragraph">
<p>由于存在迟到的元素，所以已经计算出的窗口结果是不准确和不完全的。我们可以使用迟到元素更新已经计算完的窗口结果。</p>
</div>
<div class="paragraph">
<p>如果我们要求一个operator支持重新计算和更新已经发出的结果，就需要在第一次发出结果以后也要保存之前所有的状态。但显然我们不能一直保存所有的状态，肯定会在某一个时间点将状态清空，而一旦状态被清空，结果就再也不能重新计算或者更新了。而迟到的元素只能被抛弃或者发送到侧输出流。</p>
</div>
<div class="paragraph">
<p>window operator API提供了方法来明确声明我们要等待迟到元素。当使用event-time window，我们可以指定一个时间段叫做allowed lateness。window operator如果设置了allowed lateness，这个window operator在水位线没过窗口结束时间时也将不会删除窗口和窗口中的状态。窗口会在一段时间内(allowed lateness设置的)保留所有的元素。</p>
</div>
<div class="paragraph">
<p>当迟到元素在allowed lateness时间内到达时，这个迟到元素会被实时处理并发送到触发器(trigger)。当水位线没过了窗口结束时间+allowed lateness时间时，窗口会被删除，并且所有后来的迟到的元素都会被丢弃。</p>
</div>
<div class="paragraph">
<p>Allowed lateness可以使用allowedLateness()方法来指定，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">val</span> <span class="tok-n">readings</span><span class="tok-k">:</span> <span class="tok-kt">DataStream</span><span class="tok-o">[</span><span class="tok-kt">SensorReading</span><span class="tok-o">]</span> <span class="tok-k">=</span> <span class="tok-o">???</span>

<span class="tok-k">val</span> <span class="tok-n">countPer10Secs</span><span class="tok-k">:</span> <span class="tok-kt">DataStream</span><span class="tok-o">[(</span><span class="tok-kt">String</span>, <span class="tok-kt">Long</span>, <span class="tok-kt">Int</span>, <span class="tok-kt">String</span><span class="tok-o">)]</span> <span class="tok-k">=</span> <span class="tok-n">readings</span>
  <span class="tok-o">.</span><span class="tok-n">keyBy</span><span class="tok-o">(</span><span class="tok-k">_</span><span class="tok-o">.</span><span class="tok-n">id</span><span class="tok-o">)</span>
  <span class="tok-o">.</span><span class="tok-n">timeWindow</span><span class="tok-o">(</span><span class="tok-nc">Time</span><span class="tok-o">.</span><span class="tok-n">seconds</span><span class="tok-o">(</span><span class="tok-mi">10</span><span class="tok-o">))</span>
  <span class="tok-c1">// process late readings for 5 additional seconds</span>
  <span class="tok-o">.</span><span class="tok-n">allowedLateness</span><span class="tok-o">(</span><span class="tok-nc">Time</span><span class="tok-o">.</span><span class="tok-n">seconds</span><span class="tok-o">(</span><span class="tok-mi">5</span><span class="tok-o">))</span>
  <span class="tok-c1">// count readings and update results if late readings arrive</span>
  <span class="tok-o">.</span><span class="tok-n">process</span><span class="tok-o">(</span><span class="tok-k">new</span> <span class="tok-nc">UpdatingWindowCountFunction</span><span class="tok-o">)</span>

  <span class="tok-cm">/** A counting WindowProcessFunction that distinguishes between</span>
<span class="tok-cm">  * first results and updates. */</span>
<span class="tok-k">class</span> <span class="tok-nc">UpdatingWindowCountFunction</span>
    <span class="tok-k">extends</span> <span class="tok-nc">ProcessWindowFunction</span><span class="tok-o">[</span>
            <span class="tok-kt">SensorReading</span>, <span class="tok-o">(</span><span class="tok-kt">String</span>, <span class="tok-kt">Long</span>, <span class="tok-kt">Int</span>, <span class="tok-kt">String</span><span class="tok-o">)</span>, <span class="tok-kt">String</span>, <span class="tok-kt">TimeWindow</span><span class="tok-o">]</span> <span class="tok-o">{</span>

  <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">process</span><span class="tok-o">(</span>
      <span class="tok-n">id</span><span class="tok-k">:</span> <span class="tok-kt">String</span><span class="tok-o">,</span>
      <span class="tok-n">ctx</span><span class="tok-k">:</span> <span class="tok-kt">Context</span><span class="tok-o">,</span>
      <span class="tok-n">elements</span><span class="tok-k">:</span> <span class="tok-kt">Iterable</span><span class="tok-o">[</span><span class="tok-kt">SensorReading</span><span class="tok-o">],</span>
      <span class="tok-n">out</span><span class="tok-k">:</span> <span class="tok-kt">Collector</span><span class="tok-o">[(</span><span class="tok-kt">String</span>, <span class="tok-kt">Long</span>, <span class="tok-kt">Int</span>, <span class="tok-kt">String</span><span class="tok-o">)])</span><span class="tok-k">:</span> <span class="tok-kt">Unit</span> <span class="tok-o">=</span> <span class="tok-o">{</span>

    <span class="tok-c1">// count the number of readings</span>
    <span class="tok-k">val</span> <span class="tok-n">cnt</span> <span class="tok-k">=</span> <span class="tok-n">elements</span><span class="tok-o">.</span><span class="tok-n">count</span><span class="tok-o">(</span><span class="tok-k">_</span> <span class="tok-k">=&gt;</span> <span class="tok-kc">true</span><span class="tok-o">)</span>

    <span class="tok-c1">// state to check if this is the first evaluation of the window or not</span>
    <span class="tok-k">val</span> <span class="tok-n">isUpdate</span> <span class="tok-k">=</span> <span class="tok-n">ctx</span><span class="tok-o">.</span><span class="tok-n">windowState</span><span class="tok-o">.</span><span class="tok-n">getState</span><span class="tok-o">(</span>
      <span class="tok-k">new</span> <span class="tok-nc">ValueStateDescriptor</span><span class="tok-o">[</span><span class="tok-kt">Boolean</span><span class="tok-o">](</span><span class="tok-s">&quot;isUpdate&quot;</span><span class="tok-o">,</span> <span class="tok-nc">Types</span><span class="tok-o">.</span><span class="tok-n">of</span><span class="tok-o">[</span><span class="tok-kt">Boolean</span><span class="tok-o">]))</span>

    <span class="tok-k">if</span> <span class="tok-o">(!</span><span class="tok-n">isUpdate</span><span class="tok-o">.</span><span class="tok-n">value</span><span class="tok-o">())</span> <span class="tok-o">{</span>
      <span class="tok-c1">// first evaluation, emit first result</span>
      <span class="tok-n">out</span><span class="tok-o">.</span><span class="tok-n">collect</span><span class="tok-o">((</span><span class="tok-n">id</span><span class="tok-o">,</span> <span class="tok-n">ctx</span><span class="tok-o">.</span><span class="tok-n">window</span><span class="tok-o">.</span><span class="tok-n">getEnd</span><span class="tok-o">,</span> <span class="tok-n">cnt</span><span class="tok-o">,</span> <span class="tok-s">&quot;first&quot;</span><span class="tok-o">))</span>
      <span class="tok-n">isUpdate</span><span class="tok-o">.</span><span class="tok-n">update</span><span class="tok-o">(</span><span class="tok-kc">true</span><span class="tok-o">)</span>
    <span class="tok-o">}</span> <span class="tok-k">else</span> <span class="tok-o">{</span>
      <span class="tok-c1">// not the first evaluation, emit an update</span>
      <span class="tok-n">out</span><span class="tok-o">.</span><span class="tok-n">collect</span><span class="tok-o">((</span><span class="tok-n">id</span><span class="tok-o">,</span> <span class="tok-n">ctx</span><span class="tok-o">.</span><span class="tok-n">window</span><span class="tok-o">.</span><span class="tok-n">getEnd</span><span class="tok-o">,</span> <span class="tok-n">cnt</span><span class="tok-o">,</span> <span class="tok-s">&quot;update&quot;</span><span class="tok-o">))</span>
    <span class="tok-o">}</span>
  <span class="tok-o">}</span>
<span class="tok-o">}</span></code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_有状态的计算">9. 有状态的计算</h2>
<div class="sectionbody">
<div class="paragraph">
<p>流式计算分为无状态和有状态两种情况。无状态的计算观察每个独立事件，并根据最后一个事件输出结果。例如，流处理应用程序从传感器接收温度读数，并在温度超过90度时发出警告。有状态的计算则会基于多个事件输出结果。以下是一些例子。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>所有类型的窗口。例如，计算过去一小时的平均温度，就是有状态的计算。</p>
</li>
<li>
<p>所有用于复杂事件处理的状态机。例如，若在一分钟内收到两个相差20度以上的温度读数，则发出警告，这是有状态的计算。</p>
</li>
<li>
<p>流与流之间的所有关联操作，以及流与静态表或动态表之间的关联操作，都是有状态的计算。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>下图展示了无状态流处理和有状态流处理的主要区别。无状态流处理分别接收每条记录(图中的黑条)，然后根据最新输入的记录生成输出记录(白条)。有状态流处理会维护状态(根据每条输入记录进行更新)，并基于最新输入的记录和当前的状态值生成输出记录(灰条)。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/statevsunstate.png" alt="statevsunstate">
</div>
</div>
<div class="paragraph">
<p>无状态流处理与有状态流处理的区别。输入记录由黑条表示。无状态流处理每次只转换一条输入记录，并且仅根据最新的输入记录输出结果(白条)。有状态 流处理维护所有已处理记录的状态值，并根据每条新输入的记录更新状态，因此输出记录(灰条)反映的是综合考虑多个事件之后的结果。</p>
</div>
<div class="paragraph">
<p>尽管无状态的计算很重要，但是流处理对有状态的计算更感兴趣。事实上，正确地实现有状态的计算比实现无状态的计算难得多。旧的流处理系统并不支持有状态的计算，而新一代的流处理系统则将状态及其正确性视为重中之重。</p>
</div>
<div class="sect2">
<h3 id="_一致性">9.1. 一致性</h3>
<div class="paragraph">
<p>当在分布式系统中引入状态时，自然也引入了一致性问题。一致性实际上是"正确性级别"的另一种说法，即在成功处理故障并恢复之后得到的结果，与没有发生任何故障时得到的结果相比，前者有多正确? 举例来说，假设要对最近一小时登录的用户计数。在系统经历故障之后，计数结果是多少? 在流处理中，一致性分为3个级别。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>at-most-once: 这其实是没有正确性保障的委婉说法——故障发生之后，计数结果可能丢失。同样的还有udp。</p>
</li>
<li>
<p>at-least-once: 这表示计数结果可能大于正确值，但绝不会小于正确值。也就是说，计数程序在发生故障后可能多算，但是绝不会少算。</p>
</li>
<li>
<p>exactly-once: 这指的是系统保证在发生故障后得到的计数结果与正确值一致。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>曾经，at-least-once非常流行。第一代流处理器(如Storm和Samza)刚问世时只保证at-least-once，原因有二。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>保证exactly-once的系统实现起来更复杂。这在基础架构层(决定什么代表正确，以及exactly-once的范围是什么)和实现层都很有挑战性。</p>
</li>
<li>
<p>流处理系统的早期用户愿意接受框架的局限性，并在应用层想办法弥补(例如使应用程序具有幂等性，或者用批量计算层再做一遍计算)。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>最先保证exactly-once的系统(Storm Trident和Spark Streaming)在性能和表现力这两个方面付出了很大的代价。为了保证exactly-once，这些系统无法单独地对每条记录运用应用逻辑，而是同时处理多条(一批)记录，保证对每一批的处理要么全部成功，要么全部失败。这就导致在得到结果前，必须等待一批记录处理结束。因此，用户经常不得不使用两个流处理框架(一个用来保证exactly-once，另一个用来对每个元素做低延迟处理)，结果使基础设施更加复杂。曾经，用户不得不在保证exactly-once与获得低延迟和效率之间权衡利弊。Flink避免了这种权衡。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Flink的一个重大价值在于，它既保证了exactly-once，也具有低延迟和高吞吐的处理能力。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>从根本上说，Flink通过使自身满足所有需求来避免权衡，它是业界的一次意义重大的技术飞跃。尽管这在外行看来很神奇，但是一旦了解，就会恍然大悟。</p>
</div>
</div>
<div class="sect2">
<h3 id="_检查点_保证exactly_once">9.2. 检查点: 保证exactly-once</h3>
<div class="paragraph">
<p>Flink如何保证exactly-once呢? 它使用一种被称为"检查点"的特性，在出现故障时将系统重置回正确状态。下面通过简单的类比来解释检查点的作用。</p>
</div>
<div class="paragraph">
<p>假设你和两位朋友正在数项链上有多少颗珠子，如下图所示。你捏住珠子，边数边拨，每拨过一颗珠子就给总数加一。你的朋友也这样数他们手中的珠子。当你分神忘记数到哪里时，怎么办呢? 如果项链上有很多珠子，你显然不想从头再数一遍，尤其是当三人的速度不一样却又试图合作的时候，更是如此(比如想记录前一分钟三人一共数了多少颗珠子，回想一下一分钟滚动窗口)。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/balls.png" alt="balls">
</div>
</div>
<div class="paragraph">
<p>于是，你想了一个更好的办法: 在项链上每隔一段就松松地系上一根有色皮筋，将珠子分隔开; 当珠子被拨动的时候，皮筋也可以被拨动; 然后，你安排一个助手，让他在你和朋友拨到皮筋时记录总数。用这种方法，当有人数错时，就不必从头开始数。相反，你向其他人发出错误警示，然后你们都从上一根皮筋处开始重数，助手则会告诉每个人重数时的起始数值，例如在粉色皮筋处的数值是多少。</p>
</div>
<div class="paragraph">
<p>Flink检查点的作用就类似于皮筋标记。数珠子这个类比的关键点是: 对于指定的皮筋而言，珠子的相对位置是确定的; 这让皮筋成为重新计数的参考点。总状态(珠子的总数)在每颗珠子被拨动之后更新一次，助手则会保存与每根皮筋对应的检查点状态，如当遇到粉色皮筋时一共数了多少珠子，当遇到橙色皮筋时又是多少。当问题出现时，这种方法使得重新计数变得简单。</p>
</div>
<div class="paragraph">
<p>Flink检查点的核心作用是确保状态正确，即使遇到程序中断，也要正确。记住这一基本点之后，我们用一个例子来看检查点是如何运行的。Flink为用户提供了用来定义状态的工具。例如，以下这个Scala程序按照输入记录的第一个字段(一个字符串)进行分组并维护第二个字段的计数状态。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">val</span> <span class="tok-n">stream</span><span class="tok-k">:</span> <span class="tok-kt">DataStream</span><span class="tok-o">[(</span><span class="tok-kt">String</span>, <span class="tok-kt">Int</span><span class="tok-o">)]</span> <span class="tok-k">=</span> <span class="tok-o">...</span>
<span class="tok-k">val</span> <span class="tok-n">counts</span><span class="tok-k">:</span> <span class="tok-kt">DataStream</span><span class="tok-o">[(</span><span class="tok-kt">String</span>, <span class="tok-kt">Int</span><span class="tok-o">)]</span> <span class="tok-k">=</span> <span class="tok-n">stream</span>
  <span class="tok-o">.</span><span class="tok-n">keyBy</span><span class="tok-o">(</span><span class="tok-n">record</span> <span class="tok-k">=&gt;</span> <span class="tok-n">record</span><span class="tok-o">.</span><span class="tok-n">_1</span><span class="tok-o">)</span>
  <span class="tok-o">.</span><span class="tok-n">mapWithState</span><span class="tok-o">((</span><span class="tok-n">in</span><span class="tok-k">:</span> <span class="tok-o">(</span><span class="tok-kt">String</span><span class="tok-o">,</span> <span class="tok-kt">Int</span><span class="tok-o">),</span> <span class="tok-n">count</span><span class="tok-k">:</span> <span class="tok-kt">Option</span><span class="tok-o">[</span><span class="tok-kt">Int</span><span class="tok-o">])</span> <span class="tok-k">=&gt;</span>
    <span class="tok-n">count</span> <span class="tok-k">match</span> <span class="tok-o">{</span>
      <span class="tok-k">case</span> <span class="tok-nc">Some</span><span class="tok-o">(</span><span class="tok-n">c</span><span class="tok-o">)</span> <span class="tok-k">=&gt;</span> <span class="tok-o">(</span> <span class="tok-o">(</span><span class="tok-n">in</span><span class="tok-o">.</span><span class="tok-n">_1</span><span class="tok-o">,</span> <span class="tok-n">c</span> <span class="tok-o">+</span> <span class="tok-n">in</span><span class="tok-o">.</span><span class="tok-n">_2</span><span class="tok-o">),</span> <span class="tok-nc">Some</span><span class="tok-o">(</span><span class="tok-n">c</span> <span class="tok-o">+</span> <span class="tok-n">in</span><span class="tok-o">.</span><span class="tok-n">_2</span><span class="tok-o">)</span> <span class="tok-o">)</span>
      <span class="tok-k">case</span> <span class="tok-nc">None</span> <span class="tok-k">=&gt;</span> <span class="tok-o">(</span> <span class="tok-o">(</span><span class="tok-n">in</span><span class="tok-o">.</span><span class="tok-n">_1</span><span class="tok-o">,</span> <span class="tok-n">in</span><span class="tok-o">.</span><span class="tok-n">_2</span><span class="tok-o">),</span> <span class="tok-nc">Some</span><span class="tok-o">(</span><span class="tok-n">in</span><span class="tok-o">.</span><span class="tok-n">_2</span><span class="tok-o">)</span> <span class="tok-o">)</span>
<span class="tok-o">})</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>该程序有两个算子: keyBy算子用来将记录按照第一个元素(一个字符串)进行分组，根据该key将数据进行重新分区，然后将记录再发送给下一个算子: 有状态的map算子(mapWithState)。map算子在接收到每个元素后，将输入记录的第二个字段的数据加到现有总数中，再将更新过的元素发射出去。下图表示程序的初始状态: 输入流中的6条记录被检查点屏障(checkpoint barrier)隔开，所有的map算子状态均为0(计数还未开始)。所有key为a的记录将被顶层的map算子处理，所有key为b的记录将被中间层的map算子处理，所有key为c的记录则将被底层的map算子处理。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/ckpt1.png" alt="ckpt1">
</div>
</div>
<div class="paragraph">
<p>程序的初始状态。注意，a、b、c三组的初始计数状态都是0，即三个圆柱上的值。ckpt表示检查点屏障。每条记录在处理顺序上严格地遵守在检查点之前或之后的规定，例如["b",2]在检查点之前被处理，["a",2]则在检查点之后被处理</p>
</div>
<div class="paragraph">
<p>当该程序处理输入流中的6条记录时，涉及的操作遍布3个并行实例(节点、CPU内核等)。那么，检查点该如何保证exactly-once呢?</p>
</div>
<div class="paragraph">
<p>检查点屏障和普通记录类似。它们由算子处理，但并不参与计算，而是会触发与检查点相关的行为。当读取输入流的数据源(在本例中与keyBy算子内联)遇到检查点屏障时，它将其在输入流中的位置保存到持久化存储中。如果输入流来自消息传输系统(Kafka)，这个位置就是偏移量。Flink的存储机制是插件化的，持久化存储可以是分布式文件系统，如HDFS。下图展示了这个过程。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/ckpt2.png" alt="ckpt2">
</div>
</div>
<div class="paragraph">
<p>当Flink数据源(在本例中与keyBy算子内联)遇到检查点屏障时，它会将其在输入流中的位置保存到持久化存储中。这让 Flink可以根据该位置重启输入</p>
</div>
<div class="paragraph">
<p>检查点屏障像普通记录一样在算子之间流动。当map算子处理完前3条记录并收到检查点屏障时，它们会将状态以异步的方式写入持久化存储，如下图所示。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/ckpt3.png" alt="ckpt3">
</div>
</div>
<div class="paragraph">
<p>位于检查点之前的所有记录(["b",2]、["b",3]和["c",1])被map算子处理之后的情况。此时，持久化存储已经备份了检查点屏障在输入流中的位置(备份操作发生在检查点屏障被输入算子处理的时候)。map算子接着开始处理检查点屏障，并触发将状态异步备份到稳定存储中这个动作</p>
</div>
<div class="paragraph">
<p>当map算子的状态备份和检查点屏障的位置备份被确认之后，该检查点操作就可以被标记为完成，如下图所示。我们在无须停止或者阻断计算的条件下，在一个逻辑时间点(对应检查点屏障在输入流中的位置)为计算状态拍了快照。通过确保备份的状态和位置指向同一个逻辑时间点，后文将解释如何基于备份恢复计算，从而保证exactly-once。值得注意的是，当没有出现故障时，Flink检查点的开销极小，检查点操作的速度由持久化存储的可用带宽决定。回顾数珠子的例子: 除了因为数错而需要用到皮筋之外，皮筋会被很快地拨过。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/ckpt4.png" alt="ckpt4">
</div>
</div>
<div class="paragraph">
<p>检查点操作完成，状态和位置均已备份到稳定存储中。输入流中的所有记录都已处理完成。值得注意的是，备份的状态值与实际的状态值是不同的。备份反映的是检查点的状态</p>
</div>
<div class="paragraph">
<p>如果检查点操作失败，Flink会丢弃该检查点并继续正常执行，因为之后的某一个检查点可能会成功。虽然恢复时间可能更长，但是对于状态的保证依旧很有力。只有在一系列连续的检查点操作失败之后，Flink才会抛出错误，因为这通常预示着发生了严重且持久的错误。</p>
</div>
<div class="paragraph">
<p>现在来看看下图所示的情况: 检查点操作已经完成，但故障紧随其后。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/ckpt5.png" alt="ckpt5">
</div>
</div>
<div class="paragraph">
<p>故障紧跟检查点，导致最底部的实例丢失</p>
</div>
<div class="paragraph">
<p>在这种情况下，Flink会重新拓扑(可能会获取新的执行资源)，将输入流倒回到上一个检查点，然后恢复状态值并从该处开始继续计算。在本例中，["a",2]、["a",2]和["c",2]这几条记录将被重播。</p>
</div>
<div class="paragraph">
<p>下图展示了这一重新处理过程。从上一个检查点开始重新计算，可以保证在剩下的记录被处理之后，得到的map算子的状态值与没有发生故障时的状态值一致。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/ckpt6.png" alt="ckpt6">
</div>
</div>
<div class="paragraph">
<p>Flink将输入流倒回到上一个检查点屏障的位置，同时恢复map算子的状态值。然后，Flink从此处开始重新处理。这样做保证了在记录被处理之后，map算子的状态值与没有发生故障时的一致</p>
</div>
<div class="paragraph">
<p>Flink检查点算法的正式名称是异步屏障快照(asynchronous barrier snapshotting)。该算法大致基于Chandy-Lamport分布式快照算法。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
检查点是Flink最有价值的创新之一，因为它使Flink可以保证exactly-once，并且不需要牺牲性能。
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_stateful_operators_and_applications">9.3. Stateful Operators and Applications</h3>
<div class="paragraph">
<p>Flink内置的很多算子，数据源source，数据存储sink都是有状态的，流中的数据都是buffer records，会保存一定的元素或者元数据。例如: ProcessWindowFunction会缓存输入流的数据，ProcessFunction会保存设置的定时器信息等等。</p>
</div>
<div class="sect3">
<h4 id="_实现stateful_functions">9.3.1. 实现stateful functions</h4>
<div class="paragraph">
<p>函数一般有两种类型的状态：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>keyed state</p>
</li>
<li>
<p>operator state</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="_在runtimecontext中声明keyed_state">在RuntimeContext中声明Keyed State</h5>
<div class="ulist">
<ul>
<li>
<p>keyed state很类似于一个分布式的key-value map数据结构</p>
</li>
<li>
<p>keyed state只能用于KeyedStream(keyBy算子)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Flink支持以下数据类型：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>ValueState[T]保存单个的值，值的类型为T。</p>
<div class="ulist">
<ul>
<li>
<p>get操作: ValueState.value()</p>
</li>
<li>
<p>set操作: ValueState.update(value: T)</p>
</li>
</ul>
</div>
</li>
<li>
<p>ListState[T]保存一个列表，列表里的元素的数据类型为T。基本操作如下：</p>
<div class="ulist">
<ul>
<li>
<p>ListState.add(value: T)</p>
</li>
<li>
<p>ListState.addAll(values: java.util.List[T])</p>
</li>
<li>
<p>ListState.get()返回Iterable[T]</p>
</li>
<li>
<p>ListState.update(values: java.util.List[T])</p>
</li>
</ul>
</div>
</li>
<li>
<p>MapState[K, V]保存Key-Value对。</p>
<div class="ulist">
<ul>
<li>
<p>MapState.get(key: K)</p>
</li>
<li>
<p>MapState.put(key: K, value: V)</p>
</li>
<li>
<p>MapState.contains(key: K)</p>
</li>
<li>
<p>MapState.remove(key: K)</p>
</li>
</ul>
</div>
</li>
<li>
<p>ReducingState[T]</p>
</li>
<li>
<p>AggregatingState[I, O]</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>State.clear()是清空操作。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">val</span> <span class="tok-n">sensorData</span><span class="tok-k">:</span> <span class="tok-kt">DataStream</span><span class="tok-o">[</span><span class="tok-kt">SensorReading</span><span class="tok-o">]</span> <span class="tok-k">=</span> <span class="tok-o">...</span>
<span class="tok-k">val</span> <span class="tok-n">keyedData</span><span class="tok-k">:</span> <span class="tok-kt">KeyedStream</span><span class="tok-o">[</span><span class="tok-kt">SensorReading</span>, <span class="tok-kt">String</span><span class="tok-o">]</span> <span class="tok-k">=</span> <span class="tok-n">sensorData</span><span class="tok-o">.</span><span class="tok-n">keyBy</span><span class="tok-o">(</span><span class="tok-k">_</span><span class="tok-o">.</span><span class="tok-n">id</span><span class="tok-o">)</span>

<span class="tok-k">val</span> <span class="tok-n">alerts</span><span class="tok-k">:</span> <span class="tok-kt">DataStream</span><span class="tok-o">[(</span><span class="tok-kt">String</span>, <span class="tok-kt">Double</span>, <span class="tok-kt">Double</span><span class="tok-o">)]</span> <span class="tok-k">=</span> <span class="tok-n">keyedData</span>
  <span class="tok-o">.</span><span class="tok-n">flatMap</span><span class="tok-o">(</span><span class="tok-k">new</span> <span class="tok-nc">TemperatureAlertFunction</span><span class="tok-o">(</span><span class="tok-mf">1.7</span><span class="tok-o">))</span>

<span class="tok-k">class</span> <span class="tok-nc">TemperatureAlertFunction</span><span class="tok-o">(</span><span class="tok-k">val</span> <span class="tok-n">threshold</span><span class="tok-k">:</span> <span class="tok-kt">Double</span><span class="tok-o">)</span> <span class="tok-k">extends</span> <span class="tok-nc">RichFlatMapFunction</span><span class="tok-o">[</span><span class="tok-kt">SensorReading</span>, <span class="tok-o">(</span><span class="tok-kt">String</span>, <span class="tok-kt">Double</span>, <span class="tok-kt">Double</span><span class="tok-o">)]</span> <span class="tok-o">{</span>
  <span class="tok-k">private</span> <span class="tok-k">var</span> <span class="tok-n">lastTempState</span><span class="tok-k">:</span> <span class="tok-kt">ValueState</span><span class="tok-o">[</span><span class="tok-kt">Double</span><span class="tok-o">]</span> <span class="tok-k">=</span> <span class="tok-k">_</span>

  <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">open</span><span class="tok-o">(</span><span class="tok-n">parameters</span><span class="tok-k">:</span> <span class="tok-kt">Configuration</span><span class="tok-o">)</span><span class="tok-k">:</span> <span class="tok-kt">Unit</span> <span class="tok-o">=</span> <span class="tok-o">{</span>
    <span class="tok-k">val</span> <span class="tok-n">lastTempDescriptor</span> <span class="tok-k">=</span> <span class="tok-k">new</span> <span class="tok-nc">ValueStateDescriptor</span><span class="tok-o">[</span><span class="tok-kt">Double</span><span class="tok-o">](</span><span class="tok-s">&quot;lastTemp&quot;</span><span class="tok-o">,</span> <span class="tok-n">classOf</span><span class="tok-o">[</span><span class="tok-kt">Double</span><span class="tok-o">])</span>

    <span class="tok-n">lastTempState</span> <span class="tok-k">=</span> <span class="tok-n">getRuntimeContext</span><span class="tok-o">.</span><span class="tok-n">getState</span><span class="tok-o">[</span><span class="tok-kt">Double</span><span class="tok-o">](</span><span class="tok-n">lastTempDescriptor</span><span class="tok-o">)</span>
  <span class="tok-o">}</span>

  <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">flatMap</span><span class="tok-o">(</span><span class="tok-n">reading</span><span class="tok-k">:</span> <span class="tok-kt">SensorReading</span><span class="tok-o">,</span>
                       <span class="tok-n">out</span><span class="tok-k">:</span> <span class="tok-kt">Collector</span><span class="tok-o">[(</span><span class="tok-kt">String</span>, <span class="tok-kt">Double</span>, <span class="tok-kt">Double</span><span class="tok-o">)])</span><span class="tok-k">:</span> <span class="tok-kt">Unit</span> <span class="tok-o">=</span> <span class="tok-o">{</span>
    <span class="tok-k">val</span> <span class="tok-n">lastTemp</span> <span class="tok-k">=</span> <span class="tok-n">lastTempState</span><span class="tok-o">.</span><span class="tok-n">value</span><span class="tok-o">()</span>
    <span class="tok-k">val</span> <span class="tok-n">tempDiff</span> <span class="tok-k">=</span> <span class="tok-o">(</span><span class="tok-n">reading</span><span class="tok-o">.</span><span class="tok-n">temperature</span> <span class="tok-o">-</span> <span class="tok-n">lastTemp</span><span class="tok-o">).</span><span class="tok-n">abs</span>
    <span class="tok-k">if</span> <span class="tok-o">(</span><span class="tok-n">tempDiff</span> <span class="tok-o">&gt;</span> <span class="tok-n">threshold</span><span class="tok-o">)</span> <span class="tok-o">{</span>
      <span class="tok-n">out</span><span class="tok-o">.</span><span class="tok-n">collect</span><span class="tok-o">((</span><span class="tok-n">reading</span><span class="tok-o">.</span><span class="tok-n">id</span><span class="tok-o">,</span> <span class="tok-n">reading</span><span class="tok-o">.</span><span class="tok-n">temperature</span><span class="tok-o">,</span> <span class="tok-n">tempDiff</span><span class="tok-o">))</span>
    <span class="tok-o">}</span>
    <span class="tok-k">this</span><span class="tok-o">.</span><span class="tok-n">lastTempState</span><span class="tok-o">.</span><span class="tok-n">update</span><span class="tok-o">(</span><span class="tok-n">reading</span><span class="tok-o">.</span><span class="tok-n">temperature</span><span class="tok-o">)</span>
  <span class="tok-o">}</span>
<span class="tok-o">}</span></code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>通过RuntimeContext注册StateDescriptor。StateDescriptor以状态state的名字和存储的数据类型为参数。数据类型必须指定，因为Flink需要选择合适的序列化器。</p>
</li>
<li>
<p>在open()方法中创建state变量。注意复习之前的RichFunction相关知识。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>当一个函数注册了StateDescriptor描述符，Flink会检查状态后端是否已经存在这个状态。这种情况通常出现在应用挂掉要从检查点或者保存点恢复的时候。在这两种情况下，Flink会将注册的状态连接到已经存在的状态。如果不存在状态，则初始化一个空的状态。</p>
</div>
<div class="paragraph">
<p>使用FlatMap with keyed ValueState的快捷方式flatMapWithState实现以上需求。还记得之前的例子mapWithState吗？</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">val</span> <span class="tok-n">alerts</span><span class="tok-k">:</span> <span class="tok-kt">DataStream</span><span class="tok-o">[(</span><span class="tok-kt">String</span>, <span class="tok-kt">Double</span>, <span class="tok-kt">Double</span><span class="tok-o">)]</span> <span class="tok-k">=</span> <span class="tok-n">keyedSensorData</span>
  <span class="tok-o">.</span><span class="tok-n">flatMapWithState</span><span class="tok-o">[(</span><span class="tok-kt">String</span>, <span class="tok-kt">Double</span>, <span class="tok-kt">Double</span><span class="tok-o">)</span>, <span class="tok-kt">Double</span><span class="tok-o">]</span> <span class="tok-o">{</span>
    <span class="tok-k">case</span> <span class="tok-o">(</span><span class="tok-n">in</span><span class="tok-k">:</span> <span class="tok-kt">SensorReading</span><span class="tok-o">,</span> <span class="tok-nc">None</span><span class="tok-o">)</span> <span class="tok-k">=&gt;</span>
      <span class="tok-c1">// no previous temperature defined. Just update the last temperature</span>
      <span class="tok-o">(</span><span class="tok-nc">List</span><span class="tok-o">.</span><span class="tok-n">empty</span><span class="tok-o">,</span> <span class="tok-nc">Some</span><span class="tok-o">(</span><span class="tok-n">in</span><span class="tok-o">.</span><span class="tok-n">temperature</span><span class="tok-o">))</span>
    <span class="tok-k">case</span> <span class="tok-o">(</span><span class="tok-n">r</span><span class="tok-k">:</span> <span class="tok-kt">SensorReading</span><span class="tok-o">,</span> <span class="tok-n">lastTemp</span><span class="tok-k">:</span> <span class="tok-kt">Some</span><span class="tok-o">[</span><span class="tok-kt">Double</span><span class="tok-o">])</span> <span class="tok-k">=&gt;</span>
      <span class="tok-c1">// compare temperature difference with threshold</span>
      <span class="tok-k">val</span> <span class="tok-n">tempDiff</span> <span class="tok-k">=</span> <span class="tok-o">(</span><span class="tok-n">r</span><span class="tok-o">.</span><span class="tok-n">temperature</span> <span class="tok-o">-</span> <span class="tok-n">lastTemp</span><span class="tok-o">.</span><span class="tok-n">get</span><span class="tok-o">).</span><span class="tok-n">abs</span>
      <span class="tok-k">if</span> <span class="tok-o">(</span><span class="tok-n">tempDiff</span> <span class="tok-o">&gt;</span> <span class="tok-mf">1.7</span><span class="tok-o">)</span> <span class="tok-o">{</span>
        <span class="tok-c1">// threshold exceeded. Emit an alert and update the last temperature</span>
        <span class="tok-o">(</span><span class="tok-nc">List</span><span class="tok-o">((</span><span class="tok-n">r</span><span class="tok-o">.</span><span class="tok-n">id</span><span class="tok-o">,</span> <span class="tok-n">r</span><span class="tok-o">.</span><span class="tok-n">temperature</span><span class="tok-o">,</span> <span class="tok-n">tempDiff</span><span class="tok-o">)),</span> <span class="tok-nc">Some</span><span class="tok-o">(</span><span class="tok-n">r</span><span class="tok-o">.</span><span class="tok-n">temperature</span><span class="tok-o">))</span>
      <span class="tok-o">}</span> <span class="tok-k">else</span> <span class="tok-o">{</span>
        <span class="tok-c1">// threshold not exceeded. Just update the last temperature</span>
        <span class="tok-o">(</span><span class="tok-nc">List</span><span class="tok-o">.</span><span class="tok-n">empty</span><span class="tok-o">,</span> <span class="tok-nc">Some</span><span class="tok-o">(</span><span class="tok-n">r</span><span class="tok-o">.</span><span class="tok-n">temperature</span><span class="tok-o">))</span>
      <span class="tok-o">}</span>
  <span class="tok-o">}</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_使用listcheckpointed接口来实现操作符的列表状态list_state">9.4. 使用ListCheckpointed接口来实现操作符的列表状态(List State)</h3>
<div class="paragraph">
<p>operator state会在operator的每一个并行实例中去维护。一个操作符并行实例上的所有事件都可以访问同一个状态。Flink支持三种操作符状态：list state, list union state, broadcast state。</p>
</div>
<div class="paragraph">
<p>一个函数可以实现ListCheckpointed接口来处理操作符list state。ListCheckpointed接口无法处理ValueState和ListState，因为这些状态是注册在状态后端的。操作符状态类似于成员变量，和状态后端的交互通过ListCheckpointed接口的回调函数实现。接口提供了两个方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-c1">// 返回函数状态的快照，返回值为列表</span>
<span class="tok-n">snapshotState</span><span class="tok-o">(</span><span class="tok-n">checkpointId</span><span class="tok-k">:</span> <span class="tok-kt">Long</span><span class="tok-o">,</span> <span class="tok-n">timestamp</span><span class="tok-k">:</span> <span class="tok-kt">Long</span><span class="tok-o">)</span><span class="tok-k">:</span> <span class="tok-kt">java.util.List</span><span class="tok-o">[</span><span class="tok-kt">T</span><span class="tok-o">]</span>
<span class="tok-c1">// 从列表恢复函数状态</span>
<span class="tok-n">restoreState</span><span class="tok-o">(</span><span class="tok-n">java</span><span class="tok-o">.</span><span class="tok-n">util</span><span class="tok-o">.</span><span class="tok-nc">List</span><span class="tok-o">[</span><span class="tok-kt">T</span><span class="tok-o">]</span> <span class="tok-n">state</span><span class="tok-o">)</span><span class="tok-k">:</span> <span class="tok-kt">Unit</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>当Flink触发stateful functon的一次checkpoint时，snapshotState()方法会被调用。方法接收两个参数，checkpointId为唯一的单调递增的检查点Id，timestamp为当master机器开始做检查点操作时的墙上时钟。方法必须返回序列化好的状态对象的列表。</p>
</div>
<div class="paragraph">
<p>当宕机程序从检查点或者保存点恢复时会调用restoreState()方法。restoreState使用snapshotState保存的列表来恢复。</p>
</div>
<div class="paragraph">
<p>下面的例子展示了如何实现ListCheckpointed接口。业务场景为：一个对每一个并行实例的超过阈值的温度的计数程序。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">class</span> <span class="tok-nc">HighTempCounter</span><span class="tok-o">(</span><span class="tok-k">val</span> <span class="tok-n">threshold</span><span class="tok-k">:</span> <span class="tok-kt">Double</span><span class="tok-o">)</span>
    <span class="tok-k">extends</span> <span class="tok-nc">RichFlatMapFunction</span><span class="tok-o">[</span><span class="tok-kt">SensorReading</span>, <span class="tok-o">(</span><span class="tok-kt">Int</span>, <span class="tok-kt">Long</span><span class="tok-o">)]</span>
    <span class="tok-k">with</span> <span class="tok-nc">ListCheckpointed</span><span class="tok-o">[</span><span class="tok-kt">java.lang.Long</span><span class="tok-o">]</span> <span class="tok-o">{</span>

  <span class="tok-c1">// index of the subtask</span>
  <span class="tok-k">private</span> <span class="tok-k">lazy</span> <span class="tok-k">val</span> <span class="tok-n">subtaskIdx</span> <span class="tok-k">=</span> <span class="tok-n">getRuntimeContext</span>
    <span class="tok-o">.</span><span class="tok-n">getIndexOfThisSubtask</span>
  <span class="tok-c1">// local count variable</span>
  <span class="tok-k">private</span> <span class="tok-k">var</span> <span class="tok-n">highTempCnt</span> <span class="tok-k">=</span> <span class="tok-mi">0L</span>

  <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">flatMap</span><span class="tok-o">(</span>
      <span class="tok-n">in</span><span class="tok-k">:</span> <span class="tok-kt">SensorReading</span><span class="tok-o">,</span>
      <span class="tok-n">out</span><span class="tok-k">:</span> <span class="tok-kt">Collector</span><span class="tok-o">[(</span><span class="tok-kt">Int</span>, <span class="tok-kt">Long</span><span class="tok-o">)])</span><span class="tok-k">:</span> <span class="tok-kt">Unit</span> <span class="tok-o">=</span> <span class="tok-o">{</span>
    <span class="tok-k">if</span> <span class="tok-o">(</span><span class="tok-n">in</span><span class="tok-o">.</span><span class="tok-n">temperature</span> <span class="tok-o">&gt;</span> <span class="tok-n">threshold</span><span class="tok-o">)</span> <span class="tok-o">{</span>
      <span class="tok-c1">// increment counter if threshold is exceeded</span>
      <span class="tok-n">highTempCnt</span> <span class="tok-o">+=</span> <span class="tok-mi">1</span>
      <span class="tok-c1">// emit update with subtask index and counter</span>
      <span class="tok-n">out</span><span class="tok-o">.</span><span class="tok-n">collect</span><span class="tok-o">((</span><span class="tok-n">subtaskIdx</span><span class="tok-o">,</span> <span class="tok-n">highTempCnt</span><span class="tok-o">))</span>
    <span class="tok-o">}</span>
  <span class="tok-o">}</span>

  <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">restoreState</span><span class="tok-o">(</span>
      <span class="tok-n">state</span><span class="tok-k">:</span> <span class="tok-kt">util.List</span><span class="tok-o">[</span><span class="tok-kt">java.lang.Long</span><span class="tok-o">])</span><span class="tok-k">:</span> <span class="tok-kt">Unit</span> <span class="tok-o">=</span> <span class="tok-o">{</span>
    <span class="tok-n">highTempCnt</span> <span class="tok-k">=</span> <span class="tok-mi">0</span>
    <span class="tok-c1">// restore state by adding all longs of the list</span>
    <span class="tok-k">for</span> <span class="tok-o">(</span><span class="tok-n">cnt</span> <span class="tok-k">&lt;-</span> <span class="tok-n">state</span><span class="tok-o">.</span><span class="tok-n">asScala</span><span class="tok-o">)</span> <span class="tok-o">{</span>
      <span class="tok-n">highTempCnt</span> <span class="tok-o">+=</span> <span class="tok-n">cnt</span>
    <span class="tok-o">}</span>
  <span class="tok-o">}</span>

  <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">snapshotState</span><span class="tok-o">(</span>
      <span class="tok-n">chkpntId</span><span class="tok-k">:</span> <span class="tok-kt">Long</span><span class="tok-o">,</span>
      <span class="tok-n">ts</span><span class="tok-k">:</span> <span class="tok-kt">Long</span><span class="tok-o">)</span><span class="tok-k">:</span> <span class="tok-kt">java.util.List</span><span class="tok-o">[</span><span class="tok-kt">java.lang.Long</span><span class="tok-o">]</span> <span class="tok-k">=</span> <span class="tok-o">{</span>
    <span class="tok-c1">// snapshot state as list with a single count</span>
    <span class="tok-n">java</span><span class="tok-o">.</span><span class="tok-n">util</span><span class="tok-o">.</span><span class="tok-nc">Collections</span><span class="tok-o">.</span><span class="tok-n">singletonList</span><span class="tok-o">(</span><span class="tok-n">highTempCnt</span><span class="tok-o">)</span>
  <span class="tok-o">}</span>
<span class="tok-o">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The function in the above example counts per parallel instance how many temperature measurements exceeded a configured threshold. The function uses operator state and has a single state variable for each parallel operator instance that is checkpointed and restored using the methods of the ListCheckpointed interface. Note that the ListCheckpointed interface is implemented in Java and expects a java.util.List instead of a Scala native list.</p>
</div>
<div class="paragraph">
<p>Looking at the example, you might wonder why operator state is handled as a list of state objects. As discussed in “Scaling Stateful Operators”, the list structure supports changing the parallelism of functions with operator state. In order to increase or decrease the parallelism of a function with operator state, the operator state needs to be redistributed to a larger or smaller number of task instances. This requires splitting or merging of state objects. Since the logic for splitting and merging of state is custom for every stateful function, this cannot be automatically done for arbitrary types of state.</p>
</div>
<div class="paragraph">
<p>By providing a list of state objects, functions with operator state can implement this logic using the snapshotState() and restoreState() methods. The snapshotState() method splits the operator state into multiple parts and the restoreState() method assembles the operator state from possibly multiple parts. When the state of a function is restored, the parts of the state are distributed among all parallel instances of the function and handed to the restoreState() method. If there are more parallel subtasks than state objects, some subtasks are started with no state, and the restoreState() method is called with an empty list.</p>
</div>
<div class="paragraph">
<p>Looking again at the HighTempCounter function in Example 7-4, we see that each parallel instance of the operator exposes its state as a list with a single entry. If we increased the parallelism of this operator, some of the new subtasks would be initialized with an empty state, and start counting from zero. In order to achieve better state distribution behavior when the HighTempCounter function is rescaled, we can implement the snapshotState() method so that it splits its count into multiple partial counts as shown in Example 7-5.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">snapshotState</span><span class="tok-o">(</span>
    <span class="tok-n">chkpntId</span><span class="tok-k">:</span> <span class="tok-kt">Long</span><span class="tok-o">,</span>
    <span class="tok-n">ts</span><span class="tok-k">:</span> <span class="tok-kt">Long</span><span class="tok-o">)</span><span class="tok-k">:</span> <span class="tok-kt">java.util.List</span><span class="tok-o">[</span><span class="tok-kt">java.lang.Long</span><span class="tok-o">]</span> <span class="tok-k">=</span> <span class="tok-o">{</span>
  <span class="tok-c1">// split count into ten partial counts</span>
  <span class="tok-k">val</span> <span class="tok-n">div</span> <span class="tok-k">=</span> <span class="tok-n">highTempCnt</span> <span class="tok-o">/</span> <span class="tok-mi">10</span>
  <span class="tok-k">val</span> <span class="tok-n">mod</span> <span class="tok-k">=</span> <span class="tok-o">(</span><span class="tok-n">highTempCnt</span> <span class="tok-o">%</span> <span class="tok-mi">10</span><span class="tok-o">).</span><span class="tok-n">toInt</span>
  <span class="tok-c1">// return count as ten parts</span>
  <span class="tok-o">(</span><span class="tok-nc">List</span><span class="tok-o">.</span><span class="tok-n">fill</span><span class="tok-o">(</span><span class="tok-n">mod</span><span class="tok-o">)(</span><span class="tok-k">new</span> <span class="tok-n">java</span><span class="tok-o">.</span><span class="tok-n">lang</span><span class="tok-o">.</span><span class="tok-nc">Long</span><span class="tok-o">(</span><span class="tok-n">div</span> <span class="tok-o">+</span> <span class="tok-mi">1</span><span class="tok-o">))</span> <span class="tok-o">++</span>
    <span class="tok-nc">List</span><span class="tok-o">.</span><span class="tok-n">fill</span><span class="tok-o">(</span><span class="tok-mi">10</span> <span class="tok-o">-</span> <span class="tok-n">mod</span><span class="tok-o">)(</span><span class="tok-k">new</span> <span class="tok-n">java</span><span class="tok-o">.</span><span class="tok-n">lang</span><span class="tok-o">.</span><span class="tok-nc">Long</span><span class="tok-o">(</span><span class="tok-n">div</span><span class="tok-o">))).</span><span class="tok-n">asJava</span>
<span class="tok-o">}</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_使用连接的广播状态using_connected_broadcast_state">9.5. 使用连接的广播状态(using connected broadcast state)</h3>
<div class="paragraph">
<p>一个常见的需求就是流应用需要将同样的事件分发到操作符的所有的并行实例中，而这样的分发操作还得是可恢复的。</p>
</div>
<div class="paragraph">
<p>我们举个例子：一条流是一个规则(比如5秒钟内连续两个超过阈值的温度)，另一条流是待匹配的流。也就是说，规则流和事件流。所以每一个操作符的并行实例都需要把规则流保存在操作符状态中。也就是说，规则流需要被广播到所有的并行实例中去。</p>
</div>
<div class="paragraph">
<p>在Flink中，这样的状态叫做广播状态(broadcast state)。广播状态和DataStream或者KeyedStream都可以做连接操作。</p>
</div>
<div class="paragraph">
<p>下面的例子实现了一个温度报警应用，应用有可以动态设定的阈值，动态设定通过广播流来实现。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">val</span> <span class="tok-n">sensorData</span><span class="tok-k">:</span> <span class="tok-kt">DataStream</span><span class="tok-o">[</span><span class="tok-kt">SensorReading</span><span class="tok-o">]</span> <span class="tok-k">=</span> <span class="tok-o">???</span>
<span class="tok-k">val</span> <span class="tok-n">thresholds</span><span class="tok-k">:</span> <span class="tok-kt">DataStream</span><span class="tok-o">[</span><span class="tok-kt">ThresholdUpdate</span><span class="tok-o">]</span> <span class="tok-k">=</span> <span class="tok-o">???</span>
<span class="tok-k">val</span> <span class="tok-n">keyedSensorData</span><span class="tok-k">:</span> <span class="tok-kt">KeyedStream</span><span class="tok-o">[</span><span class="tok-kt">SensorReading</span>, <span class="tok-kt">String</span><span class="tok-o">]</span> <span class="tok-k">=</span> <span class="tok-n">sensorData</span><span class="tok-o">.</span><span class="tok-n">keyBy</span><span class="tok-o">(</span><span class="tok-k">_</span><span class="tok-o">.</span><span class="tok-n">id</span><span class="tok-o">)</span>

<span class="tok-c1">// the descriptor of the broadcast state</span>
<span class="tok-k">val</span> <span class="tok-n">broadcastStateDescriptor</span> <span class="tok-k">=</span>
  <span class="tok-k">new</span> <span class="tok-nc">MapStateDescriptor</span><span class="tok-o">[</span><span class="tok-kt">String</span>, <span class="tok-kt">Double</span><span class="tok-o">](</span>
    <span class="tok-s">&quot;thresholds&quot;</span><span class="tok-o">,</span> <span class="tok-n">classOf</span><span class="tok-o">[</span><span class="tok-kt">String</span><span class="tok-o">],</span> <span class="tok-n">classOf</span><span class="tok-o">[</span><span class="tok-kt">Double</span><span class="tok-o">])</span>

<span class="tok-k">val</span> <span class="tok-n">broadcastThresholds</span><span class="tok-k">:</span> <span class="tok-kt">BroadcastStream</span><span class="tok-o">[</span><span class="tok-kt">ThresholdUpdate</span><span class="tok-o">]</span> <span class="tok-k">=</span> <span class="tok-n">thresholds</span>
  <span class="tok-o">.</span><span class="tok-n">broadcast</span><span class="tok-o">(</span><span class="tok-n">broadcastStateDescriptor</span><span class="tok-o">)</span>

<span class="tok-c1">// connect keyed sensor stream and broadcasted rules stream</span>
<span class="tok-k">val</span> <span class="tok-n">alerts</span><span class="tok-k">:</span> <span class="tok-kt">DataStream</span><span class="tok-o">[(</span><span class="tok-kt">String</span>, <span class="tok-kt">Double</span>, <span class="tok-kt">Double</span><span class="tok-o">)]</span> <span class="tok-k">=</span> <span class="tok-n">keyedSensorData</span>
  <span class="tok-o">.</span><span class="tok-n">connect</span><span class="tok-o">(</span><span class="tok-n">broadcastThresholds</span><span class="tok-o">)</span>
  <span class="tok-o">.</span><span class="tok-n">process</span><span class="tok-o">(</span><span class="tok-k">new</span> <span class="tok-nc">UpdatableTemperatureAlertFunction</span><span class="tok-o">())</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>带有广播状态的函数在应用到两条流上时分三个步骤：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>调用DataStream.broadcast()来创建BroadcastStream，定义一个或者多个MapStateDescriptor对象。</p>
</li>
<li>
<p>将BroadcastStream和DataStream/KeyedStream做connect操作。</p>
</li>
<li>
<p>在connected streams上调用KeyedBroadcastProcessFunction/BroadcastProcessFunction。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>下面的例子实现了动态设定温度阈值的功能。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">class</span> <span class="tok-nc">UpdatableTemperatureAlertFunction</span><span class="tok-o">()</span>
    <span class="tok-k">extends</span> <span class="tok-nc">KeyedBroadcastProcessFunction</span>
      <span class="tok-o">[</span><span class="tok-kt">String</span>, <span class="tok-kt">SensorReading</span>, <span class="tok-kt">ThresholdUpdate</span>, <span class="tok-o">(</span><span class="tok-kt">String</span>, <span class="tok-kt">Double</span>, <span class="tok-kt">Double</span><span class="tok-o">)]</span> <span class="tok-o">{</span>

  <span class="tok-c1">// the descriptor of the broadcast state</span>
  <span class="tok-k">private</span> <span class="tok-k">lazy</span> <span class="tok-k">val</span> <span class="tok-n">thresholdStateDescriptor</span> <span class="tok-k">=</span>
    <span class="tok-k">new</span> <span class="tok-nc">MapStateDescriptor</span><span class="tok-o">[</span><span class="tok-kt">String</span>, <span class="tok-kt">Double</span><span class="tok-o">](</span>
      <span class="tok-s">&quot;thresholds&quot;</span><span class="tok-o">,</span> <span class="tok-n">classOf</span><span class="tok-o">[</span><span class="tok-kt">String</span><span class="tok-o">],</span> <span class="tok-n">classOf</span><span class="tok-o">[</span><span class="tok-kt">Double</span><span class="tok-o">])</span>

  <span class="tok-c1">// the keyed state handle</span>
  <span class="tok-k">private</span> <span class="tok-k">var</span> <span class="tok-n">lastTempState</span><span class="tok-k">:</span> <span class="tok-kt">ValueState</span><span class="tok-o">[</span><span class="tok-kt">Double</span><span class="tok-o">]</span> <span class="tok-k">=</span> <span class="tok-k">_</span>

  <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">open</span><span class="tok-o">(</span><span class="tok-n">parameters</span><span class="tok-k">:</span> <span class="tok-kt">Configuration</span><span class="tok-o">)</span><span class="tok-k">:</span> <span class="tok-kt">Unit</span> <span class="tok-o">=</span> <span class="tok-o">{</span>
    <span class="tok-c1">// create keyed state descriptor</span>
    <span class="tok-k">val</span> <span class="tok-n">lastTempDescriptor</span> <span class="tok-k">=</span> <span class="tok-k">new</span> <span class="tok-nc">ValueStateDescriptor</span><span class="tok-o">[</span><span class="tok-kt">Double</span><span class="tok-o">](</span>
      <span class="tok-s">&quot;lastTemp&quot;</span><span class="tok-o">,</span> <span class="tok-n">classOf</span><span class="tok-o">[</span><span class="tok-kt">Double</span><span class="tok-o">])</span>
    <span class="tok-c1">// obtain the keyed state handle</span>
    <span class="tok-n">lastTempState</span> <span class="tok-k">=</span> <span class="tok-n">getRuntimeContext</span><span class="tok-o">.</span><span class="tok-n">getState</span><span class="tok-o">[</span><span class="tok-kt">Double</span><span class="tok-o">](</span><span class="tok-n">lastTempDescriptor</span><span class="tok-o">)</span>
  <span class="tok-o">}</span>

  <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">processBroadcastElement</span><span class="tok-o">(</span>
      <span class="tok-n">update</span><span class="tok-k">:</span> <span class="tok-kt">ThresholdUpdate</span><span class="tok-o">,</span>
      <span class="tok-n">ctx</span><span class="tok-k">:</span> <span class="tok-kt">KeyedBroadcastProcessFunction</span>
        <span class="tok-o">[</span><span class="tok-kt">String</span>, <span class="tok-kt">SensorReading</span>, <span class="tok-kt">ThresholdUpdate</span>, <span class="tok-o">(</span><span class="tok-kt">String</span>, <span class="tok-kt">Double</span>, <span class="tok-kt">Double</span><span class="tok-o">)]</span><span class="tok-k">#</span><span class="tok-nc">Context</span><span class="tok-o">,</span>
      <span class="tok-n">out</span><span class="tok-k">:</span> <span class="tok-kt">Collector</span><span class="tok-o">[(</span><span class="tok-kt">String</span>, <span class="tok-kt">Double</span>, <span class="tok-kt">Double</span><span class="tok-o">)])</span><span class="tok-k">:</span> <span class="tok-kt">Unit</span> <span class="tok-o">=</span> <span class="tok-o">{</span>
    <span class="tok-c1">// get broadcasted state handle</span>
    <span class="tok-k">val</span> <span class="tok-n">thresholds</span> <span class="tok-k">=</span> <span class="tok-n">ctx</span><span class="tok-o">.</span><span class="tok-n">getBroadcastState</span><span class="tok-o">(</span><span class="tok-n">thresholdStateDescriptor</span><span class="tok-o">)</span>

    <span class="tok-k">if</span> <span class="tok-o">(</span><span class="tok-n">update</span><span class="tok-o">.</span><span class="tok-n">threshold</span> <span class="tok-o">!=</span> <span class="tok-mf">0.0d</span><span class="tok-o">)</span> <span class="tok-o">{</span>
      <span class="tok-c1">// configure a new threshold for the sensor</span>
      <span class="tok-n">thresholds</span><span class="tok-o">.</span><span class="tok-n">put</span><span class="tok-o">(</span><span class="tok-n">update</span><span class="tok-o">.</span><span class="tok-n">id</span><span class="tok-o">,</span> <span class="tok-n">update</span><span class="tok-o">.</span><span class="tok-n">threshold</span><span class="tok-o">)</span>
    <span class="tok-o">}</span> <span class="tok-k">else</span> <span class="tok-o">{</span>
      <span class="tok-c1">// remove threshold for the sensor</span>
      <span class="tok-n">thresholds</span><span class="tok-o">.</span><span class="tok-n">remove</span><span class="tok-o">(</span><span class="tok-n">update</span><span class="tok-o">.</span><span class="tok-n">id</span><span class="tok-o">)</span>
    <span class="tok-o">}</span>
  <span class="tok-o">}</span>

  <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">processElement</span><span class="tok-o">(</span>
      <span class="tok-n">reading</span><span class="tok-k">:</span> <span class="tok-kt">SensorReading</span><span class="tok-o">,</span>
      <span class="tok-n">readOnlyCtx</span><span class="tok-k">:</span> <span class="tok-kt">KeyedBroadcastProcessFunction</span>
        <span class="tok-o">[</span><span class="tok-kt">String</span>, <span class="tok-kt">SensorReading</span>, <span class="tok-kt">ThresholdUpdate</span>,
        <span class="tok-o">(</span><span class="tok-kt">String</span>, <span class="tok-kt">Double</span>, <span class="tok-kt">Double</span><span class="tok-o">)]</span><span class="tok-k">#</span><span class="tok-nc">ReadOnlyContext</span><span class="tok-o">,</span>
      <span class="tok-n">out</span><span class="tok-k">:</span> <span class="tok-kt">Collector</span><span class="tok-o">[(</span><span class="tok-kt">String</span>, <span class="tok-kt">Double</span>, <span class="tok-kt">Double</span><span class="tok-o">)])</span><span class="tok-k">:</span> <span class="tok-kt">Unit</span> <span class="tok-o">=</span> <span class="tok-o">{</span>
    <span class="tok-c1">// get read-only broadcast state</span>
    <span class="tok-k">val</span> <span class="tok-n">thresholds</span> <span class="tok-k">=</span> <span class="tok-n">readOnlyCtx</span><span class="tok-o">.</span><span class="tok-n">getBroadcastState</span><span class="tok-o">(</span><span class="tok-n">thresholdStateDescriptor</span><span class="tok-o">)</span>
    <span class="tok-c1">// check if we have a threshold</span>
    <span class="tok-k">if</span> <span class="tok-o">(</span><span class="tok-n">thresholds</span><span class="tok-o">.</span><span class="tok-n">contains</span><span class="tok-o">(</span><span class="tok-n">reading</span><span class="tok-o">.</span><span class="tok-n">id</span><span class="tok-o">))</span> <span class="tok-o">{</span>
      <span class="tok-c1">// get threshold for sensor</span>
      <span class="tok-k">val</span> <span class="tok-n">sensorThreshold</span><span class="tok-k">:</span> <span class="tok-kt">Double</span> <span class="tok-o">=</span> <span class="tok-n">thresholds</span><span class="tok-o">.</span><span class="tok-n">get</span><span class="tok-o">(</span><span class="tok-n">reading</span><span class="tok-o">.</span><span class="tok-n">id</span><span class="tok-o">)</span>

      <span class="tok-c1">// fetch the last temperature from state</span>
      <span class="tok-k">val</span> <span class="tok-n">lastTemp</span> <span class="tok-k">=</span> <span class="tok-n">lastTempState</span><span class="tok-o">.</span><span class="tok-n">value</span><span class="tok-o">()</span>
      <span class="tok-c1">// check if we need to emit an alert</span>
      <span class="tok-k">val</span> <span class="tok-n">tempDiff</span> <span class="tok-k">=</span> <span class="tok-o">(</span><span class="tok-n">reading</span><span class="tok-o">.</span><span class="tok-n">temperature</span> <span class="tok-o">-</span> <span class="tok-n">lastTemp</span><span class="tok-o">).</span><span class="tok-n">abs</span>
      <span class="tok-k">if</span> <span class="tok-o">(</span><span class="tok-n">tempDiff</span> <span class="tok-o">&gt;</span> <span class="tok-n">sensorThreshold</span><span class="tok-o">)</span> <span class="tok-o">{</span>
        <span class="tok-c1">// temperature increased by more than the threshold</span>
        <span class="tok-n">out</span><span class="tok-o">.</span><span class="tok-n">collect</span><span class="tok-o">((</span><span class="tok-n">reading</span><span class="tok-o">.</span><span class="tok-n">id</span><span class="tok-o">,</span> <span class="tok-n">reading</span><span class="tok-o">.</span><span class="tok-n">temperature</span><span class="tok-o">,</span> <span class="tok-n">tempDiff</span><span class="tok-o">))</span>
      <span class="tok-o">}</span>
    <span class="tok-o">}</span>

    <span class="tok-c1">// update lastTemp state</span>
    <span class="tok-k">this</span><span class="tok-o">.</span><span class="tok-n">lastTempState</span><span class="tok-o">.</span><span class="tok-n">update</span><span class="tok-o">(</span><span class="tok-n">reading</span><span class="tok-o">.</span><span class="tok-n">temperature</span><span class="tok-o">)</span>
  <span class="tok-o">}</span>
<span class="tok-o">}</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_状态存储恢复和清理">9.6. 状态存储，恢复和清理</h3>
<div class="sect3">
<h4 id="_配置检查点">9.6.1. 配置检查点</h4>
<div class="paragraph">
<p>10秒钟保存一次检查点。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">val</span> <span class="tok-n">env</span> <span class="tok-k">=</span> <span class="tok-nc">StreamExecutionEnvironment</span><span class="tok-o">.</span><span class="tok-n">getExecutionEnvironment</span>

<span class="tok-c1">// set checkpointing interval to 10 seconds (10000 milliseconds)</span>
<span class="tok-n">env</span><span class="tok-o">.</span><span class="tok-n">enableCheckpointing</span><span class="tok-o">(</span><span class="tok-mi">10000L</span><span class="tok-o">)</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_指定唯一的操作符标识符operator_identifiers">9.6.2. 指定唯一的操作符标识符(operator identifiers)</h4>
<div class="paragraph">
<p>每一个操作符都可以指定唯一的标识符。标识符将会作为操作符的元数据和状态数据一起保存到savepoint中去。当应用从保存点恢复时，标识符可以用来在savepoint中查找标识符对应的操作符的状态数据。标识符必须是唯一的，否则应用不知道从哪一个标识符恢复。</p>
</div>
<div class="paragraph">
<p>强烈建议为应用的每一个操作符定义唯一标识符。例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">val</span> <span class="tok-n">alerts</span><span class="tok-k">:</span> <span class="tok-kt">DataStream</span><span class="tok-o">[(</span><span class="tok-kt">String</span>, <span class="tok-kt">Double</span>, <span class="tok-kt">Double</span><span class="tok-o">)]</span> <span class="tok-k">=</span> <span class="tok-n">keyedSensorData</span>
  <span class="tok-o">.</span><span class="tok-n">flatMap</span><span class="tok-o">(</span><span class="tok-k">new</span> <span class="tok-nc">TemperatureAlertFunction</span><span class="tok-o">(</span><span class="tok-mf">1.1</span><span class="tok-o">))</span>
  <span class="tok-o">.</span><span class="tok-n">uid</span><span class="tok-o">(</span><span class="tok-s">&quot;TempAlert&quot;</span><span class="tok-o">)</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_指定操作符的最大并行度">9.6.3. 指定操作符的最大并行度</h4>
<div class="paragraph">
<p>操作符的最大并行度定义了操作符的keyed state可以被分到多少个key groups中。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">val</span> <span class="tok-n">env</span> <span class="tok-k">=</span> <span class="tok-nc">StreamExecutionEnvironment</span><span class="tok-o">.</span><span class="tok-n">getExecutionEnvironment</span>

<span class="tok-c1">// set the maximum parallelism for this application</span>
<span class="tok-n">env</span><span class="tok-o">.</span><span class="tok-n">setMaxParallelism</span><span class="tok-o">(</span><span class="tok-mi">512</span><span class="tok-o">)</span>

<span class="tok-k">val</span> <span class="tok-n">alerts</span><span class="tok-k">:</span> <span class="tok-kt">DataStream</span><span class="tok-o">[(</span><span class="tok-kt">String</span>, <span class="tok-kt">Double</span>, <span class="tok-kt">Double</span><span class="tok-o">)]</span> <span class="tok-k">=</span> <span class="tok-n">keyedSensorData</span>
  <span class="tok-o">.</span><span class="tok-n">flatMap</span><span class="tok-o">(</span><span class="tok-k">new</span> <span class="tok-nc">TemperatureAlertFunction</span><span class="tok-o">(</span><span class="tok-mf">1.1</span><span class="tok-o">))</span>
  <span class="tok-c1">// set the maximum parallelism for this operator and</span>
  <span class="tok-c1">// override the application-wide value</span>
  <span class="tok-o">.</span><span class="tok-n">setMaxParallelism</span><span class="tok-o">(</span><span class="tok-mi">1024</span><span class="tok-o">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>示意图：</p>
</div>
</div>
<div class="sect3">
<h4 id="_防止状态泄露">9.6.4. 防止状态泄露</h4>
<div class="paragraph">
<p>流应用通常需要运行几个月或者几年。如果state数据不断增长的话，会爆炸。所以控制state数据的大小十分重要。而Flink并不会清理state和gc。所以所有的stateful operator都需要控制他们各自的状态数据大小，保证不爆炸。</p>
</div>
<div class="paragraph">
<p>例如我们之前讲过增量聚合函数ReduceFunction/AggregateFunction，就可以提前聚合而不给state太多压力。</p>
</div>
<div class="paragraph">
<p>我们来看一个例子，我们实现了一个KeyedProcessFunction，用来计算连续两次的温度的差值，如果差值超过阈值，报警。</p>
</div>
<div class="paragraph">
<p>我们之前实现过这个需求，但没有清理掉状态数据。比如一小时内不再产生温度数据的传感器对应的状态数据就可以清理掉了。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">class</span> <span class="tok-nc">SelfCleaningTemperatureAlertFunction</span><span class="tok-o">(</span><span class="tok-k">val</span> <span class="tok-n">threshold</span><span class="tok-k">:</span> <span class="tok-kt">Double</span><span class="tok-o">)</span>
    <span class="tok-k">extends</span> <span class="tok-nc">KeyedProcessFunction</span><span class="tok-o">[</span><span class="tok-kt">String</span>, <span class="tok-kt">SensorReading</span>, <span class="tok-o">(</span><span class="tok-kt">String</span>, <span class="tok-kt">Double</span>, <span class="tok-kt">Double</span><span class="tok-o">)]</span> <span class="tok-o">{</span>

  <span class="tok-c1">// the keyed state handle for the last temperature</span>
  <span class="tok-k">private</span> <span class="tok-k">var</span> <span class="tok-n">lastTempState</span><span class="tok-k">:</span> <span class="tok-kt">ValueState</span><span class="tok-o">[</span><span class="tok-kt">Double</span><span class="tok-o">]</span> <span class="tok-k">=</span> <span class="tok-k">_</span>
  <span class="tok-c1">// the keyed state handle for the last registered timer</span>
  <span class="tok-k">private</span> <span class="tok-k">var</span> <span class="tok-n">lastTimerState</span><span class="tok-k">:</span> <span class="tok-kt">ValueState</span><span class="tok-o">[</span><span class="tok-kt">Long</span><span class="tok-o">]</span> <span class="tok-k">=</span> <span class="tok-k">_</span>

  <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">open</span><span class="tok-o">(</span><span class="tok-n">parameters</span><span class="tok-k">:</span> <span class="tok-kt">Configuration</span><span class="tok-o">)</span><span class="tok-k">:</span> <span class="tok-kt">Unit</span> <span class="tok-o">=</span> <span class="tok-o">{</span>
    <span class="tok-c1">// register state for last temperature</span>
    <span class="tok-k">val</span> <span class="tok-n">lastTempDesc</span> <span class="tok-k">=</span> <span class="tok-k">new</span> <span class="tok-nc">ValueStateDescriptor</span><span class="tok-o">[</span><span class="tok-kt">Double</span><span class="tok-o">](</span><span class="tok-s">&quot;lastTemp&quot;</span><span class="tok-o">,</span> <span class="tok-n">classOf</span><span class="tok-o">[</span><span class="tok-kt">Double</span><span class="tok-o">])</span>
    <span class="tok-n">lastTempState</span> <span class="tok-k">=</span> <span class="tok-n">getRuntimeContext</span><span class="tok-o">.</span><span class="tok-n">getState</span><span class="tok-o">[</span><span class="tok-kt">Double</span><span class="tok-o">](</span><span class="tok-n">lastTempDescriptor</span><span class="tok-o">)</span>
    <span class="tok-c1">// register state for last timer</span>
    <span class="tok-k">val</span> <span class="tok-n">lastTimerDesc</span> <span class="tok-k">=</span> <span class="tok-k">new</span> <span class="tok-nc">ValueStateDescriptor</span><span class="tok-o">[</span><span class="tok-kt">Long</span><span class="tok-o">](</span><span class="tok-s">&quot;lastTimer&quot;</span><span class="tok-o">,</span> <span class="tok-n">classOf</span><span class="tok-o">[</span><span class="tok-kt">Long</span><span class="tok-o">])</span>
    <span class="tok-n">lastTimerState</span> <span class="tok-k">=</span> <span class="tok-n">getRuntimeContext</span><span class="tok-o">.</span><span class="tok-n">getState</span><span class="tok-o">(</span><span class="tok-n">timestampDescriptor</span><span class="tok-o">)</span>
  <span class="tok-o">}</span>

  <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">processElement</span><span class="tok-o">(</span>
      <span class="tok-n">reading</span><span class="tok-k">:</span> <span class="tok-kt">SensorReading</span><span class="tok-o">,</span>
      <span class="tok-n">ctx</span><span class="tok-k">:</span> <span class="tok-kt">KeyedProcessFunction</span>
        <span class="tok-o">[</span><span class="tok-kt">String</span>, <span class="tok-kt">SensorReading</span>, <span class="tok-o">(</span><span class="tok-kt">String</span>, <span class="tok-kt">Double</span>, <span class="tok-kt">Double</span><span class="tok-o">)]</span><span class="tok-k">#</span><span class="tok-nc">Context</span><span class="tok-o">,</span>
      <span class="tok-n">out</span><span class="tok-k">:</span> <span class="tok-kt">Collector</span><span class="tok-o">[(</span><span class="tok-kt">String</span>, <span class="tok-kt">Double</span>, <span class="tok-kt">Double</span><span class="tok-o">)])</span><span class="tok-k">:</span> <span class="tok-kt">Unit</span> <span class="tok-o">=</span> <span class="tok-o">{</span>

    <span class="tok-c1">// compute timestamp of new clean up timer as record timestamp + one hour</span>
    <span class="tok-k">val</span> <span class="tok-n">newTimer</span> <span class="tok-k">=</span> <span class="tok-n">ctx</span><span class="tok-o">.</span><span class="tok-n">timestamp</span><span class="tok-o">()</span> <span class="tok-o">+</span> <span class="tok-o">(</span><span class="tok-mi">3600</span> <span class="tok-o">*</span> <span class="tok-mi">1000</span><span class="tok-o">)</span>
    <span class="tok-c1">// get timestamp of current timer</span>
    <span class="tok-k">val</span> <span class="tok-n">curTimer</span> <span class="tok-k">=</span> <span class="tok-n">lastTimerState</span><span class="tok-o">.</span><span class="tok-n">value</span><span class="tok-o">()</span>
    <span class="tok-c1">// delete previous timer and register new timer</span>
    <span class="tok-n">ctx</span><span class="tok-o">.</span><span class="tok-n">timerService</span><span class="tok-o">().</span><span class="tok-n">deleteEventTimeTimer</span><span class="tok-o">(</span><span class="tok-n">curTimer</span><span class="tok-o">)</span>
    <span class="tok-n">ctx</span><span class="tok-o">.</span><span class="tok-n">timerService</span><span class="tok-o">().</span><span class="tok-n">registerEventTimeTimer</span><span class="tok-o">(</span><span class="tok-n">newTimer</span><span class="tok-o">)</span>
    <span class="tok-c1">// update timer timestamp state</span>
    <span class="tok-n">lastTimerState</span><span class="tok-o">.</span><span class="tok-n">update</span><span class="tok-o">(</span><span class="tok-n">newTimer</span><span class="tok-o">)</span>

    <span class="tok-c1">// fetch the last temperature from state</span>
    <span class="tok-k">val</span> <span class="tok-n">lastTemp</span> <span class="tok-k">=</span> <span class="tok-n">lastTempState</span><span class="tok-o">.</span><span class="tok-n">value</span><span class="tok-o">()</span>
    <span class="tok-c1">// check if we need to emit an alert</span>
    <span class="tok-k">val</span> <span class="tok-n">tempDiff</span> <span class="tok-k">=</span> <span class="tok-o">(</span><span class="tok-n">reading</span><span class="tok-o">.</span><span class="tok-n">temperature</span> <span class="tok-o">-</span> <span class="tok-n">lastTemp</span><span class="tok-o">).</span><span class="tok-n">abs</span>
    <span class="tok-k">if</span> <span class="tok-o">(</span><span class="tok-n">tempDiff</span> <span class="tok-o">&gt;</span> <span class="tok-n">threshold</span><span class="tok-o">)</span> <span class="tok-o">{</span>
      <span class="tok-c1">// temperature increased by more than the threshold</span>
      <span class="tok-n">out</span><span class="tok-o">.</span><span class="tok-n">collect</span><span class="tok-o">((</span><span class="tok-n">reading</span><span class="tok-o">.</span><span class="tok-n">id</span><span class="tok-o">,</span> <span class="tok-n">reading</span><span class="tok-o">.</span><span class="tok-n">temperature</span><span class="tok-o">,</span> <span class="tok-n">tempDiff</span><span class="tok-o">))</span>
    <span class="tok-o">}</span>

    <span class="tok-c1">// update lastTemp state</span>
    <span class="tok-k">this</span><span class="tok-o">.</span><span class="tok-n">lastTempState</span><span class="tok-o">.</span><span class="tok-n">update</span><span class="tok-o">(</span><span class="tok-n">reading</span><span class="tok-o">.</span><span class="tok-n">temperature</span><span class="tok-o">)</span>
  <span class="tok-o">}</span>

  <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">onTimer</span><span class="tok-o">(</span>
      <span class="tok-n">timestamp</span><span class="tok-k">:</span> <span class="tok-kt">Long</span><span class="tok-o">,</span>
      <span class="tok-n">ctx</span><span class="tok-k">:</span> <span class="tok-kt">KeyedProcessFunction</span>
        <span class="tok-o">[</span><span class="tok-kt">String</span>, <span class="tok-kt">SensorReading</span>, <span class="tok-o">(</span><span class="tok-kt">String</span>, <span class="tok-kt">Double</span>, <span class="tok-kt">Double</span><span class="tok-o">)]</span><span class="tok-k">#</span><span class="tok-nc">OnTimerContext</span><span class="tok-o">,</span>
      <span class="tok-n">out</span><span class="tok-k">:</span> <span class="tok-kt">Collector</span><span class="tok-o">[(</span><span class="tok-kt">String</span>, <span class="tok-kt">Double</span>, <span class="tok-kt">Double</span><span class="tok-o">)])</span><span class="tok-k">:</span> <span class="tok-kt">Unit</span> <span class="tok-o">=</span> <span class="tok-o">{</span>

    <span class="tok-c1">// clear all state for the key</span>
    <span class="tok-n">lastTempState</span><span class="tok-o">.</span><span class="tok-n">clear</span><span class="tok-o">()</span>
    <span class="tok-n">lastTimerState</span><span class="tok-o">.</span><span class="tok-n">clear</span><span class="tok-o">()</span>
  <span class="tok-o">}</span>
<span class="tok-o">}</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_选择一个状态后端">9.6.5. 选择一个状态后端</h4>
<div class="ulist">
<ul>
<li>
<p>MemoryStateBackend将状态当作Java的对象(没有序列化操作)存储在TaskManager JVM进程的堆上。</p>
</li>
<li>
<p>FsStateBackend将状态存储在本地的文件系统或者远程的文件系统如HDFS。</p>
</li>
<li>
<p>RocksDBStateBackend将状态存储在RocksDB \footnote{Facebook开源的KV数据库} 中。</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">val</span> <span class="tok-n">env</span> <span class="tok-k">=</span> <span class="tok-nc">StreamExecutionEnvironment</span><span class="tok-o">.</span><span class="tok-n">getExecutionEnvironment</span>

<span class="tok-k">val</span> <span class="tok-n">checkpointPath</span><span class="tok-k">:</span> <span class="tok-kt">String</span> <span class="tok-o">=</span> <span class="tok-o">???</span>
<span class="tok-c1">// configure path for checkpoints on the remote filesystem</span>
<span class="tok-c1">// env.setStateBackend(new FsStateBackend(&quot;file:///tmp/checkpoints&quot;))</span>

<span class="tok-k">val</span> <span class="tok-n">backend</span> <span class="tok-k">=</span> <span class="tok-k">new</span> <span class="tok-nc">RocksDBStateBackend</span><span class="tok-o">(</span><span class="tok-n">checkpointPath</span><span class="tok-o">)</span>
<span class="tok-c1">// configure the state backend</span>
<span class="tok-n">env</span><span class="tok-o">.</span><span class="tok-n">setStateBackend</span><span class="tok-o">(</span><span class="tok-n">backend</span><span class="tok-o">)</span></code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_从外部系统读取以及写入外部系统">10. 从外部系统读取以及写入外部系统</h2>
<div class="sectionbody">
<div class="paragraph">
<p>数据可以存储在不同的系统中，例如：文件系统，对象存储系统（OSS），关系型数据库，Key-Value存储，搜索引擎索引，日志系统，消息队列，等等。每一种系统都是给特定的应用场景设计的，在某一个特定的目标上超越了其他系统。今天的数据架构，往往包含着很多不同的存储系统。在将一个组件加入到我们的系统中时，我们需要问一个问题：“这个组件和架构中的其他组件能多好的一起工作？”</p>
</div>
<div class="paragraph">
<p>添加一个像Flink这样的数据处理系统，需要仔细的考虑。因为Flink没有自己的存储层，而是读取数据和持久化数据都需要依赖外部存储。所以，对于Flink，针对外部系统提供良好的读取和写入的连接器就很重要了。尽管如此，仅仅能够读写外部系统对于Flink这样想要提供任务故障情况下一致性保证的流处理器来讲，是不够的。</p>
</div>
<div class="paragraph">
<p>在本章中，我们将会讨论source和sink的连接器。这些连接器影响了Flink的一致性保证，也提供了对于最流行的一些外部系统的读写的连接器。我们还将学习如何实现自定义source和sink连接器，以及如何实现可以向外部系统发送异步读写请求的函数。</p>
</div>
<div class="sect2">
<h3 id="_应用的一致性保证">10.1. 应用的一致性保证</h3>
<div class="paragraph">
<p>Flink的检查点和恢复机制定期的会保存应用程序状态的一致性检查点。在故障的情况下，应用程序的状态将会从最近一次完成的检查点恢复，并继续处理。尽管如此，可以使用检查点来重置应用程序的状态无法完全达到令人满意的一致性保证。相反，source和sink的连接器需要和Flink的检查点和恢复机制进行集成才能提供有意义的一致性保证。</p>
</div>
<div class="paragraph">
<p>为了给应用程序提供恰好处理一次语义的状态一致性保证，应用程序的source连接器需要能够将source的读位置重置到之前保存的检查点位置。当处理一次检查点时，source操作符将会把source的读位置持久化，并在恢复的时候从这些读位置开始重新读取。支持读位置的检查点的source连接器一般来说是基于文件的存储系统，如：文件流或者Kafka source（检查点会持久化某个正在消费的topic的读偏移量）。如果一个应用程序从一个无法存储和重置读位置的source连接器摄入数据，那么当任务出现故障的时候，数据就会丢失。也就是说我们只能提供at-most-once）的一致性保证。</p>
</div>
<div class="paragraph">
<p>Fink的检查点和恢复机制和可以重置读位置的source连接器结合使用，可以保证应用程序不会丢失任何数据。尽管如此，应用程序可能会发出两次计算结果，因为从上一次检查点恢复的应用程序所计算的结果将会被重新发送一次（一些结果已经发送出去了，这时任务故障，然后从上一次检查点恢复，这些结果将被重新计算一次然后发送出去）。所以，可重置读位置的source和Flink的恢复机制不足以提供端到端的恰好处理一次语义，即使应用程序的状态是恰好处理一次一致性级别。</p>
</div>
<div class="paragraph">
<p>一个志在提供端到端恰好处理一次语义一致性的应用程序需要特殊的sink连接器。sink连接器可以在不同的情况下使用两种技术来达到恰好处理一次一致性语义：幂等性写入和事务性写入。</p>
</div>
<div class="sect3">
<h4 id="_幂等性写入">10.1.1. 幂等性写入</h4>
<div class="paragraph">
<p>一个幂等操作无论执行多少次都会返回同样的结果。例如，重复的向hashmap中插入同样的key-value对就是幂等操作，因为头一次插入操作之后所有的插入操作都不会改变这个hashmap，因为hashmap已经包含这个key-value对了。另一方面，append操作就不是幂等操作了，因为多次append同一个元素将会导致列表每次都会添加一个元素。在流处理程序中，幂等写入操作是很有意思的，因为幂等写入操作可以执行多次但不改变结果。所以它们可以在某种程度上缓和Flink检查点机制带来的重播计算结果的效应。</p>
</div>
<div class="paragraph">
<p>需要注意的是，依赖于幂等性sink来达到exactly-once语义的应用程序，必须保证在从检查点恢复以后，它将会覆盖之前已经写入的结果。例如，一个包含有sink操作的应用在sink到一个key-value存储时必须保证它能够确定的计算出将要更新的key值。同时，从Flink程序sink到的key-value存储中读取数据的应用，在Flink从检查点恢复的过程中，可能会看到不想看到的结果。当重播开始时，之前已经发出的计算结果可能会被更早的结果所覆盖（因为在恢复过程中）。所以，一个消费Flink程序输出数据的应用，可能会观察到时间回退，例如读到了比之前小的计数。也就是说，当流处理程序处于恢复过程中时，流处理程序的结果将处于不稳定的状态，因为一些结果被覆盖掉，而另一些结果还没有被覆盖。一旦重播完成，也就是说应用程序已经通过了之前出故障的点，结果将会继续保持一致性。</p>
</div>
</div>
<div class="sect3">
<h4 id="_事务性写入">10.1.2. 事务性写入</h4>
<div class="paragraph">
<p>第二种实现端到端的恰好处理一次一致性语义的方法基于事务性写入。其思想是只将最近一次成功保存的检查点之前的计算结果写入到外部系统中去。这样就保证了在任务故障的情况下，端到端恰好处理一次语义。应用将被重置到最近一次的检查点，而在这个检查点之后并没有向外部系统发出任何计算结果。通过只有当检查点保存完成以后再写入数据这种方法，事务性的方法将不会遭受幂等性写入所遭受的重播不一致的问题。尽管如此，事务性写入却带来了延迟，因为只有在检查点完成以后，我们才能看到计算结果。</p>
</div>
<div class="paragraph">
<p>Flink提供了两种构建模块来实现事务性sink连接器：write-ahead-log（WAL，预写式日志）sink和两阶段提交sink。WAL式sink将会把所有计算结果写入到应用程序的状态中，等接到检查点完成的通知，才会将计算结果发送到sink系统。因为sink操作会把数据都缓存在状态后段，所以WAL可以使用在任何外部sink系统上。尽管如此，WAL还是无法提供刀枪不入的恰好处理一次语义的保证，再加上由于要缓存数据带来的状态后段的状态大小的问题，WAL模型并不十分完美。</p>
</div>
<div class="paragraph">
<p>与之形成对比的，2PC sink需要sink系统提供事务的支持或者可以模拟出事务特性的模块。对于每一个检查点，sink开始一个事务，然后将所有的接收到的数据都添加到事务中，并将这些数据写入到sink系统，但并没有提交（commit）它们。当事务接收到检查点完成的通知时，事务将被commit，数据将被真正的写入sink系统。这项机制主要依赖于一次sink可以在检查点完成之前开始事务，并在应用程序从一次故障中恢复以后再commit的能力。</p>
</div>
<div class="paragraph">
<p>2PC协议依赖于Flink的检查点机制。检查点屏障是开始一个新的事务的通知，所有操作符自己的检查点成功的通知是它们可以commit的投票，而JobManager通知一个检查点成功的消息是commit事务的指令。于WAL sink形成对比的是，2PC sinks依赖于sink系统和sink本身的实现可以实现恰好处理一次语义。更多的，2PC sink不断的将数据写入到sink系统中，而WAL写模型就会有之前所述的问题。</p>
</div>
<div class="paragraph">
<p>表格8-1</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_flink提供的连接器">10.2. Flink提供的连接器}</h3>
<div class="paragraph">
<p>Flink提供了读写很多存储系统的连接器。消息队列，日志系统，例如Apache Kafka, Kinesis, RabbitMQ等等这些是常用的数据源。在批处理环境中，数据流很可能是监听一个文件系统，而当新的数据落盘的时候，读取这些新数据。</p>
</div>
<div class="paragraph">
<p>在sink一端，数据流经常写入到消息队列中，以供接下来的流处理程序消费。数据流也可能写入到文件系统中做持久化，或者交给批处理程序来进行分析。数据流还可能被写入到key-value存储或者关系型数据库中，例如Cassandra，ElasticSearch或者MySQL中，这样数据可供查询，还可以在仪表盘中显示出来。</p>
</div>
<div class="paragraph">
<p>不幸的是，对于大多数存储系统并没有标准接口，除了针对DBMS的JDBC。相反，每一个存储系统都需要有自己的特定的连接器。所以，Flink需要维护针对不同存储系统（消息队列，日志系统，文件系统，k-v数据库，关系型数据库等等）的连接器实现。</p>
</div>
<div class="paragraph">
<p>Flink提供了针对Apache Kafka, Kinesis, RabbitMQ, Apache Nifi, 各种文件系统，Cassandra, Elasticsearch, 还有JDBC的连接器。除此之外，Apache Bahir项目还提供了额外的针对例如ActiveMQ, Akka, Flume, Netty, 和Redis等的连接器。</p>
</div>
<div class="sect3">
<h4 id="_apache_kafka_source连接器">10.2.1. Apache Kafka Source连接器</h4>
<div class="paragraph">
<p>Apache Kafka是一个分布式流式平台。它的核心是一个分布式的发布订阅消息系统。</p>
</div>
<div class="paragraph">
<p>Kafka将事件流组织为所谓的topics。一个主题就是一个事件日志系统，Kafka可以保证主题中的数据在被读取时和这些数据在被写入时相同的顺序。为了扩大读写的规模，主题可以分裂为多个分区，这些分区分布在一个集群上面。这时，读写顺序的保证就限制到了分区这个粒度， Kafka并没有提供从不同分区读取数据时的顺序保证。Kafka分区的读位置称为偏移量（offset）。</p>
</div>
<div class="paragraph">
<p>Kafka的依赖引入如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="xml"><span></span><span class="tok-nt">&lt;dependency&gt;</span>
   <span class="tok-nt">&lt;groupId&gt;</span>org.apache.flink<span class="tok-nt">&lt;/groupId&gt;</span>
   <span class="tok-nt">&lt;artifactId&gt;</span>flink-connector-kafka_2.12<span class="tok-nt">&lt;/artifactId&gt;</span>
   <span class="tok-nt">&lt;version&gt;</span>1.7.1<span class="tok-nt">&lt;/version&gt;</span>
<span class="tok-nt">&lt;/dependency&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Flink Kafka连接器并行的摄入事件流。每一个并行source任务可以从一个或者多个分区中读取数据。任务将会跟踪每一个分区当前的读偏移量，然后将读偏移量写入到检查点数据中。当从任务故障恢复时，读偏移量将被恢复，而source任务将从检查点保存的读偏移量开始重新读取数据。Flink Kafka连接器并不依赖Kafka自己的offset-tracking机制（基于消费者组实现）。下图展示了分区如何分配给source实例。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/spaf_0801.png" alt="spaf 0801">
</div>
</div>
<div class="paragraph">
<p>Kafka source连接器使用如下代码创建</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">val</span> <span class="tok-n">properties</span> <span class="tok-k">=</span> <span class="tok-k">new</span> <span class="tok-nc">Properties</span><span class="tok-o">()</span>
<span class="tok-n">properties</span><span class="tok-o">.</span><span class="tok-n">setProperty</span><span class="tok-o">(</span><span class="tok-s">&quot;bootstrap.servers&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;localhost:9092&quot;</span><span class="tok-o">)</span>
<span class="tok-n">properties</span><span class="tok-o">.</span><span class="tok-n">setProperty</span><span class="tok-o">(</span><span class="tok-s">&quot;group.id&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;test&quot;</span><span class="tok-o">)</span>

<span class="tok-k">val</span> <span class="tok-n">stream</span><span class="tok-k">:</span> <span class="tok-kt">DataStream</span><span class="tok-o">[</span><span class="tok-kt">String</span><span class="tok-o">]</span> <span class="tok-k">=</span> <span class="tok-n">env</span><span class="tok-o">.</span><span class="tok-n">addSource</span><span class="tok-o">(</span>
  <span class="tok-k">new</span> <span class="tok-nc">FlinkKafkaConsumer</span><span class="tok-o">[</span><span class="tok-kt">String</span><span class="tok-o">](</span>
    <span class="tok-s">&quot;topic&quot;</span><span class="tok-o">,</span>
    <span class="tok-k">new</span> <span class="tok-nc">SimpleStringSchema</span><span class="tok-o">(),</span>
    <span class="tok-n">properties</span><span class="tok-o">))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>构造器接受三个参数。第一个参数定义了从哪些topic中读取数据，可以是一个topic，也可以是topic列表，还可以是匹配所有想要读取的topic的正则表达式。当从多个topic中读取数据时，Kafka连接器将会处理所有topic的分区，将这些分区的数据放到一条流中去。</p>
</div>
<div class="paragraph">
<p>第二个参数是一个DeserializationSchema或者KeyedDeserializationSchema。Kafka消息被存储为原始的字节数据，所以需要反序列化成Java或者Scala对象。上例中使用的SimpleStringSchema，是一个内置的DeserializationSchema，它仅仅是简单的将字节数组反序列化成字符串。DeserializationSchema和KeyedDeserializationSchema是公共的接口，所以我们可以自定义反序列化逻辑。</p>
</div>
<div class="paragraph">
<p>第三个参数是一个Properties对象，设置了用来读写的Kafka客户端的一些属性。</p>
</div>
<div class="paragraph">
<p>为了抽取事件时间的时间戳然后产生水印，我们可以通过调用FlinkKafkaConsumer.assignTimestampsAndWatermark()方法为Kafka消费者提供AssignerWithPeriodicWatermark或者AssignerWithPucntuatedWatermark。每一个assigner都将被应用到每个分区，来利用每一个分区的顺序保证特性。souce实例将会根据水印的传播协议聚合所有分区的水印。</p>
</div>
</div>
<div class="sect3">
<h4 id="_apache_kafka_sink连接器">10.2.2. Apache Kafka Sink连接器</h4>
<div class="paragraph">
<p>添加依赖：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="xml"><span></span><span class="tok-nt">&lt;dependency&gt;</span>
   <span class="tok-nt">&lt;groupId&gt;</span>org.apache.flink<span class="tok-nt">&lt;/groupId&gt;</span>
   <span class="tok-nt">&lt;artifactId&gt;</span>flink-connector-kafka_2.12<span class="tok-nt">&lt;/artifactId&gt;</span>
   <span class="tok-nt">&lt;version&gt;</span>1.7.1<span class="tok-nt">&lt;/version&gt;</span>
<span class="tok-nt">&lt;/dependency&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>下面的例子展示了如何创建一个Kafka sink</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">val</span> <span class="tok-n">stream</span><span class="tok-k">:</span> <span class="tok-kt">DataStream</span><span class="tok-o">[</span><span class="tok-kt">String</span><span class="tok-o">]</span> <span class="tok-k">=</span> <span class="tok-o">...</span>

<span class="tok-k">val</span> <span class="tok-n">myProducer</span> <span class="tok-k">=</span> <span class="tok-k">new</span> <span class="tok-nc">FlinkKafkaProducer</span><span class="tok-o">[</span><span class="tok-kt">String</span><span class="tok-o">](</span>
  <span class="tok-s">&quot;localhost:9092&quot;</span><span class="tok-o">,</span>         <span class="tok-c1">// broker list</span>
  <span class="tok-s">&quot;topic&quot;</span><span class="tok-o">,</span>                  <span class="tok-c1">// target topic</span>
  <span class="tok-k">new</span> <span class="tok-nc">SimpleStringSchema</span><span class="tok-o">)</span>   <span class="tok-c1">// serialization schema</span>

<span class="tok-n">stream</span><span class="tok-o">.</span><span class="tok-n">addSink</span><span class="tok-o">(</span><span class="tok-n">myProducer</span><span class="tok-o">)</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_kakfa_sink的at_least_once保证">10.2.3. Kakfa Sink的at-least-once保证</h4>
<div class="paragraph">
<p>Flink的Kafka sink提供了基于配置的一致性保证。Kafka sink使用下面的条件提供了至少处理一次保证：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Flink检查点机制开启，所有的数据源都是可重置的。</p>
</li>
<li>
<p>当写入失败时，sink连接器将会抛出异常，使得应用程序挂掉然后重启。这是默认行为。应用程序内部的Kafka客户端还可以配置为重试写入，只要提前声明当写入失败时，重试几次这样的属性（retries property）。</p>
</li>
<li>
<p>sink连接器在完成它的检查点之前会等待Kafka发送已经将数据写入的通知。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_kafka_sink的恰好处理一次语义保证">10.2.4. Kafka Sink的恰好处理一次语义保证</h4>
<div class="paragraph">
<p>Kafka 0.11版本引入了事务写特性。由于这个新特性，Flink Kafka sink可以为输出结果提供恰好处理一次语义的一致性保证，只要经过合适的配置就行。Flink程序必须开启检查点机制，并从可重置的数据源进行消费。FlinkKafkaProducer还提供了包含Semantic参数的构造器来控制sink提供的一致性保证。可能的取值如下：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Semantic.NONE，不提供任何一致性保证。数据可能丢失或者被重写多次。</p>
</li>
<li>
<p>Semantic.AT_LEAST_ONCE，保证无数据丢失，但可能被处理多次。这个是默认设置。</p>
</li>
<li>
<p>Semantic.EXACTLY_ONCE，基于Kafka的事务性写入特性实现，保证每条数据恰好处理一次。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_文件系统source连接器">10.2.5. 文件系统source连接器</h4>
<div class="paragraph">
<p>Apache Flink针对文件系统实现了一个可重置的source连接器，将文件看作流来读取数据。如下面的例子所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">val</span> <span class="tok-n">lineReader</span> <span class="tok-k">=</span> <span class="tok-k">new</span> <span class="tok-nc">TextInputFormat</span><span class="tok-o">(</span><span class="tok-kc">null</span><span class="tok-o">)</span>

<span class="tok-k">val</span> <span class="tok-n">lineStream</span><span class="tok-k">:</span> <span class="tok-kt">DataStream</span><span class="tok-o">[</span><span class="tok-kt">String</span><span class="tok-o">]</span> <span class="tok-k">=</span> <span class="tok-n">env</span><span class="tok-o">.</span><span class="tok-n">readFile</span><span class="tok-o">[</span><span class="tok-kt">String</span><span class="tok-o">](</span>
  <span class="tok-n">lineReader</span><span class="tok-o">,</span>                 <span class="tok-c1">// The FileInputFormat</span>
  <span class="tok-s">&quot;hdfs:///path/to/my/data&quot;</span><span class="tok-o">,</span>  <span class="tok-c1">// The path to read</span>
  <span class="tok-nc">FileProcessingMode</span>
    <span class="tok-o">.</span><span class="tok-nc">PROCESS_CONTINUOUSLY</span><span class="tok-o">,</span>    <span class="tok-c1">// The processing mode</span>
  <span class="tok-mi">30000L</span><span class="tok-o">)</span>                     <span class="tok-c1">// The monitoring interval in ms</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>StreamExecutionEnvironment.readFile()接收如下参数：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>FileInputFormat参数，负责读取文件中的内容。</p>
</li>
<li>
<p>文件路径。如果文件路径指向单个文件，那么将会读取这个文件。如果路径指向一个文件夹，FileInputFormat将会扫描文件夹中所有的文件。</p>
</li>
<li>
<p>PROCESS_CONTINUOUSLY将会周期性的扫描文件，以便扫描到文件新的改变。</p>
</li>
<li>
<p>30000L表示多久扫描一次监听的文件。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>FileInputFormat是一个特定的InputFormat，用来从文件系统中读取文件。FileInputFormat分两步读取文件。首先扫描文件系统的路径，然后为所有匹配到的文件创建所谓的input splits。一个input split将会定义文件上的一个范围，一般通过读取的开始偏移量和读取长度来定义。在将一个大的文件分割成一堆小的splits以后，这些splits可以分发到不同的读任务，这样就可以并行的读取文件了。FileInputFormat的第二步会接收一个input split，读取被split定义的文件范围，然后返回对应的数据。</p>
</div>
<div class="paragraph">
<p>DataStream应用中使用的FileInputFormat需要实现CheckpointableInputFormat接口。这个接口定义了方法来做检查点和重置文件片段的当前的读取位置。</p>
</div>
<div class="paragraph">
<p>在Flink 1.7中，Flink提供了一些类，这些类继承了FileInputFormat，并实现了CheckpointableInputFormat接口。TextInputFormat一行一行的读取文件，而CsvInputFormat使用逗号分隔符来读取文件。</p>
</div>
</div>
<div class="sect3">
<h4 id="_文件系统sink连接器">10.2.6. 文件系统sink连接器</h4>
<div class="paragraph">
<p>在将流处理应用配置成exactly-once检查点机制，以及配置成所有源数据都能在故障的情况下可以重置，Flink的StreamingFileSink提供了端到端的恰好处理一次语义保证。下面的例子展示了StreamingFileSink的使用方式。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">val</span> <span class="tok-n">input</span><span class="tok-k">:</span> <span class="tok-kt">DataStream</span><span class="tok-o">[</span><span class="tok-kt">String</span><span class="tok-o">]</span> <span class="tok-k">=</span> <span class="tok-err">…</span>
<span class="tok-k">val</span> <span class="tok-n">sink</span><span class="tok-k">:</span> <span class="tok-kt">StreamingFileSink</span><span class="tok-o">[</span><span class="tok-kt">String</span><span class="tok-o">]</span> <span class="tok-k">=</span> <span class="tok-nc">StreamingFileSink</span>
  <span class="tok-o">.</span><span class="tok-n">forRowFormat</span><span class="tok-o">(</span>
    <span class="tok-k">new</span> <span class="tok-nc">Path</span><span class="tok-o">(</span><span class="tok-s">&quot;/base/path&quot;</span><span class="tok-o">),</span>
    <span class="tok-k">new</span> <span class="tok-nc">SimpleStringEncoder</span><span class="tok-o">[</span><span class="tok-kt">String</span><span class="tok-o">](</span><span class="tok-s">&quot;UTF-8&quot;</span><span class="tok-o">))</span>
  <span class="tok-o">.</span><span class="tok-n">build</span><span class="tok-o">()</span>

<span class="tok-n">input</span><span class="tok-o">.</span><span class="tok-n">addSink</span><span class="tok-o">(</span><span class="tok-n">sink</span><span class="tok-o">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>当StreamingFileSink接到一条数据，这条数据将被分配到一个桶（bucket）中。一个桶是我们配置的“/base/path”的子目录。</p>
</div>
<div class="paragraph">
<p>Flink使用BucketAssigner来分配桶。BucketAssigner是一个公共的接口，为每一条数据返回一个BucketId，BucketId决定了数据被分配到哪个子目录。如果没有指定BucketAssigner，Flink将使用DateTimeBucketAssigner来将每条数据分配到每个一个小时所产生的桶中去，基于数据写入的处理时间（机器时间，墙上时钟）。</p>
</div>
<div class="paragraph">
<p>StreamingFileSink提供了exactly-once输出的保证。sink通过一个commit协议来达到恰好处理一次语义的保证。这个commit协议会将文件移动到不同的阶段，有以下状态：in progress，pending，finished。这个协议基于Flink的检查点机制。当Flink决定roll a file时，这个文件将被关闭并移动到pending状态，通过重命名文件来实现。当下一个检查点完成时，pending文件将被移动到finished状态，同样是通过重命名来实现。</p>
</div>
<div class="paragraph">
<p>一旦任务故障，sink任务需要将处于in progress状态的文件重置到上一次检查点的写偏移量。这个可以通过关闭当前in progress的文件，并将文件结尾无效的部分丢弃掉来实现。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_实现自定义源函数">10.3. 实现自定义源函数</h3>
<div class="paragraph">
<p>DataStream API提供了两个接口来实现source连接器：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>SourceFunction和RichSourceFunction可以用来定义非并行的source连接器，source跑在单任务上。</p>
</li>
<li>
<p>ParallelSourceFunction和RichParallelSourceFunction可以用来定义跑在并行实例上的source连接器。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>除了并行于非并行的区别，这两种接口完全一样。就像process function的rich版本一样，RichSourceFunction和RichParallelSourceFunction的子类可以override open()和close()方法，也可以访问RuntimeContext，RuntimeContext提供了并行任务实例的数量，当前任务实例的索引，以及一些其他信息。</p>
</div>
<div class="paragraph">
<p>SourceFunction和ParallelSourceFunction定义了两种方法：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>void run(SourceContext&lt;T&gt; ctx)</p>
</li>
<li>
<p>cancel()</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>run()方法用来读取或者接收数据然后将数据摄入到Flink应用中。根据接收数据的系统，数据可能是推送的也可能是拉取的。Flink仅仅在特定的线程调用run()方法一次，通常情况下会是一个无限循环来读取或者接收数据并发送数据。任务可以在某个时间点被显式的取消，或者由于流是有限流，当数据被消费完毕时，任务也会停止。</p>
</div>
<div class="paragraph">
<p>当应用被取消或者关闭时，cancel()方法会被Flink调用。为了优雅的关闭Flink应用，run()方法需要在cancel()被调用以后，立即终止执行。下面的例子显示了一个简单的源函数的例子：从0数到Long.MaxValue。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">class</span> <span class="tok-nc">CountSource</span> <span class="tok-k">extends</span> <span class="tok-nc">SourceFunction</span><span class="tok-o">[</span><span class="tok-kt">Long</span><span class="tok-o">]</span> <span class="tok-o">{</span>
  <span class="tok-k">var</span> <span class="tok-n">isRunning</span><span class="tok-k">:</span> <span class="tok-kt">Boolean</span> <span class="tok-o">=</span> <span class="tok-kc">true</span>

  <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">run</span><span class="tok-o">(</span><span class="tok-n">ctx</span><span class="tok-k">:</span> <span class="tok-kt">SourceFunction.SourceContext</span><span class="tok-o">[</span><span class="tok-kt">Long</span><span class="tok-o">])</span> <span class="tok-k">=</span> <span class="tok-o">{</span>

    <span class="tok-k">var</span> <span class="tok-n">cnt</span><span class="tok-k">:</span> <span class="tok-kt">Long</span> <span class="tok-o">=</span> <span class="tok-o">-</span><span class="tok-mi">1</span>
    <span class="tok-k">while</span> <span class="tok-o">(</span><span class="tok-n">isRunning</span> <span class="tok-o">&amp;&amp;</span> <span class="tok-n">cnt</span> <span class="tok-o">&lt;</span> <span class="tok-nc">Long</span><span class="tok-o">.</span><span class="tok-nc">MaxValue</span><span class="tok-o">)</span> <span class="tok-o">{</span>
      <span class="tok-n">cnt</span> <span class="tok-o">+=</span> <span class="tok-mi">1</span>
      <span class="tok-n">ctx</span><span class="tok-o">.</span><span class="tok-n">collect</span><span class="tok-o">(</span><span class="tok-n">cnt</span><span class="tok-o">)</span>
    <span class="tok-o">}</span>
  <span class="tok-o">}</span>

  <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">cancel</span><span class="tok-o">()</span> <span class="tok-k">=</span> <span class="tok-n">isRunning</span> <span class="tok-k">=</span> <span class="tok-kc">false</span>
<span class="tok-o">}</span></code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_可重置的源函数">10.3.1. 可重置的源函数</h4>
<div class="paragraph">
<p>之前我们讲过，应用程序只有使用可以重播输出数据的数据源时，才能提供令人满意的一致性保证。如果外部系统暴露了获取和重置读偏移量的API，那么source函数就可以重播源数据。这样的例子包括一些能够提供文件流的偏移量的文件系统，或者提供seek方法用来移动到文件的特定位置的文件系统。或者Apache Kafka这种可以为每一个主题的分区提供偏移量并且可以设置分区的读位置的系统。一个反例就是source连接器连接的是socket，socket将会立即丢弃已经发送过的数据。</p>
</div>
<div class="paragraph">
<p>支持重播输出的源函数需要和Flink的检查点机制集成起来，还需要在检查点被处理时，持久化当前所有的读取位置。当应用从一个保存点（savepoint）恢复或者从故障恢复时，Flink会从最近一次的检查点或者保存点中获取读偏移量。如果程序开始时并不存在状态，那么读偏移量将会被设置到一个默认值。一个可重置的源函数需要实现CheckpointedFunction接口，还需要能够存储读偏移量和相关的元数据，例如文件的路径，分区的ID。这些数据将被保存在list state或者union list state中。</p>
</div>
<div class="paragraph">
<p>下面的例子将CountSource重写为可重置的数据源。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">class</span> <span class="tok-nc">ResettableCountSource</span>
    <span class="tok-k">extends</span> <span class="tok-nc">SourceFunction</span><span class="tok-o">[</span><span class="tok-kt">Long</span><span class="tok-o">]</span> <span class="tok-k">with</span> <span class="tok-nc">CheckpointedFunction</span> <span class="tok-o">{</span>

  <span class="tok-k">var</span> <span class="tok-n">isRunning</span><span class="tok-k">:</span> <span class="tok-kt">Boolean</span> <span class="tok-o">=</span> <span class="tok-kc">true</span>
  <span class="tok-k">var</span> <span class="tok-n">cnt</span><span class="tok-k">:</span> <span class="tok-kt">Long</span> <span class="tok-o">=</span> <span class="tok-k">_</span>
  <span class="tok-k">var</span> <span class="tok-n">offsetState</span><span class="tok-k">:</span> <span class="tok-kt">ListState</span><span class="tok-o">[</span><span class="tok-kt">Long</span><span class="tok-o">]</span> <span class="tok-k">=</span> <span class="tok-k">_</span>

  <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">run</span><span class="tok-o">(</span><span class="tok-n">ctx</span><span class="tok-k">:</span> <span class="tok-kt">SourceFunction.SourceContext</span><span class="tok-o">[</span><span class="tok-kt">Long</span><span class="tok-o">])</span> <span class="tok-k">=</span> <span class="tok-o">{</span>
    <span class="tok-k">while</span> <span class="tok-o">(</span><span class="tok-n">isRunning</span> <span class="tok-o">&amp;&amp;</span> <span class="tok-n">cnt</span> <span class="tok-o">&lt;</span> <span class="tok-nc">Long</span><span class="tok-o">.</span><span class="tok-nc">MaxValue</span><span class="tok-o">)</span> <span class="tok-o">{</span>
      <span class="tok-c1">// synchronize data emission and checkpoints</span>
      <span class="tok-n">ctx</span><span class="tok-o">.</span><span class="tok-n">getCheckpointLock</span><span class="tok-o">.</span><span class="tok-n">synchronized</span> <span class="tok-o">{</span>
        <span class="tok-n">cnt</span> <span class="tok-o">+=</span> <span class="tok-mi">1</span>
        <span class="tok-n">ctx</span><span class="tok-o">.</span><span class="tok-n">collect</span><span class="tok-o">(</span><span class="tok-n">cnt</span><span class="tok-o">)</span>
      <span class="tok-o">}</span>
    <span class="tok-o">}</span>
  <span class="tok-o">}</span>

  <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">cancel</span><span class="tok-o">()</span> <span class="tok-k">=</span> <span class="tok-n">isRunning</span> <span class="tok-k">=</span> <span class="tok-kc">false</span>

  <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">snapshotState</span><span class="tok-o">(</span><span class="tok-n">snapshotCtx</span><span class="tok-k">:</span> <span class="tok-kt">FunctionSnapshotContext</span><span class="tok-o">)</span><span class="tok-k">:</span> <span class="tok-kt">Unit</span> <span class="tok-o">=</span> <span class="tok-o">{</span>
    <span class="tok-c1">// remove previous cnt</span>
    <span class="tok-n">offsetState</span><span class="tok-o">.</span><span class="tok-n">clear</span><span class="tok-o">()</span>
    <span class="tok-c1">// add current cnt</span>
    <span class="tok-n">offsetState</span><span class="tok-o">.</span><span class="tok-n">add</span><span class="tok-o">(</span><span class="tok-n">cnt</span><span class="tok-o">)</span>
  <span class="tok-o">}</span>

  <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">initializeState</span><span class="tok-o">(</span>
      <span class="tok-n">initCtx</span><span class="tok-k">:</span> <span class="tok-kt">FunctionInitializationContext</span><span class="tok-o">)</span><span class="tok-k">:</span> <span class="tok-kt">Unit</span> <span class="tok-o">=</span> <span class="tok-o">{</span>

    <span class="tok-k">val</span> <span class="tok-n">desc</span> <span class="tok-k">=</span> <span class="tok-k">new</span> <span class="tok-nc">ListStateDescriptor</span><span class="tok-o">[</span><span class="tok-kt">Long</span><span class="tok-o">](</span><span class="tok-s">&quot;offset&quot;</span><span class="tok-o">,</span> <span class="tok-n">classOf</span><span class="tok-o">[</span><span class="tok-kt">Long</span><span class="tok-o">])</span>
    <span class="tok-n">offsetState</span> <span class="tok-k">=</span> <span class="tok-n">initCtx</span><span class="tok-o">.</span><span class="tok-n">getOperatorStateStore</span><span class="tok-o">.</span><span class="tok-n">getListState</span><span class="tok-o">(</span><span class="tok-n">desc</span><span class="tok-o">)</span>
    <span class="tok-c1">// initialize cnt variable</span>
    <span class="tok-k">val</span> <span class="tok-n">it</span> <span class="tok-k">=</span> <span class="tok-n">offsetState</span><span class="tok-o">.</span><span class="tok-n">get</span><span class="tok-o">()</span>
    <span class="tok-n">cnt</span> <span class="tok-k">=</span> <span class="tok-k">if</span> <span class="tok-o">(</span><span class="tok-kc">null</span> <span class="tok-o">==</span> <span class="tok-n">it</span> <span class="tok-o">||</span> <span class="tok-o">!</span><span class="tok-n">it</span><span class="tok-o">.</span><span class="tok-n">iterator</span><span class="tok-o">().</span><span class="tok-n">hasNext</span><span class="tok-o">)</span> <span class="tok-o">{</span>
      <span class="tok-o">-</span><span class="tok-mi">1L</span>
    <span class="tok-o">}</span> <span class="tok-k">else</span> <span class="tok-o">{</span>
      <span class="tok-n">it</span><span class="tok-o">.</span><span class="tok-n">iterator</span><span class="tok-o">().</span><span class="tok-n">next</span><span class="tok-o">()</span>
    <span class="tok-o">}</span>
  <span class="tok-o">}</span>
<span class="tok-o">}</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_实现自定义sink函数">10.4. 实现自定义sink函数</h3>
<div class="paragraph">
<p>DataStream API中，任何运算符或者函数都可以向外部系统发送数据。DataStream不需要最终流向sink运算符。例如，我们可能实现了一个FlatMapFunction，这个函数将每一个接收到的数据通过HTTP POST请求发送出去，而不使用Collector发送到下一个运算符。DataStream API也提供了SinkFunction接口以及对应的rich版本RichSinkFunction抽象类。SinkFunction接口提供了一个方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-n">void</span> <span class="tok-n">invode</span><span class="tok-o">(</span><span class="tok-nc">IN</span> <span class="tok-n">value</span><span class="tok-o">,</span> <span class="tok-nc">Context</span> <span class="tok-n">ctx</span><span class="tok-o">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>SinkFunction的Context可以访问当前处理时间，当前水位线，以及数据的时间戳。</p>
</div>
<div class="paragraph">
<p>下面的例子展示了一个简单的SinkFunction，可以将传感器读数写入到socket中去。需要注意的是，我们需要在启动Flink程序前启动一个监听相关端口的进程。否则将会抛出ConnectException异常。可以运行“nc -l localhost 9191”命令。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">val</span> <span class="tok-n">readings</span><span class="tok-k">:</span> <span class="tok-kt">DataStream</span><span class="tok-o">[</span><span class="tok-kt">SensorReading</span><span class="tok-o">]</span> <span class="tok-k">=</span> <span class="tok-o">???</span>

<span class="tok-c1">// write the sensor readings to a socket</span>
<span class="tok-n">readings</span><span class="tok-o">.</span><span class="tok-n">addSink</span><span class="tok-o">(</span><span class="tok-k">new</span> <span class="tok-nc">SimpleSocketSink</span><span class="tok-o">(</span><span class="tok-s">&quot;localhost&quot;</span><span class="tok-o">,</span> <span class="tok-mi">9191</span><span class="tok-o">))</span>
  <span class="tok-c1">// set parallelism to 1 because only one thread can write to a socket</span>
  <span class="tok-o">.</span><span class="tok-n">setParallelism</span><span class="tok-o">(</span><span class="tok-mi">1</span><span class="tok-o">)</span>

<span class="tok-c1">// -----</span>

<span class="tok-k">class</span> <span class="tok-nc">SimpleSocketSink</span><span class="tok-o">(</span><span class="tok-k">val</span> <span class="tok-n">host</span><span class="tok-k">:</span> <span class="tok-kt">String</span><span class="tok-o">,</span> <span class="tok-k">val</span> <span class="tok-n">port</span><span class="tok-k">:</span> <span class="tok-kt">Int</span><span class="tok-o">)</span>
    <span class="tok-k">extends</span> <span class="tok-nc">RichSinkFunction</span><span class="tok-o">[</span><span class="tok-kt">SensorReading</span><span class="tok-o">]</span> <span class="tok-o">{</span>

  <span class="tok-k">var</span> <span class="tok-n">socket</span><span class="tok-k">:</span> <span class="tok-kt">Socket</span> <span class="tok-o">=</span> <span class="tok-k">_</span>
  <span class="tok-k">var</span> <span class="tok-n">writer</span><span class="tok-k">:</span> <span class="tok-kt">PrintStream</span> <span class="tok-o">=</span> <span class="tok-k">_</span>

  <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">open</span><span class="tok-o">(</span><span class="tok-n">config</span><span class="tok-k">:</span> <span class="tok-kt">Configuration</span><span class="tok-o">)</span><span class="tok-k">:</span> <span class="tok-kt">Unit</span> <span class="tok-o">=</span> <span class="tok-o">{</span>
    <span class="tok-c1">// open socket and writer</span>
    <span class="tok-n">socket</span> <span class="tok-k">=</span> <span class="tok-k">new</span> <span class="tok-nc">Socket</span><span class="tok-o">(</span><span class="tok-nc">InetAddress</span><span class="tok-o">.</span><span class="tok-n">getByName</span><span class="tok-o">(</span><span class="tok-n">host</span><span class="tok-o">),</span> <span class="tok-n">port</span><span class="tok-o">)</span>
    <span class="tok-n">writer</span> <span class="tok-k">=</span> <span class="tok-k">new</span> <span class="tok-nc">PrintStream</span><span class="tok-o">(</span><span class="tok-n">socket</span><span class="tok-o">.</span><span class="tok-n">getOutputStream</span><span class="tok-o">)</span>
  <span class="tok-o">}</span>

  <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">invoke</span><span class="tok-o">(</span>
      <span class="tok-n">value</span><span class="tok-k">:</span> <span class="tok-kt">SensorReading</span><span class="tok-o">,</span>
      <span class="tok-n">ctx</span><span class="tok-k">:</span> <span class="tok-kt">SinkFunction.Context</span><span class="tok-o">[</span><span class="tok-k">_</span><span class="tok-o">])</span><span class="tok-k">:</span> <span class="tok-kt">Unit</span> <span class="tok-o">=</span> <span class="tok-o">{</span>
    <span class="tok-c1">// write sensor reading to socket</span>
    <span class="tok-n">writer</span><span class="tok-o">.</span><span class="tok-n">println</span><span class="tok-o">(</span><span class="tok-n">value</span><span class="tok-o">.</span><span class="tok-n">toString</span><span class="tok-o">)</span>
    <span class="tok-n">writer</span><span class="tok-o">.</span><span class="tok-n">flush</span><span class="tok-o">()</span>
  <span class="tok-o">}</span>

  <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">close</span><span class="tok-o">()</span><span class="tok-k">:</span> <span class="tok-kt">Unit</span> <span class="tok-o">=</span> <span class="tok-o">{</span>
    <span class="tok-c1">// close writer and socket</span>
    <span class="tok-n">writer</span><span class="tok-o">.</span><span class="tok-n">close</span><span class="tok-o">()</span>
    <span class="tok-n">socket</span><span class="tok-o">.</span><span class="tok-n">close</span><span class="tok-o">()</span>
  <span class="tok-o">}</span>
<span class="tok-o">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>之前我们讨论过，端到端的一致性保证建立在sink连接器的属性上面。为了达到端到端的恰好处理一次语义的目的，应用程序需要幂等性的sink连接器或者事务性的sink连接器。上面例子中的SinkFunction既不是幂等写入也不是事务性的写入。由于socket具有只能添加（append-only）这样的属性，所以不可能实现幂等性的写入。又因为socket不具备内置的事务支持，所以事务性写入就只能使用Flink的WAL sink特性来实现了。接下来我们将学习如何实现幂等sink连接器和事务sink连接器。</p>
</div>
<div class="sect3">
<h4 id="_幂等sink连接器">10.4.1. 幂等sink连接器</h4>
<div class="paragraph">
<p>对于大多数应用，SinkFunction接口足以实现一个幂等性写入的sink连接器了。需要以下两个条件：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>结果数据必须具有确定性的key，在这个key上面幂等性更新才能实现。例如一个计算每分钟每个传感器的平均温度值的程序，确定性的key值可以是传感器的ID和每分钟的时间戳。确定性的key值，对于在故障恢复的场景下，能够正确的覆盖结果非常的重要。</p>
</li>
<li>
<p>外部系统支持针对每个key的更新，例如关系型数据库或者key-value存储。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>下面的例子展示了如何实现一个针对JDBC数据库的幂等写入sink连接器，这里使用的是Apache Derby数据库。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">val</span> <span class="tok-n">readings</span><span class="tok-k">:</span> <span class="tok-kt">DataStream</span><span class="tok-o">[</span><span class="tok-kt">SensorReading</span><span class="tok-o">]</span> <span class="tok-k">=</span> <span class="tok-o">???</span>

<span class="tok-c1">// write the sensor readings to a Derby table</span>
<span class="tok-n">readings</span><span class="tok-o">.</span><span class="tok-n">addSink</span><span class="tok-o">(</span><span class="tok-k">new</span> <span class="tok-nc">DerbyUpsertSink</span><span class="tok-o">)</span>

<span class="tok-c1">// -----</span>

<span class="tok-k">class</span> <span class="tok-nc">DerbyUpsertSink</span> <span class="tok-k">extends</span> <span class="tok-nc">RichSinkFunction</span><span class="tok-o">[</span><span class="tok-kt">SensorReading</span><span class="tok-o">]</span> <span class="tok-o">{</span>
  <span class="tok-k">var</span> <span class="tok-n">conn</span><span class="tok-k">:</span> <span class="tok-kt">Connection</span> <span class="tok-o">=</span> <span class="tok-k">_</span>
  <span class="tok-k">var</span> <span class="tok-n">insertStmt</span><span class="tok-k">:</span> <span class="tok-kt">PreparedStatement</span> <span class="tok-o">=</span> <span class="tok-k">_</span>
  <span class="tok-k">var</span> <span class="tok-n">updateStmt</span><span class="tok-k">:</span> <span class="tok-kt">PreparedStatement</span> <span class="tok-o">=</span> <span class="tok-k">_</span>

  <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">open</span><span class="tok-o">(</span><span class="tok-n">parameters</span><span class="tok-k">:</span> <span class="tok-kt">Configuration</span><span class="tok-o">)</span><span class="tok-k">:</span> <span class="tok-kt">Unit</span> <span class="tok-o">=</span> <span class="tok-o">{</span>
    <span class="tok-c1">// connect to embedded in-memory Derby</span>
    <span class="tok-n">conn</span> <span class="tok-k">=</span> <span class="tok-nc">DriverManager</span><span class="tok-o">.</span><span class="tok-n">getConnection</span><span class="tok-o">(</span>
       <span class="tok-s">&quot;jdbc:derby:memory:flinkExample&quot;</span><span class="tok-o">,</span>
       <span class="tok-k">new</span> <span class="tok-nc">Properties</span><span class="tok-o">())</span>
    <span class="tok-c1">// prepare insert and update statements</span>
    <span class="tok-n">insertStmt</span> <span class="tok-k">=</span> <span class="tok-n">conn</span><span class="tok-o">.</span><span class="tok-n">prepareStatement</span><span class="tok-o">(</span>
      <span class="tok-s">&quot;INSERT INTO Temperatures (sensor, temp) VALUES (?, ?)&quot;</span><span class="tok-o">)</span>
    <span class="tok-n">updateStmt</span> <span class="tok-k">=</span> <span class="tok-n">conn</span><span class="tok-o">.</span><span class="tok-n">prepareStatement</span><span class="tok-o">(</span>
      <span class="tok-s">&quot;UPDATE Temperatures SET temp = ? WHERE sensor = ?&quot;</span><span class="tok-o">)</span>
  <span class="tok-o">}</span>

  <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">invoke</span><span class="tok-o">(</span><span class="tok-n">r</span><span class="tok-k">:</span> <span class="tok-kt">SensorReading</span><span class="tok-o">,</span> <span class="tok-n">context</span><span class="tok-k">:</span> <span class="tok-kt">Context</span><span class="tok-o">[</span><span class="tok-k">_</span><span class="tok-o">])</span><span class="tok-k">:</span> <span class="tok-kt">Unit</span> <span class="tok-o">=</span> <span class="tok-o">{</span>
    <span class="tok-c1">// set parameters for update statement and execute it</span>
    <span class="tok-n">updateStmt</span><span class="tok-o">.</span><span class="tok-n">setDouble</span><span class="tok-o">(</span><span class="tok-mi">1</span><span class="tok-o">,</span> <span class="tok-n">r</span><span class="tok-o">.</span><span class="tok-n">temperature</span><span class="tok-o">)</span>
    <span class="tok-n">updateStmt</span><span class="tok-o">.</span><span class="tok-n">setString</span><span class="tok-o">(</span><span class="tok-mi">2</span><span class="tok-o">,</span> <span class="tok-n">r</span><span class="tok-o">.</span><span class="tok-n">id</span><span class="tok-o">)</span>
    <span class="tok-n">updateStmt</span><span class="tok-o">.</span><span class="tok-n">execute</span><span class="tok-o">()</span>
    <span class="tok-c1">// execute insert statement if update statement did not update any row</span>
    <span class="tok-k">if</span> <span class="tok-o">(</span><span class="tok-n">updateStmt</span><span class="tok-o">.</span><span class="tok-n">getUpdateCount</span> <span class="tok-o">==</span> <span class="tok-mi">0</span><span class="tok-o">)</span> <span class="tok-o">{</span>
      <span class="tok-c1">// set parameters for insert statement</span>
      <span class="tok-n">insertStmt</span><span class="tok-o">.</span><span class="tok-n">setString</span><span class="tok-o">(</span><span class="tok-mi">1</span><span class="tok-o">,</span> <span class="tok-n">r</span><span class="tok-o">.</span><span class="tok-n">id</span><span class="tok-o">)</span>
      <span class="tok-n">insertStmt</span><span class="tok-o">.</span><span class="tok-n">setDouble</span><span class="tok-o">(</span><span class="tok-mi">2</span><span class="tok-o">,</span> <span class="tok-n">r</span><span class="tok-o">.</span><span class="tok-n">temperature</span><span class="tok-o">)</span>
      <span class="tok-c1">// execute insert statement</span>
      <span class="tok-n">insertStmt</span><span class="tok-o">.</span><span class="tok-n">execute</span><span class="tok-o">()</span>
    <span class="tok-o">}</span>
  <span class="tok-o">}</span>

  <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">close</span><span class="tok-o">()</span><span class="tok-k">:</span> <span class="tok-kt">Unit</span> <span class="tok-o">=</span> <span class="tok-o">{</span>
    <span class="tok-n">insertStmt</span><span class="tok-o">.</span><span class="tok-n">close</span><span class="tok-o">()</span>
    <span class="tok-n">updateStmt</span><span class="tok-o">.</span><span class="tok-n">close</span><span class="tok-o">()</span>
    <span class="tok-n">conn</span><span class="tok-o">.</span><span class="tok-n">close</span><span class="tok-o">()</span>
  <span class="tok-o">}</span>
<span class="tok-o">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>由于Apache Derby并没有提供内置的UPSERT方法，所以这个sink连接器实现了UPSERT写。具体实现方法是首先去尝试更新一行数据，如果这行数据不存在，则插入新的一行数据。</p>
</div>
</div>
<div class="sect3">
<h4 id="_事务性sink连接器">10.4.2. 事务性sink连接器</h4>
<div class="paragraph">
<p>事务写入sink连接器需要和Flink的检查点机制集成，因为只有在检查点成功完成以后，事务写入sink连接器才会向外部系统commit数据。</p>
</div>
<div class="paragraph">
<p>为了简化事务性sink的实现，Flink提供了两个模版用来实现自定义sink运算符。这两个模版都实现了CheckpointListener接口。CheckpointListener接口将会从JobManager接收到检查点完成的通知。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>GenericWriteAheadSink模版会收集检查点之前的所有的数据，并将数据存储到sink任务的运算符状态中。状态保存到了检查点中，并在任务故障的情况下恢复。当任务接收到检查点完成的通知时，任务会将所有的数据写入到外部系统中。</p>
</li>
<li>
<p>TwoPhaseCommitSinkFunction模版利用了外部系统的事务特性。对于每一个检查点，任务首先开始一个新的事务，并将接下来所有的数据都写到外部系统的当前事务上下文中去。当任务接收到检查点完成的通知时，sink连接器将会commit这个事务。</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="_genericwriteaheadsink">GENERICWRITEAHEADSINK</h5>
<div class="paragraph">
<p>GenericWriteAheadSink使得sink运算符可以很方便的实现。这个运算符和Flink的检查点机制集成使用，目标是将每一条数据恰好一次写入到外部系统中去。需要注意的是，在发生故障的情况下，write-ahead log sink可能会不止一次的发送相同的数据。所以GenericWriteAheadSink无法提供完美无缺的恰好处理一次语义的一致性保证，而是仅能提供at-least-once这样的保证。我们接下来详细的讨论这些场景。</p>
</div>
<div class="paragraph">
<p>GenericWriteAheadSink的原理是将接收到的所有数据都追加到有检查点分割好的预写式日志中去。每当sink运算符碰到检查点屏障，运算符将会开辟一个新的section，并将接下来的所有数据都追加到新的section中去。WAL（预写式日志）将会保存到运算符状态中。由于log能被恢复，所有不会有数据丢失。</p>
</div>
<div class="paragraph">
<p>当GenericWriteAheadSink接收到检查点完成的通知时，将会发送对应检查点的WAL中存储的所有数据。当所有数据发送成功，对应的检查点必须在内部提交。</p>
</div>
<div class="paragraph">
<p>检查点的提交分两步。第一步，sink持久化检查点被提交的信息。第二步，删除WAL中所有的数据。我们不能将commit信息保存在Flink应用程序状态中，因为状态不是持久化的，会在故障恢复时重置状态。相反，GenericWriteAheadSink依赖于可插拔的组件在一个外部持久化存储中存储和查找提交信息。这个组件就是CheckpointCommitter。</p>
</div>
<div class="paragraph">
<p>继承GenericWriteAheadSink的运算符需要提供三个构造器函数。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>CheckpointCommitter</p>
</li>
<li>
<p>TypeSerializer，用来序列化输入数据。</p>
</li>
<li>
<p>一个job ID，传给CheckpointCommitter，当应用重启时可以识别commit信息。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>还有，write-ahead运算符需要实现一个单独的方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="java"><span></span><span class="tok-kt">boolean</span> <span class="tok-nf">sendValues</span><span class="tok-o">(</span><span class="tok-n">Iterable</span><span class="tok-o">&lt;</span><span class="tok-n">IN</span><span class="tok-o">&gt;</span> <span class="tok-n">values</span><span class="tok-o">,</span> <span class="tok-kt">long</span> <span class="tok-n">chkpntId</span><span class="tok-o">,</span> <span class="tok-kt">long</span> <span class="tok-n">timestamp</span><span class="tok-o">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>当检查点完成时，GenericWriteAheadSink调用sendValues()方法来将数据写入到外部存储系统中。这个方法接收一个检查点对应的所有数据的迭代器，检查点的ID，检查点被处理时的时间戳。当数据写入成功时，方法必须返回true，写入失败返回false。</p>
</div>
<div class="paragraph">
<p>下面的例子展示了如何实现一个写入到标准输出的write-ahead sink。它使用了FileCheckpointCommitter。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">val</span> <span class="tok-n">readings</span><span class="tok-k">:</span> <span class="tok-kt">DataStream</span><span class="tok-o">[</span><span class="tok-kt">SensorReading</span><span class="tok-o">]</span> <span class="tok-k">=</span> <span class="tok-o">???</span>

<span class="tok-c1">// write the sensor readings to the standard out via a write-ahead log</span>
<span class="tok-n">readings</span><span class="tok-o">.</span><span class="tok-n">transform</span><span class="tok-o">(</span>
  <span class="tok-s">&quot;WriteAheadSink&quot;</span><span class="tok-o">,</span> <span class="tok-k">new</span> <span class="tok-nc">SocketWriteAheadSink</span><span class="tok-o">)</span>

<span class="tok-c1">// -----</span>

<span class="tok-k">class</span> <span class="tok-nc">StdOutWriteAheadSink</span> <span class="tok-k">extends</span> <span class="tok-nc">GenericWriteAheadSink</span><span class="tok-o">[</span><span class="tok-kt">SensorReading</span><span class="tok-o">](</span>
    <span class="tok-c1">// CheckpointCommitter that commits checkpoints to the local filesystem</span>
    <span class="tok-k">new</span> <span class="tok-nc">FileCheckpointCommitter</span><span class="tok-o">(</span><span class="tok-nc">System</span><span class="tok-o">.</span><span class="tok-n">getProperty</span><span class="tok-o">(</span><span class="tok-s">&quot;java.io.tmpdir&quot;</span><span class="tok-o">)),</span>
    <span class="tok-c1">// Serializer for records</span>
    <span class="tok-n">createTypeInformation</span><span class="tok-o">[</span><span class="tok-kt">SensorReading</span><span class="tok-o">]</span>
      <span class="tok-o">.</span><span class="tok-n">createSerializer</span><span class="tok-o">(</span><span class="tok-k">new</span> <span class="tok-nc">ExecutionConfig</span><span class="tok-o">),</span>
    <span class="tok-c1">// Random JobID used by the CheckpointCommitter</span>
    <span class="tok-nc">UUID</span><span class="tok-o">.</span><span class="tok-n">randomUUID</span><span class="tok-o">.</span><span class="tok-n">toString</span><span class="tok-o">)</span> <span class="tok-o">{</span>

  <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">sendValues</span><span class="tok-o">(</span>
      <span class="tok-n">readings</span><span class="tok-k">:</span> <span class="tok-kt">Iterable</span><span class="tok-o">[</span><span class="tok-kt">SensorReading</span><span class="tok-o">],</span>
      <span class="tok-n">checkpointId</span><span class="tok-k">:</span> <span class="tok-kt">Long</span><span class="tok-o">,</span>
      <span class="tok-n">timestamp</span><span class="tok-k">:</span> <span class="tok-kt">Long</span><span class="tok-o">)</span><span class="tok-k">:</span> <span class="tok-kt">Boolean</span> <span class="tok-o">=</span> <span class="tok-o">{</span>

    <span class="tok-k">for</span> <span class="tok-o">(</span><span class="tok-n">r</span> <span class="tok-k">&lt;-</span> <span class="tok-n">readings</span><span class="tok-o">.</span><span class="tok-n">asScala</span><span class="tok-o">)</span> <span class="tok-o">{</span>
      <span class="tok-c1">// write record to standard out</span>
      <span class="tok-n">println</span><span class="tok-o">(</span><span class="tok-n">r</span><span class="tok-o">)</span>
    <span class="tok-o">}</span>
    <span class="tok-kc">true</span>
  <span class="tok-o">}</span>
<span class="tok-o">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>之前我们讲过，GenericWriteAheadSink无法提供完美的exactly-once保证。有两个故障状况会导致数据可能被发送不止一次。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>当任务执行sendValues()方法时，程序挂掉了。如果外部系统无法原子性的写入所有数据（要么都写入要么都不写），一些数据可能会写入，而另一些数据并没有被写入。由于checkpoint还没有commit，所以在任务恢复的过程中一些数据可能会被再次写入。</p>
</li>
<li>
<p>所有数据都写入成功了，sendValues()方法也返回true了；但在CheckpointCommitter方法被调用之前程序挂了，或者CheckpointCommitter在commit检查点时失败了。那么在恢复的过程中，所有未被提交的检查点将会被重新写入。</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_twophasecommitsinkfunction">TWOPHASECOMMITSINKFUNCTION</h5>
<div class="paragraph">
<p>Flink提供了TwoPhaseCommitSinkFunction接口来简化sink函数的实现。这个接口保证了端到端的exactly-once语义。2PC sink函数是否提供这样的一致性保证取决于我们的实现细节。我们需要讨论一个问题：“2PC协议是否开销太大？”</p>
</div>
<div class="paragraph">
<p>通常来讲，为了保证分布式系统的一致性，2PC是一个非常昂贵的方法。尽管如此，在Flink的语境下，2PC协议针对每一个检查点只运行一次。TwoPhaseCommitSinkFunction和WAL sink很相似，不同点在于前者不会将数据收集到state中，而是会写入到外部系统事务的上下文中。</p>
</div>
<div class="paragraph">
<p>TwoPhaseCommitSinkFunction实现了以下协议。在sink任务发送出第一条数据之前，任务将在外部系统中开始一个事务，所有接下来的数据将被写入这个事务的上下文中。当JobManager初始化检查点并将检查点屏障插入到流中的时候，2PC协议的投票阶段开始。当运算符接收到检查点屏障，运算符将保存它的状态，当保存完成时，运算符将发送一个acknowledgement信息给JobManager。当sink任务接收到检查点屏障时，运算符将会持久化它的状态，并准备提交当前的事务，以及acknowledge JobManager中的检查点。发送给JobManager的acknowledgement信息类似于2PC协议中的commit投票。sink任务还不能提交事务，因为它还没有保证所有的任务都已经完成了它们的检查点操作。sink任务也会为下一个检查点屏障之前的所有数据开始一个新的事务。</p>
</div>
<div class="paragraph">
<p>当JobManager成功接收到所有任务实例发出的检查点操作成功的通知时，JobManager将会把检查点完成的通知发送给所有感兴趣的任务。这里的通知对应于2PC协议的提交命令。当sink任务接收到通知时，它将commit所有处于开启状态的事务。一旦sink任务acknowledge了检查点操作，它必须能够commit对应的事务，即使任务发生故障。如果commit失败，数据将会丢失。</p>
</div>
<div class="paragraph">
<p>让我们总结一下外部系统需要满足什么样的要求：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>外部系统必须提供事务支持，或者sink的实现能在外部系统上模拟事务功能。</p>
</li>
<li>
<p>在检查点操作期间，事务必须处于open状态，并接收这段时间数据的持续写入。</p>
</li>
<li>
<p>事务必须等到检查点操作完成的通知到来才可以提交。在恢复周期中，可能需要一段时间等待。如果sink系统关闭了事务（例如超时了），那么未被commit的数据将会丢失。</p>
</li>
<li>
<p>sink必须在进程挂掉后能够恢复事务。一些sink系统会提供事务ID，用来commit或者abort一个开始的事务。</p>
</li>
<li>
<p>commit一个事务必须是一个幂等性操作。sink系统或者外部系统能够观察到事务已经被提交，或者重复提交并没有副作用。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>下面的例子可能会让上面的一些概念好理解一些。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">class</span> <span class="tok-nc">TransactionalFileSink</span><span class="tok-o">(</span><span class="tok-k">val</span> <span class="tok-n">targetPath</span><span class="tok-k">:</span> <span class="tok-kt">String</span><span class="tok-o">,</span> <span class="tok-k">val</span> <span class="tok-n">tempPath</span><span class="tok-k">:</span> <span class="tok-kt">String</span><span class="tok-o">)</span>
    <span class="tok-k">extends</span> <span class="tok-nc">TwoPhaseCommitSinkFunction</span><span class="tok-o">[(</span><span class="tok-kt">String</span>, <span class="tok-kt">Double</span><span class="tok-o">)</span>, <span class="tok-kt">String</span>, <span class="tok-kt">Void</span><span class="tok-o">](</span>
      <span class="tok-n">createTypeInformation</span><span class="tok-o">[</span><span class="tok-kt">String</span><span class="tok-o">].</span><span class="tok-n">createSerializer</span><span class="tok-o">(</span><span class="tok-k">new</span> <span class="tok-nc">ExecutionConfig</span><span class="tok-o">),</span>
      <span class="tok-n">createTypeInformation</span><span class="tok-o">[</span><span class="tok-kt">Void</span><span class="tok-o">].</span><span class="tok-n">createSerializer</span><span class="tok-o">(</span><span class="tok-k">new</span> <span class="tok-nc">ExecutionConfig</span><span class="tok-o">))</span> <span class="tok-o">{</span>

  <span class="tok-k">var</span> <span class="tok-n">transactionWriter</span><span class="tok-k">:</span> <span class="tok-kt">BufferedWriter</span> <span class="tok-o">=</span> <span class="tok-k">_</span>

  <span class="tok-cm">/** Creates a temporary file for a transaction into which the records are</span>
<span class="tok-cm">    * written.</span>
<span class="tok-cm">    */</span>
  <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">beginTransaction</span><span class="tok-o">()</span><span class="tok-k">:</span> <span class="tok-kt">String</span> <span class="tok-o">=</span> <span class="tok-o">{</span>
    <span class="tok-c1">// path of transaction file is built from current time and task index</span>
    <span class="tok-k">val</span> <span class="tok-n">timeNow</span> <span class="tok-k">=</span> <span class="tok-nc">LocalDateTime</span><span class="tok-o">.</span><span class="tok-n">now</span><span class="tok-o">(</span><span class="tok-nc">ZoneId</span><span class="tok-o">.</span><span class="tok-n">of</span><span class="tok-o">(</span><span class="tok-s">&quot;UTC&quot;</span><span class="tok-o">))</span>
      <span class="tok-o">.</span><span class="tok-n">format</span><span class="tok-o">(</span><span class="tok-nc">DateTimeFormatter</span><span class="tok-o">.</span><span class="tok-nc">ISO_LOCAL_DATE_TIME</span><span class="tok-o">)</span>
    <span class="tok-k">val</span> <span class="tok-n">taskIdx</span> <span class="tok-k">=</span> <span class="tok-k">this</span><span class="tok-o">.</span><span class="tok-n">getRuntimeContext</span><span class="tok-o">.</span><span class="tok-n">getIndexOfThisSubtask</span>
    <span class="tok-k">val</span> <span class="tok-n">transactionFile</span> <span class="tok-k">=</span> <span class="tok-s">s&quot;</span><span class="tok-si">$timeNow</span><span class="tok-s">-</span><span class="tok-si">$taskIdx</span><span class="tok-s">&quot;</span>

    <span class="tok-c1">// create transaction file and writer</span>
    <span class="tok-k">val</span> <span class="tok-n">tFilePath</span> <span class="tok-k">=</span> <span class="tok-nc">Paths</span><span class="tok-o">.</span><span class="tok-n">get</span><span class="tok-o">(</span><span class="tok-s">s&quot;</span><span class="tok-si">$tempPath</span><span class="tok-s">/</span><span class="tok-si">$transactionFile</span><span class="tok-s">&quot;</span><span class="tok-o">)</span>
    <span class="tok-nc">Files</span><span class="tok-o">.</span><span class="tok-n">createFile</span><span class="tok-o">(</span><span class="tok-n">tFilePath</span><span class="tok-o">)</span>
    <span class="tok-k">this</span><span class="tok-o">.</span><span class="tok-n">transactionWriter</span> <span class="tok-k">=</span> <span class="tok-nc">Files</span><span class="tok-o">.</span><span class="tok-n">newBufferedWriter</span><span class="tok-o">(</span><span class="tok-n">tFilePath</span><span class="tok-o">)</span>
    <span class="tok-n">println</span><span class="tok-o">(</span><span class="tok-s">s&quot;Creating Transaction File: </span><span class="tok-si">$tFilePath</span><span class="tok-s">&quot;</span><span class="tok-o">)</span>
    <span class="tok-c1">// name of transaction file is returned to later identify the transaction</span>
    <span class="tok-n">transactionFile</span>
  <span class="tok-o">}</span>

  <span class="tok-cm">/** Write record into the current transaction file. */</span>
  <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">invoke</span><span class="tok-o">(</span>
      <span class="tok-n">transaction</span><span class="tok-k">:</span> <span class="tok-kt">String</span><span class="tok-o">,</span>
      <span class="tok-n">value</span><span class="tok-k">:</span> <span class="tok-o">(</span><span class="tok-kt">String</span><span class="tok-o">,</span> <span class="tok-kt">Double</span><span class="tok-o">),</span>
      <span class="tok-n">context</span><span class="tok-k">:</span> <span class="tok-kt">Context</span><span class="tok-o">[</span><span class="tok-k">_</span><span class="tok-o">])</span><span class="tok-k">:</span> <span class="tok-kt">Unit</span> <span class="tok-o">=</span> <span class="tok-o">{</span>
    <span class="tok-n">transactionWriter</span><span class="tok-o">.</span><span class="tok-n">write</span><span class="tok-o">(</span><span class="tok-n">value</span><span class="tok-o">.</span><span class="tok-n">toString</span><span class="tok-o">)</span>
    <span class="tok-n">transactionWriter</span><span class="tok-o">.</span><span class="tok-n">write</span><span class="tok-o">(</span><span class="tok-sc">&#39;\n&#39;</span><span class="tok-o">)</span>
  <span class="tok-o">}</span>

  <span class="tok-cm">/** Flush and close the current transaction file. */</span>
  <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">preCommit</span><span class="tok-o">(</span><span class="tok-n">transaction</span><span class="tok-k">:</span> <span class="tok-kt">String</span><span class="tok-o">)</span><span class="tok-k">:</span> <span class="tok-kt">Unit</span> <span class="tok-o">=</span> <span class="tok-o">{</span>
    <span class="tok-n">transactionWriter</span><span class="tok-o">.</span><span class="tok-n">flush</span><span class="tok-o">()</span>
    <span class="tok-n">transactionWriter</span><span class="tok-o">.</span><span class="tok-n">close</span><span class="tok-o">()</span>
  <span class="tok-o">}</span>

  <span class="tok-cm">/** Commit a transaction by moving the precommitted transaction file</span>
<span class="tok-cm">    * to the target directory.</span>
<span class="tok-cm">    */</span>
  <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">commit</span><span class="tok-o">(</span><span class="tok-n">transaction</span><span class="tok-k">:</span> <span class="tok-kt">String</span><span class="tok-o">)</span><span class="tok-k">:</span> <span class="tok-kt">Unit</span> <span class="tok-o">=</span> <span class="tok-o">{</span>
    <span class="tok-k">val</span> <span class="tok-n">tFilePath</span> <span class="tok-k">=</span> <span class="tok-nc">Paths</span><span class="tok-o">.</span><span class="tok-n">get</span><span class="tok-o">(</span><span class="tok-s">s&quot;</span><span class="tok-si">$tempPath</span><span class="tok-s">/</span><span class="tok-si">$transaction</span><span class="tok-s">&quot;</span><span class="tok-o">)</span>
    <span class="tok-c1">// check if the file exists to ensure that the commit is idempotent</span>
    <span class="tok-k">if</span> <span class="tok-o">(</span><span class="tok-nc">Files</span><span class="tok-o">.</span><span class="tok-n">exists</span><span class="tok-o">(</span><span class="tok-n">tFilePath</span><span class="tok-o">))</span> <span class="tok-o">{</span>
      <span class="tok-k">val</span> <span class="tok-n">cFilePath</span> <span class="tok-k">=</span> <span class="tok-nc">Paths</span><span class="tok-o">.</span><span class="tok-n">get</span><span class="tok-o">(</span><span class="tok-s">s&quot;</span><span class="tok-si">$targetPath</span><span class="tok-s">/</span><span class="tok-si">$transaction</span><span class="tok-s">&quot;</span><span class="tok-o">)</span>
      <span class="tok-nc">Files</span><span class="tok-o">.</span><span class="tok-n">move</span><span class="tok-o">(</span><span class="tok-n">tFilePath</span><span class="tok-o">,</span> <span class="tok-n">cFilePath</span><span class="tok-o">)</span>
    <span class="tok-o">}</span>
  <span class="tok-o">}</span>

  <span class="tok-cm">/** Aborts a transaction by deleting the transaction file. */</span>
  <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">abort</span><span class="tok-o">(</span><span class="tok-n">transaction</span><span class="tok-k">:</span> <span class="tok-kt">String</span><span class="tok-o">)</span><span class="tok-k">:</span> <span class="tok-kt">Unit</span> <span class="tok-o">=</span> <span class="tok-o">{</span>
    <span class="tok-k">val</span> <span class="tok-n">tFilePath</span> <span class="tok-k">=</span> <span class="tok-nc">Paths</span><span class="tok-o">.</span><span class="tok-n">get</span><span class="tok-o">(</span><span class="tok-s">s&quot;</span><span class="tok-si">$tempPath</span><span class="tok-s">/</span><span class="tok-si">$transaction</span><span class="tok-s">&quot;</span><span class="tok-o">)</span>
    <span class="tok-k">if</span> <span class="tok-o">(</span><span class="tok-nc">Files</span><span class="tok-o">.</span><span class="tok-n">exists</span><span class="tok-o">(</span><span class="tok-n">tFilePath</span><span class="tok-o">))</span> <span class="tok-o">{</span>
      <span class="tok-nc">Files</span><span class="tok-o">.</span><span class="tok-n">delete</span><span class="tok-o">(</span><span class="tok-n">tFilePath</span><span class="tok-o">)</span>
    <span class="tok-o">}</span>
  <span class="tok-o">}</span>
<span class="tok-o">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>TwoPhaseCommitSinkFunction[IN, TXN, CONTEXT]包含如下三个范型参数：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>IN表示输入数据的类型。</p>
</li>
<li>
<p>TXN定义了一个事务的标识符，可以用来识别和恢复事务。</p>
</li>
<li>
<p>CONTEXT定义了自定义的上下文。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>TwoPhaseCommitSinkFunction的构造器需要两个TypeSerializer。一个是TXN的类型，另一个是CONTEXT的类型。</p>
</div>
<div class="paragraph">
<p>最后，TwoPhaseCommitSinkFunction定义了五个需要实现的方法：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>beginTransaction(): TXN开始一个事务，并返回事务的标识符。</p>
</li>
<li>
<p>invoke(txn: TXN, value: IN, context: Context[_]): Unit将值写入到当前事务中。</p>
</li>
<li>
<p>preCommit(txn: TXN): Unit预提交一个事务。一个预提交的事务不会接收新的写入。</p>
</li>
<li>
<p>commit(txn: TXN): Unit提交一个事务。这个操作必须是幂等的。</p>
</li>
<li>
<p>abort(txn: TXN): Unit终止一个事务。</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_flink_cep简介">11. Flink CEP简介</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>什么是复杂事件CEP？</strong></p>
</div>
<div class="paragraph">
<p>一个或多个由简单事件构成的事件流通过一定的规则匹配，然后输出用户想得到的数据，满足规则的复杂事件。</p>
</div>
<div class="paragraph">
<p><strong>特征：</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>目标：从有序的简单事件流中发现一些高阶特征</p>
</li>
<li>
<p>输入：一个或多个由简单事件构成的事件流</p>
</li>
<li>
<p>处理：识别简单事件之间的内在联系，多个符合一定规则的简单事件构成复杂事件</p>
</li>
<li>
<p>输出：满足规则的复杂事件</p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="images/cep1.jpg" alt="cep1">
</div>
</div>
<div class="paragraph">
<p>CEP用于分析低延迟、频繁产生的不同来源的事件流。CEP可以帮助在复杂的、不相关的事件流中找出有意义的模式和复杂的关系，以接近实时或准实时的获得通知并阻止一些行为。</p>
</div>
<div class="paragraph">
<p>CEP支持在流上进行模式匹配，根据模式的条件不同，分为连续的条件或不连续的条件；模式的条件允许有时间的限制，当在条件范围内没有达到满足的条件时，会导致模式匹配超时。</p>
</div>
<div class="paragraph">
<p>看起来很简单，但是它有很多不同的功能：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>输入的流数据，尽快产生结果</p>
</li>
<li>
<p>在2个event流上，基于时间进行聚合类的计算</p>
</li>
<li>
<p>提供实时/准实时的警告和通知</p>
</li>
<li>
<p>在多样的数据源中产生关联并分析模式</p>
</li>
<li>
<p>高吞吐、低延迟的处理</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>市场上有多种CEP的解决方案，例如Spark、Samza、Beam等，但他们都没有提供专门的library支持。但是Flink提供了专门的CEP library。</p>
</div>
<div class="paragraph">
<p><strong>Flink CEP</strong></p>
</div>
<div class="paragraph">
<p>Flink为CEP提供了专门的Flink CEP library，它包含如下组件：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Event Stream</p>
</li>
<li>
<p>pattern定义</p>
</li>
<li>
<p>pattern检测</p>
</li>
<li>
<p>生成Alert</p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="images/cep6.png" alt="cep6">
</div>
</div>
<div class="paragraph">
<p>首先，开发人员要在DataStream流上定义出模式条件，之后Flink CEP引擎进行模式检测，必要时生成告警。</p>
</div>
<div class="paragraph">
<p>为了使用Flink CEP，我们需要导入依赖：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="xml"><span></span><span class="tok-nt">&lt;dependency&gt;</span>
  <span class="tok-nt">&lt;groupId&gt;</span>org.apache.flink<span class="tok-nt">&lt;/groupId&gt;</span>
  <span class="tok-nt">&lt;artifactId&gt;</span>flink-cep-scala_${scala.binary.version}<span class="tok-nt">&lt;/artifactId&gt;</span>
  <span class="tok-nt">&lt;version&gt;</span>${flink.version}<span class="tok-nt">&lt;/version&gt;</span>
<span class="tok-nt">&lt;/dependency&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Event Streams</strong></p>
</div>
<div class="paragraph">
<p>登录事件流</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">case</span> <span class="tok-k">class</span> <span class="tok-nc">LoginEvent</span><span class="tok-o">(</span><span class="tok-n">userId</span><span class="tok-k">:</span> <span class="tok-kt">String</span><span class="tok-o">,</span> <span class="tok-n">ip</span><span class="tok-k">:</span> <span class="tok-kt">String</span><span class="tok-o">,</span> <span class="tok-n">eventType</span><span class="tok-k">:</span> <span class="tok-kt">String</span><span class="tok-o">,</span> <span class="tok-n">eventTime</span><span class="tok-k">:</span> <span class="tok-kt">String</span><span class="tok-o">)</span>

<span class="tok-k">val</span> <span class="tok-n">env</span> <span class="tok-k">=</span> <span class="tok-nc">StreamExecutionEnvironment</span><span class="tok-o">.</span><span class="tok-n">getExecutionEnvironment</span>
<span class="tok-n">env</span><span class="tok-o">.</span><span class="tok-n">setStreamTimeCharacteristic</span><span class="tok-o">(</span><span class="tok-nc">TimeCharacteristic</span><span class="tok-o">.</span><span class="tok-nc">EventTime</span><span class="tok-o">)</span>
<span class="tok-n">env</span><span class="tok-o">.</span><span class="tok-n">setParallelism</span><span class="tok-o">(</span><span class="tok-mi">1</span><span class="tok-o">)</span>

<span class="tok-k">val</span> <span class="tok-n">loginEventStream</span> <span class="tok-k">=</span> <span class="tok-n">env</span><span class="tok-o">.</span><span class="tok-n">fromCollection</span><span class="tok-o">(</span><span class="tok-nc">List</span><span class="tok-o">(</span>
  <span class="tok-nc">LoginEvent</span><span class="tok-o">(</span><span class="tok-s">&quot;1&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;192.168.0.1&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;fail&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;1558430842&quot;</span><span class="tok-o">),</span>
  <span class="tok-nc">LoginEvent</span><span class="tok-o">(</span><span class="tok-s">&quot;1&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;192.168.0.2&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;fail&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;1558430843&quot;</span><span class="tok-o">),</span>
  <span class="tok-nc">LoginEvent</span><span class="tok-o">(</span><span class="tok-s">&quot;1&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;192.168.0.3&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;fail&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;1558430844&quot;</span><span class="tok-o">),</span>
  <span class="tok-nc">LoginEvent</span><span class="tok-o">(</span><span class="tok-s">&quot;2&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;192.168.10.10&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;success&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;1558430845&quot;</span><span class="tok-o">)</span>
<span class="tok-o">)).</span><span class="tok-n">assignAscendingTimestamps</span><span class="tok-o">(</span><span class="tok-k">_</span><span class="tok-o">.</span><span class="tok-n">eventTime</span><span class="tok-o">.</span><span class="tok-n">toLong</span> <span class="tok-o">*</span> <span class="tok-mi">1000</span><span class="tok-o">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Pattern API</strong></p>
</div>
<div class="paragraph">
<p>每个Pattern都应该包含几个步骤，或者叫做state。从一个state到另一个state，通常我们需要定义一些条件，例如下列的代码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">val</span> <span class="tok-n">loginFailPattern</span> <span class="tok-k">=</span> <span class="tok-nc">Pattern</span><span class="tok-o">.</span><span class="tok-n">begin</span><span class="tok-o">[</span><span class="tok-kt">LoginEvent</span><span class="tok-o">](</span><span class="tok-s">&quot;begin&quot;</span><span class="tok-o">)</span>
  <span class="tok-o">.</span><span class="tok-n">where</span><span class="tok-o">(</span><span class="tok-k">_</span><span class="tok-o">.</span><span class="tok-n">eventType</span><span class="tok-o">.</span><span class="tok-n">equals</span><span class="tok-o">(</span><span class="tok-s">&quot;fail&quot;</span><span class="tok-o">))</span>
  <span class="tok-o">.</span><span class="tok-n">next</span><span class="tok-o">(</span><span class="tok-s">&quot;next&quot;</span><span class="tok-o">)</span>
  <span class="tok-o">.</span><span class="tok-n">where</span><span class="tok-o">(</span><span class="tok-k">_</span><span class="tok-o">.</span><span class="tok-n">eventType</span><span class="tok-o">.</span><span class="tok-n">equals</span><span class="tok-o">(</span><span class="tok-s">&quot;fail&quot;</span><span class="tok-o">))</span>
  <span class="tok-o">.</span><span class="tok-n">within</span><span class="tok-o">(</span><span class="tok-nc">Time</span><span class="tok-o">.</span><span class="tok-n">seconds</span><span class="tok-o">(</span><span class="tok-mi">10</span><span class="tok-o">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>每个state都应该有一个标示：</p>
</div>
<div class="paragraph">
<p>例如: <code>.begin[LoginEvent]("begin")</code>中的"begin"</p>
</div>
<div class="paragraph">
<p>每个state都需要有一个唯一的名字，而且需要一个filter来过滤条件，这个过滤条件定义事件需要符合的条件</p>
</div>
<div class="paragraph">
<p>例如: <code>.where(_.eventType.equals("fail"))</code></p>
</div>
<div class="paragraph">
<p>我们也可以通过subtype来限制event的子类型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-n">start</span><span class="tok-o">.</span><span class="tok-n">subtype</span><span class="tok-o">(</span><span class="tok-nc">SubEvent</span><span class="tok-o">.</span><span class="tok-n">class</span><span class="tok-o">).</span><span class="tok-n">where</span><span class="tok-o">(...);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>事实上，你可以多次调用subtype和where方法；而且如果where条件是不相关的，你可以通过or来指定一个单独的filter函数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-n">pattern</span><span class="tok-o">.</span><span class="tok-n">where</span><span class="tok-o">(...).</span><span class="tok-n">or</span><span class="tok-o">(...);</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>之后，我们可以在此条件基础上，通过next或者followedBy方法切换到下一个state，next的意思是说上一步符合条件的元素之后紧挨着的元素；而followedBy并不要求一定是挨着的元素。这两者分别称为严格近邻和非严格近邻。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">val</span> <span class="tok-n">strictNext</span> <span class="tok-k">=</span> <span class="tok-n">start</span><span class="tok-o">.</span><span class="tok-n">next</span><span class="tok-o">(</span><span class="tok-s">&quot;middle&quot;</span><span class="tok-o">)</span>
<span class="tok-k">val</span> <span class="tok-n">nonStrictNext</span> <span class="tok-k">=</span> <span class="tok-n">start</span><span class="tok-o">.</span><span class="tok-n">followedBy</span><span class="tok-o">(</span><span class="tok-s">&quot;middle&quot;</span><span class="tok-o">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>最后，我们可以将所有的Pattern的条件限定在一定的时间范围内：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-n">next</span><span class="tok-o">.</span><span class="tok-n">within</span><span class="tok-o">(</span><span class="tok-nc">Time</span><span class="tok-o">.</span><span class="tok-n">seconds</span><span class="tok-o">(</span><span class="tok-mi">10</span><span class="tok-o">))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这个时间可以是Processing Time，也可以是Event Time。</p>
</div>
<div class="paragraph">
<p><strong>Pattern 检测</strong></p>
</div>
<div class="paragraph">
<p>通过一个input DataStream以及刚刚我们定义的Pattern，我们可以创建一个PatternStream：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">val</span> <span class="tok-n">input</span> <span class="tok-k">=</span> <span class="tok-o">...</span>
<span class="tok-k">val</span> <span class="tok-n">pattern</span> <span class="tok-k">=</span> <span class="tok-o">...</span>

<span class="tok-k">val</span> <span class="tok-n">patternStream</span> <span class="tok-k">=</span> <span class="tok-nc">CEP</span><span class="tok-o">.</span><span class="tok-n">pattern</span><span class="tok-o">(</span><span class="tok-n">input</span><span class="tok-o">,</span> <span class="tok-n">pattern</span><span class="tok-o">)</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">val</span> <span class="tok-n">patternStream</span> <span class="tok-k">=</span> <span class="tok-nc">CEP</span><span class="tok-o">.</span><span class="tok-n">pattern</span><span class="tok-o">(</span><span class="tok-n">loginEventStream</span><span class="tok-o">.</span><span class="tok-n">keyBy</span><span class="tok-o">(</span><span class="tok-k">_</span><span class="tok-o">.</span><span class="tok-n">userId</span><span class="tok-o">),</span> <span class="tok-n">loginFailPattern</span><span class="tok-o">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>一旦获得PatternStream，我们就可以通过select或flatSelect，从一个Map序列找到我们需要的告警信息。</p>
</div>
<div class="paragraph">
<p><strong>select</strong></p>
</div>
<div class="paragraph">
<p>select方法需要实现一个PatternSelectFunction，通过select方法来输出需要的警告。它接受一个Map对，包含string/event，其中key为state的名字，event则为真是的Event。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">val</span> <span class="tok-n">loginFailDataStream</span> <span class="tok-k">=</span> <span class="tok-n">patternStream</span>
  <span class="tok-o">.</span><span class="tok-n">select</span><span class="tok-o">((</span><span class="tok-n">pattern</span><span class="tok-k">:</span> <span class="tok-kt">Map</span><span class="tok-o">[</span><span class="tok-kt">String</span>, <span class="tok-kt">Iterable</span><span class="tok-o">[</span><span class="tok-kt">LoginEvent</span><span class="tok-o">]])</span> <span class="tok-k">=&gt;</span> <span class="tok-o">{</span>
    <span class="tok-k">val</span> <span class="tok-n">first</span> <span class="tok-k">=</span> <span class="tok-n">pattern</span><span class="tok-o">.</span><span class="tok-n">getOrElse</span><span class="tok-o">(</span><span class="tok-s">&quot;begin&quot;</span><span class="tok-o">,</span> <span class="tok-kc">null</span><span class="tok-o">).</span><span class="tok-n">iterator</span><span class="tok-o">.</span><span class="tok-n">next</span><span class="tok-o">()</span>
    <span class="tok-k">val</span> <span class="tok-n">second</span> <span class="tok-k">=</span> <span class="tok-n">pattern</span><span class="tok-o">.</span><span class="tok-n">getOrElse</span><span class="tok-o">(</span><span class="tok-s">&quot;next&quot;</span><span class="tok-o">,</span> <span class="tok-kc">null</span><span class="tok-o">).</span><span class="tok-n">iterator</span><span class="tok-o">.</span><span class="tok-n">next</span><span class="tok-o">()</span>

    <span class="tok-o">(</span><span class="tok-n">second</span><span class="tok-o">.</span><span class="tok-n">userId</span><span class="tok-o">,</span> <span class="tok-n">second</span><span class="tok-o">.</span><span class="tok-n">ip</span><span class="tok-o">,</span> <span class="tok-n">second</span><span class="tok-o">.</span><span class="tok-n">eventType</span><span class="tok-o">)</span>
  <span class="tok-o">})</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>其返回值仅为1条记录。</p>
</div>
<div class="paragraph">
<p><strong>flatSelect</strong></p>
</div>
<div class="paragraph">
<p>通过实现PatternFlatSelectFunction，实现与select相似的功能。唯一的区别就是flatSelect方法可以返回多条记录。</p>
</div>
<div class="paragraph">
<p><strong>超时事件的处理</strong></p>
</div>
<div class="paragraph">
<p>通过within方法，我们的parttern规则限定在一定的窗口范围内。当有超过窗口时间后还到达的event，我们可以通过在select或flatSelect中，实现PatternTimeoutFunction/PatternFlatTimeoutFunction来处理这种情况。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">val</span> <span class="tok-n">complexResult</span> <span class="tok-k">=</span> <span class="tok-n">patternStream</span><span class="tok-o">.</span><span class="tok-n">select</span><span class="tok-o">(</span><span class="tok-n">orderTimeoutOutput</span><span class="tok-o">)</span> <span class="tok-o">{</span>
  <span class="tok-o">(</span><span class="tok-n">pattern</span><span class="tok-k">:</span> <span class="tok-kt">Map</span><span class="tok-o">[</span><span class="tok-kt">String</span>, <span class="tok-kt">Iterable</span><span class="tok-o">[</span><span class="tok-kt">OrderEvent</span><span class="tok-o">]],</span> <span class="tok-n">timestamp</span><span class="tok-k">:</span> <span class="tok-kt">Long</span><span class="tok-o">)</span> <span class="tok-k">=&gt;</span> <span class="tok-o">{</span>
    <span class="tok-k">val</span> <span class="tok-n">createOrder</span> <span class="tok-k">=</span> <span class="tok-n">pattern</span><span class="tok-o">.</span><span class="tok-n">get</span><span class="tok-o">(</span><span class="tok-s">&quot;begin&quot;</span><span class="tok-o">)</span>
    <span class="tok-nc">OrderTimeoutEvent</span><span class="tok-o">(</span><span class="tok-n">createOrder</span><span class="tok-o">.</span><span class="tok-n">get</span><span class="tok-o">.</span><span class="tok-n">iterator</span><span class="tok-o">.</span><span class="tok-n">next</span><span class="tok-o">().</span><span class="tok-n">orderId</span><span class="tok-o">,</span> <span class="tok-s">&quot;timeout&quot;</span><span class="tok-o">)</span>
  <span class="tok-o">}</span>
<span class="tok-o">}</span> <span class="tok-o">{</span>
  <span class="tok-n">pattern</span><span class="tok-k">:</span> <span class="tok-kt">Map</span><span class="tok-o">[</span><span class="tok-kt">String</span>, <span class="tok-kt">Iterable</span><span class="tok-o">[</span><span class="tok-kt">OrderEvent</span><span class="tok-o">]]</span> <span class="tok-k">=&gt;</span> <span class="tok-o">{</span>
    <span class="tok-k">val</span> <span class="tok-n">payOrder</span> <span class="tok-k">=</span> <span class="tok-n">pattern</span><span class="tok-o">.</span><span class="tok-n">get</span><span class="tok-o">(</span><span class="tok-s">&quot;next&quot;</span><span class="tok-o">)</span>
    <span class="tok-nc">OrderTimeoutEvent</span><span class="tok-o">(</span><span class="tok-n">payOrder</span><span class="tok-o">.</span><span class="tok-n">get</span><span class="tok-o">.</span><span class="tok-n">iterator</span><span class="tok-o">.</span><span class="tok-n">next</span><span class="tok-o">().</span><span class="tok-n">orderId</span><span class="tok-o">,</span> <span class="tok-s">&quot;success&quot;</span><span class="tok-o">)</span>
  <span class="tok-o">}</span>
<span class="tok-o">}</span>

<span class="tok-k">val</span> <span class="tok-n">timeoutResult</span> <span class="tok-k">=</span> <span class="tok-n">complexResult</span><span class="tok-o">.</span><span class="tok-n">getSideOutput</span><span class="tok-o">(</span><span class="tok-n">orderTimeoutOutput</span><span class="tok-o">)</span>

<span class="tok-n">complexResult</span><span class="tok-o">.</span><span class="tok-n">print</span><span class="tok-o">()</span>
<span class="tok-n">timeoutResult</span><span class="tok-o">.</span><span class="tok-n">print</span><span class="tok-o">()</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>完整例子:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">import</span> <span class="tok-nn">org.apache.flink.cep.scala.CEP</span>
<span class="tok-k">import</span> <span class="tok-nn">org.apache.flink.cep.scala.pattern.Pattern</span>
<span class="tok-k">import</span> <span class="tok-nn">org.apache.flink.streaming.api.TimeCharacteristic</span>
<span class="tok-k">import</span> <span class="tok-nn">org.apache.flink.streaming.api.scala._</span>
<span class="tok-k">import</span> <span class="tok-nn">org.apache.flink.streaming.api.windowing.time.Time</span>

<span class="tok-k">import</span> <span class="tok-nn">scala.collection.Map</span>

<span class="tok-k">object</span> <span class="tok-nc">ScalaFlinkLoginFail</span> <span class="tok-o">{</span>

  <span class="tok-k">def</span> <span class="tok-n">main</span><span class="tok-o">(</span><span class="tok-n">args</span><span class="tok-k">:</span> <span class="tok-kt">Array</span><span class="tok-o">[</span><span class="tok-kt">String</span><span class="tok-o">])</span><span class="tok-k">:</span> <span class="tok-kt">Unit</span> <span class="tok-o">=</span> <span class="tok-o">{</span>

    <span class="tok-k">val</span> <span class="tok-n">env</span> <span class="tok-k">=</span> <span class="tok-nc">StreamExecutionEnvironment</span><span class="tok-o">.</span><span class="tok-n">getExecutionEnvironment</span>
    <span class="tok-n">env</span><span class="tok-o">.</span><span class="tok-n">setStreamTimeCharacteristic</span><span class="tok-o">(</span><span class="tok-nc">TimeCharacteristic</span><span class="tok-o">.</span><span class="tok-nc">EventTime</span><span class="tok-o">)</span>
    <span class="tok-n">env</span><span class="tok-o">.</span><span class="tok-n">setParallelism</span><span class="tok-o">(</span><span class="tok-mi">1</span><span class="tok-o">)</span>

    <span class="tok-k">val</span> <span class="tok-n">loginEventStream</span> <span class="tok-k">=</span> <span class="tok-n">env</span><span class="tok-o">.</span><span class="tok-n">fromCollection</span><span class="tok-o">(</span><span class="tok-nc">List</span><span class="tok-o">(</span>
      <span class="tok-nc">LoginEvent</span><span class="tok-o">(</span><span class="tok-s">&quot;1&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;192.168.0.1&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;fail&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;1558430842&quot;</span><span class="tok-o">),</span>
      <span class="tok-nc">LoginEvent</span><span class="tok-o">(</span><span class="tok-s">&quot;1&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;192.168.0.2&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;fail&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;1558430843&quot;</span><span class="tok-o">),</span>
      <span class="tok-nc">LoginEvent</span><span class="tok-o">(</span><span class="tok-s">&quot;1&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;192.168.0.3&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;fail&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;1558430844&quot;</span><span class="tok-o">),</span>
      <span class="tok-nc">LoginEvent</span><span class="tok-o">(</span><span class="tok-s">&quot;2&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;192.168.10.10&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;success&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;1558430845&quot;</span><span class="tok-o">)</span>
    <span class="tok-o">)).</span><span class="tok-n">assignAscendingTimestamps</span><span class="tok-o">(</span><span class="tok-k">_</span><span class="tok-o">.</span><span class="tok-n">eventTime</span><span class="tok-o">.</span><span class="tok-n">toLong</span><span class="tok-o">)</span>

    <span class="tok-k">val</span> <span class="tok-n">loginFailPattern</span> <span class="tok-k">=</span> <span class="tok-nc">Pattern</span><span class="tok-o">.</span><span class="tok-n">begin</span><span class="tok-o">[</span><span class="tok-kt">LoginEvent</span><span class="tok-o">](</span><span class="tok-s">&quot;begin&quot;</span><span class="tok-o">)</span>
      <span class="tok-o">.</span><span class="tok-n">where</span><span class="tok-o">(</span><span class="tok-k">_</span><span class="tok-o">.</span><span class="tok-n">eventType</span><span class="tok-o">.</span><span class="tok-n">equals</span><span class="tok-o">(</span><span class="tok-s">&quot;fail&quot;</span><span class="tok-o">))</span>
      <span class="tok-o">.</span><span class="tok-n">next</span><span class="tok-o">(</span><span class="tok-s">&quot;next&quot;</span><span class="tok-o">)</span>
      <span class="tok-o">.</span><span class="tok-n">where</span><span class="tok-o">(</span><span class="tok-k">_</span><span class="tok-o">.</span><span class="tok-n">eventType</span><span class="tok-o">.</span><span class="tok-n">equals</span><span class="tok-o">(</span><span class="tok-s">&quot;fail&quot;</span><span class="tok-o">))</span>
      <span class="tok-o">.</span><span class="tok-n">within</span><span class="tok-o">(</span><span class="tok-nc">Time</span><span class="tok-o">.</span><span class="tok-n">seconds</span><span class="tok-o">(</span><span class="tok-mi">10</span><span class="tok-o">))</span>

    <span class="tok-k">val</span> <span class="tok-n">patternStream</span> <span class="tok-k">=</span> <span class="tok-nc">CEP</span><span class="tok-o">.</span><span class="tok-n">pattern</span><span class="tok-o">(</span><span class="tok-n">loginEventStream</span><span class="tok-o">.</span><span class="tok-n">keyBy</span><span class="tok-o">(</span><span class="tok-k">_</span><span class="tok-o">.</span><span class="tok-n">userId</span><span class="tok-o">),</span> <span class="tok-n">loginFailPattern</span><span class="tok-o">)</span>

    <span class="tok-k">val</span> <span class="tok-n">loginFailDataStream</span> <span class="tok-k">=</span> <span class="tok-n">patternStream</span>
      <span class="tok-o">.</span><span class="tok-n">select</span><span class="tok-o">((</span><span class="tok-n">pattern</span><span class="tok-k">:</span> <span class="tok-kt">Map</span><span class="tok-o">[</span><span class="tok-kt">String</span>, <span class="tok-kt">Iterable</span><span class="tok-o">[</span><span class="tok-kt">LoginEvent</span><span class="tok-o">]])</span> <span class="tok-k">=&gt;</span> <span class="tok-o">{</span>
        <span class="tok-k">val</span> <span class="tok-n">first</span> <span class="tok-k">=</span> <span class="tok-n">pattern</span><span class="tok-o">.</span><span class="tok-n">getOrElse</span><span class="tok-o">(</span><span class="tok-s">&quot;begin&quot;</span><span class="tok-o">,</span> <span class="tok-kc">null</span><span class="tok-o">).</span><span class="tok-n">iterator</span><span class="tok-o">.</span><span class="tok-n">next</span><span class="tok-o">()</span>
        <span class="tok-k">val</span> <span class="tok-n">second</span> <span class="tok-k">=</span> <span class="tok-n">pattern</span><span class="tok-o">.</span><span class="tok-n">getOrElse</span><span class="tok-o">(</span><span class="tok-s">&quot;next&quot;</span><span class="tok-o">,</span> <span class="tok-kc">null</span><span class="tok-o">).</span><span class="tok-n">iterator</span><span class="tok-o">.</span><span class="tok-n">next</span><span class="tok-o">()</span>

        <span class="tok-o">(</span><span class="tok-n">second</span><span class="tok-o">.</span><span class="tok-n">userId</span><span class="tok-o">,</span> <span class="tok-n">second</span><span class="tok-o">.</span><span class="tok-n">ip</span><span class="tok-o">,</span> <span class="tok-n">second</span><span class="tok-o">.</span><span class="tok-n">eventType</span><span class="tok-o">)</span>
      <span class="tok-o">})</span>

    <span class="tok-n">loginFailDataStream</span><span class="tok-o">.</span><span class="tok-n">print</span>

    <span class="tok-n">env</span><span class="tok-o">.</span><span class="tok-n">execute</span>
  <span class="tok-o">}</span>

<span class="tok-o">}</span>

<span class="tok-k">case</span> <span class="tok-k">class</span> <span class="tok-nc">LoginEvent</span><span class="tok-o">(</span><span class="tok-n">userId</span><span class="tok-k">:</span> <span class="tok-kt">String</span><span class="tok-o">,</span> <span class="tok-n">ip</span><span class="tok-k">:</span> <span class="tok-kt">String</span><span class="tok-o">,</span> <span class="tok-n">eventType</span><span class="tok-k">:</span> <span class="tok-kt">String</span><span class="tok-o">,</span> <span class="tok-n">eventTime</span><span class="tok-k">:</span> <span class="tok-kt">String</span><span class="tok-o">)</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_尚硅谷大数据技术之电商用户行为分析">12. 尚硅谷大数据技术之电商用户行为分析</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_项目整体介绍">12.1. 项目整体介绍</h3>
<div class="sect3">
<h4 id="_电商的用户行为">12.1.1. 电商的用户行为</h4>
<div class="paragraph">
<p>电商平台中的用户行为频繁且较复杂，系统上线运行一段时间后，可以收集到大量的用户行为数据，进而利用大数据技术进行深入挖掘和分析，得到感兴趣的商业指标并增强对风险的控制。</p>
</div>
<div class="paragraph">
<p>电商用户行为数据多样，整体可以分为用户行为习惯数据和业务行为数据两大类。用户的行为习惯数据包括了用户的登录方式、上线的时间点及时长、点击和浏览页面、页面停留时间以及页面跳转等等，我们可以从中进行流量统计和热门商品的统计，也可以深入挖掘用户的特征；这些数据往往可以从web服务器日志中直接读取到。而业务行为数据就是用户在电商平台中针对每个业务（通常是某个具体商品）所作的操作，我们一般会在业务系统中相应的位置埋点，然后收集日志进行分析。业务行为数据又可以简单分为两类：一类是能够明显地表现出用户兴趣的行为，比如对商品的收藏、喜欢、评分和评价，我们可以从中对数据进行深入分析，得到用户画像，进而对用户给出个性化的推荐商品列表，这个过程往往会用到机器学习相关的算法；另一类则是常规的业务操作，但需要着重关注一些异常状况以做好风控，比如登录和订单支付。</p>
</div>
</div>
<div class="sect3">
<h4 id="_项目主要模块">12.1.2. 项目主要模块</h4>
<div class="paragraph">
<p>基于对电商用户行为数据的基本分类，我们可以发现主要有以下三个分析方向：</p>
</div>
<div class="paragraph">
<p><strong>热门统计</strong></p>
</div>
<div class="paragraph">
<p>利用用户的点击浏览行为，进行流量统计、近期热门商品统计等。</p>
</div>
<div class="paragraph">
<p><strong>偏好统计</strong></p>
</div>
<div class="paragraph">
<p>利用用户的偏好行为，比如收藏、喜欢、评分等，进行用户画像分析，给出个性化的商品推荐列表。</p>
</div>
<div class="paragraph">
<p><strong>风险控制</strong></p>
</div>
<div class="paragraph">
<p>利用用户的常规业务行为，比如登录、下单、支付等，分析数据，对异常情况进行报警提示。</p>
</div>
<div class="paragraph">
<p>例如订单失效监控，恶意登录(短时间内频繁登录失败)监控。</p>
</div>
<div class="paragraph">
<p>本项目限于数据，我们只实现热门统计和风险控制中的部分内容，将包括以下四大模块：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>实时热门商品统计</p>
</li>
<li>
<p>实时流量统计</p>
</li>
<li>
<p>恶意登录监控</p>
</li>
<li>
<p>订单支付失效监控。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>由于对实时性要求较高，我们会用Flink作为数据处理的框架。在项目中，我们将综合运用flink的各种API，基于EventTime去处理基本的业务需求，并且灵活地使用底层的processFunction，基于状态编程和CEP去处理更加复杂的情形。</p>
</div>
</div>
<div class="sect3">
<h4 id="_数据源解析">12.1.3. 数据源解析</h4>
<div class="paragraph">
<p>我们准备了一份淘宝用户行为数据集，保存为csv文件。本数据集包含了淘宝上某一天随机一百万用户的所有行为（包括点击、购买、收藏、喜欢）。数据集的每一行表示一条用户行为，由用户ID、商品ID、商品类目ID、行为类型和时间戳组成，并以逗号分隔。关于数据集中每一列的详细描述如下：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">字段名</th>
<th class="tableblock halign-left valign-top">数据类型</th>
<th class="tableblock halign-left valign-top">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">userId</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Long</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">加密后的用户ID</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">itemId</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Long</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">加密后的商品ID</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">categoryId</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Int</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">加密后的商品所属类别ID</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">behavior</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">String</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用户行为类型，包括('pv', 'buy', 'cart', 'fav')</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">timestamp</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Long</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">行为发生的时间戳，单位秒</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>另外，我们还可以拿到web服务器的日志数据，这里以apache服务器的一份log为例，每一行日志记录了访问者的IP、userId、访问时间、访问方法以及访问的url，具体描述如下：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">字段名</th>
<th class="tableblock halign-left valign-top">数据类型</th>
<th class="tableblock halign-left valign-top">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ip</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">String</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">访问的IP</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">userId</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Long</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">访问的user ID</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">eventTime</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Long</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">访问时间</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">method</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">String</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">访问方法 GET/POST/PUT/DELETE</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">url</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">String</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">访问的url</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>由于行为数据有限，在实时热门商品统计模块中可以使用UserBehavior数据集，而对于恶意登录监控和订单支付失效监控，我们只以示例数据来做演示。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_实时热门商品统计">12.2. 实时热门商品统计</h3>
<div class="paragraph">
<p>首先要实现的是实时热门商品统计，我们将会基于UserBehavior数据集来进行分析。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>基本需求</p>
<div class="ulist">
<ul>
<li>
<p>统计近1小时内的热门商品，每5分钟更新一次</p>
</li>
<li>
<p>热门度用浏览次数("pv")来衡量</p>
</li>
</ul>
</div>
</li>
<li>
<p>解决思路</p>
<div class="ulist">
<ul>
<li>
<p>在所有用户行为数据中，过滤出浏览("pv")行为进行统计</p>
</li>
<li>
<p>构建滑动窗口，窗口长度为1小时，滑动距离为5分钟</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="images/电商用户行为数据分析1.png" alt="电商用户行为数据分析1">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="images/电商用户行为数据分析2.png" alt="电商用户行为数据分析2">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="images/电商用户行为数据分析3.png" alt="电商用户行为数据分析3">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="images/电商用户行为数据分析4.png" alt="电商用户行为数据分析4">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="images/电商用户行为数据分析5.png" alt="电商用户行为数据分析5">
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>窗口聚合策略——每出现一条记录就加一</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">class</span> <span class="tok-nc">CountAgg</span> <span class="tok-k">extends</span> <span class="tok-nc">AggregateFunction</span><span class="tok-o">[</span><span class="tok-kt">UserBehavior</span>, <span class="tok-kt">Long</span>, <span class="tok-kt">Long</span><span class="tok-o">]</span> <span class="tok-o">{</span>
  <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">createAccumulator</span><span class="tok-o">()</span><span class="tok-k">:</span> <span class="tok-kt">Long</span> <span class="tok-o">=</span> <span class="tok-mi">0L</span>
  <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">add</span><span class="tok-o">(</span><span class="tok-n">userBehavior</span><span class="tok-k">:</span> <span class="tok-kt">UserBehavior</span><span class="tok-o">,</span> <span class="tok-n">acc</span><span class="tok-k">:</span> <span class="tok-kt">Long</span><span class="tok-o">)</span><span class="tok-k">:</span> <span class="tok-kt">Long</span> <span class="tok-o">=</span> <span class="tok-n">acc</span> <span class="tok-o">+</span> <span class="tok-mi">1</span>
  <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">getResult</span><span class="tok-o">(</span><span class="tok-n">acc</span><span class="tok-k">:</span> <span class="tok-kt">Long</span><span class="tok-o">)</span><span class="tok-k">:</span> <span class="tok-kt">Long</span> <span class="tok-o">=</span> <span class="tok-n">acc</span>
  <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">merge</span><span class="tok-o">(</span><span class="tok-n">acc1</span><span class="tok-k">:</span> <span class="tok-kt">Long</span><span class="tok-o">,</span> <span class="tok-n">acc2</span><span class="tok-k">:</span> <span class="tok-kt">Long</span><span class="tok-o">)</span><span class="tok-k">:</span> <span class="tok-kt">Long</span> <span class="tok-o">=</span> <span class="tok-n">acc1</span> <span class="tok-o">+</span> <span class="tok-n">acc2</span>
<span class="tok-o">}</span></code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>累加规则——窗口内碰到一条数据就加一(add方法)</p>
</li>
<li>
<p>实现 AggregateFunction 接口</p>
<div class="ulist">
<ul>
<li>
<p><code>interface AggregateFunction&lt;IN, ACC, OUT&gt;</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>定义输出结构 —— ItemViewCount(itemId, windowEnd, count)</p>
</li>
<li>
<p>实现<code>WindowFunction</code>接口</p>
<div class="ulist">
<ul>
<li>
<p><code>trait WindowFunction[IN, OUT, KEY, W &lt;: Window]</code></p>
<div class="ulist">
<ul>
<li>
<p>IN: 输入为累加器的类型，Long</p>
</li>
<li>
<p>OUT: 窗口累加以后输出的类型为 ItemViewCount(itemId: Long, windowEnd: Long, count: Long), windowEnd为窗口的结束 时间，也是窗口的唯一标识</p>
</li>
<li>
<p>KEY: Tuple泛型，在这里是 itemId，窗口根据itemId聚合</p>
</li>
<li>
<p>W: 聚合的窗口，w.getEnd 就能拿到窗口的结束时间</p>
</li>
<li>
<p><code>override def apply</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">apply</span><span class="tok-o">(</span><span class="tok-n">key</span><span class="tok-k">:</span> <span class="tok-kt">Tuple</span><span class="tok-o">,</span> <span class="tok-n">window</span><span class="tok-k">:</span> <span class="tok-kt">TimeWindow</span><span class="tok-o">,</span> <span class="tok-n">aggregateResult</span><span class="tok-k">:</span> <span class="tok-kt">Iterable</span><span class="tok-o">[</span><span class="tok-kt">Long</span><span class="tok-o">],</span> <span class="tok-n">collector</span><span class="tok-k">:</span> <span class="tok-kt">Collector</span><span class="tok-o">[</span><span class="tok-kt">ItemViewCount</span><span class="tok-o">])</span> <span class="tok-k">:</span> <span class="tok-kt">Unit</span> <span class="tok-o">=</span> <span class="tok-o">{</span>
  <span class="tok-k">val</span> <span class="tok-n">itemId</span><span class="tok-k">:</span> <span class="tok-kt">Long</span> <span class="tok-o">=</span> <span class="tok-n">key</span><span class="tok-o">.</span><span class="tok-n">asInstanceOf</span><span class="tok-o">[</span><span class="tok-kt">Tuple1</span><span class="tok-o">[</span><span class="tok-kt">Long</span><span class="tok-o">]].</span><span class="tok-n">f0</span>
  <span class="tok-k">val</span> <span class="tok-n">count</span> <span class="tok-k">=</span> <span class="tok-n">aggregateResult</span><span class="tok-o">.</span><span class="tok-n">iterator</span><span class="tok-o">.</span><span class="tok-n">next</span>
  <span class="tok-n">collector</span><span class="tok-o">.</span><span class="tok-n">collect</span><span class="tok-o">(</span><span class="tok-nc">ItemViewCount</span><span class="tok-o">(</span><span class="tok-n">itemId</span><span class="tok-o">,</span> <span class="tok-n">window</span><span class="tok-o">.</span><span class="tok-n">getEnd</span><span class="tok-o">,</span> <span class="tok-n">count</span><span class="tok-o">))</span>
<span class="tok-o">}</span></code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="images/电商用户行为数据分析6.png" alt="电商用户行为数据分析6">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="images/电商用户行为数据分析7.png" alt="电商用户行为数据分析7">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="images/电商用户行为数据分析8.png" alt="电商用户行为数据分析8">
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>最终排序输出 —— keyedProcessFunction</p>
<div class="ulist">
<ul>
<li>
<p>针对有状态流的底层API</p>
</li>
<li>
<p>KeyedProcessFunction会对分流后的每一条流进行处理</p>
</li>
<li>
<p>以windowEnd作为 key，保证分流以后每一条流的数据都在一个时间窗口内</p>
</li>
<li>
<p>从 ListState 中读取当前流的状态，存储数据进行排序输出</p>
</li>
</ul>
</div>
</li>
<li>
<p>用ProcessFunction来定义KeyedStream的处理逻辑</p>
</li>
<li>
<p>分流之后，每个KeyedStream都有其自己的生命周期</p>
<div class="ulist">
<ul>
<li>
<p>open: 初始化，在这里可以获取当前流的状态</p>
</li>
<li>
<p>processElement: 处理流中每一个元素时调用</p>
</li>
<li>
<p>onTimer: 定时调用，注册定时器Timer并触发之后的回调操作</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="images/电商用户行为数据分析9.png" alt="电商用户行为数据分析9">
</div>
</div>
<div class="paragraph">
<p>项目主体用Scala编写，采用IDEA作为开发环境进行项目编写，采用maven作为项目构建和管理工具。首先我们需要搭建项目框架。</p>
</div>
<div class="sect3">
<h4 id="_创建maven项目">12.2.1. 创建Maven项目</h4>
<div class="sect4">
<h5 id="_项目框架搭建">项目框架搭建</h5>
<div class="paragraph">
<p>打开IDEA，创建一个maven项目，命名为UserBehaviorAnalysis。由于包含了多个模块，我们可以以UserBehaviorAnalysis作为父项目，并在其下建一个名为HotItemsAnalysis的子项目，用于实时统计热门top N商品。</p>
</div>
<div class="paragraph">
<p>在UserBehaviorAnalysis下新建一个maven module作为子项目，命名为HotItemsAnalysis。</p>
</div>
<div class="paragraph">
<p>父项目只是为了规范化项目结构，方便依赖管理，本身是不需要代码实现的，所以UserBehaviorAnalysis下的src文件夹可以删掉。</p>
</div>
</div>
<div class="sect4">
<h5 id="_声明项目中工具的版本信息">声明项目中工具的版本信息</h5>
<div class="paragraph">
<p>我们整个项目需要的工具的不同版本可能会对程序运行造成影响，所以应该在最外层的UserBehaviorAnalysis中声明所有子模块共用的版本信息。</p>
</div>
<div class="paragraph">
<p>在pom.xml中加入以下配置：</p>
</div>
<div class="listingblock">
<div class="title">UserBehaviorAnalysis/pom.xml</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="xml"><span></span><span class="tok-nt">&lt;properties&gt;</span>
    <span class="tok-nt">&lt;flink.version&gt;</span>1.7.2<span class="tok-nt">&lt;/flink.version&gt;</span>
    <span class="tok-nt">&lt;scala.binary.version&gt;</span>2.11<span class="tok-nt">&lt;/scala.binary.version&gt;</span>
    <span class="tok-nt">&lt;kafka.version&gt;</span>2.2.0<span class="tok-nt">&lt;/kafka.version&gt;</span>
<span class="tok-nt">&lt;/properties&gt;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_添加项目依赖">添加项目依赖</h5>
<div class="paragraph">
<p>对于整个项目而言，所有模块都会用到flink相关的组件，所以我们在UserBehaviorAnalysis中引入公有依赖：</p>
</div>
<div class="listingblock">
<div class="title">UserBehaviorAnalysis/pom.xml</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="xml"><span></span><span class="tok-nt">&lt;dependencies&gt;</span>
    <span class="tok-nt">&lt;dependency&gt;</span>
        <span class="tok-nt">&lt;groupId&gt;</span>org.apache.flink<span class="tok-nt">&lt;/groupId&gt;</span>
        <span class="tok-nt">&lt;artifactId&gt;</span>flink-scala_${scala.binary.version}<span class="tok-nt">&lt;/artifactId&gt;</span>
        <span class="tok-nt">&lt;version&gt;</span>${flink.version}<span class="tok-nt">&lt;/version&gt;</span>
    <span class="tok-nt">&lt;/dependency&gt;</span>
    <span class="tok-nt">&lt;dependency&gt;</span>
        <span class="tok-nt">&lt;groupId&gt;</span>org.apache.flink<span class="tok-nt">&lt;/groupId&gt;</span>
        <span class="tok-nt">&lt;artifactId&gt;</span>flink-streaming-scala_${scala.binary.version}<span class="tok-nt">&lt;/artifactId&gt;</span>
        <span class="tok-nt">&lt;version&gt;</span>${flink.version}<span class="tok-nt">&lt;/version&gt;</span>
    <span class="tok-nt">&lt;/dependency&gt;</span>
    <span class="tok-nt">&lt;dependency&gt;</span>
        <span class="tok-nt">&lt;groupId&gt;</span>org.apache.kafka<span class="tok-nt">&lt;/groupId&gt;</span>
        <span class="tok-nt">&lt;artifactId&gt;</span>kafka_${scala.binary.version}<span class="tok-nt">&lt;/artifactId&gt;</span>
        <span class="tok-nt">&lt;version&gt;</span>${kafka.version}<span class="tok-nt">&lt;/version&gt;</span>
    <span class="tok-nt">&lt;/dependency&gt;</span>
    <span class="tok-nt">&lt;dependency&gt;</span>
        <span class="tok-nt">&lt;groupId&gt;</span>org.apache.flink<span class="tok-nt">&lt;/groupId&gt;</span>
        <span class="tok-nt">&lt;artifactId&gt;</span>flink-connector-kafka_${scala.binary.version}<span class="tok-nt">&lt;/artifactId&gt;</span>
        <span class="tok-nt">&lt;version&gt;</span>${flink.version}<span class="tok-nt">&lt;/version&gt;</span>
    <span class="tok-nt">&lt;/dependency&gt;</span>
<span class="tok-nt">&lt;/dependencies&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>同样，对于maven项目的构建，可以引入公有的插件：</p>
</div>
<div class="listingblock">
<div class="title">UserBehaviorAnalysis/pom.xml</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="xml"><span></span><span class="tok-nt">&lt;build&gt;</span>
    <span class="tok-nt">&lt;plugins&gt;</span>
        <span class="tok-c">&lt;!-- 该插件用于将Scala代码编译成class文件 --&gt;</span>
        <span class="tok-nt">&lt;plugin&gt;</span>
            <span class="tok-nt">&lt;groupId&gt;</span>net.alchim31.maven<span class="tok-nt">&lt;/groupId&gt;</span>
            <span class="tok-nt">&lt;artifactId&gt;</span>scala-maven-plugin<span class="tok-nt">&lt;/artifactId&gt;</span>
            <span class="tok-nt">&lt;version&gt;</span>3.4.6<span class="tok-nt">&lt;/version&gt;</span>
            <span class="tok-nt">&lt;executions&gt;</span>
                <span class="tok-nt">&lt;execution&gt;</span>
                    <span class="tok-c">&lt;!-- 声明绑定到maven的compile阶段 --&gt;</span>
                    <span class="tok-nt">&lt;goals&gt;</span>
                        <span class="tok-nt">&lt;goal&gt;</span>testCompile<span class="tok-nt">&lt;/goal&gt;</span>
                    <span class="tok-nt">&lt;/goals&gt;</span>
                <span class="tok-nt">&lt;/execution&gt;</span>
            <span class="tok-nt">&lt;/executions&gt;</span>
        <span class="tok-nt">&lt;/plugin&gt;</span>

        <span class="tok-nt">&lt;plugin&gt;</span>
            <span class="tok-nt">&lt;groupId&gt;</span>org.apache.maven.plugins<span class="tok-nt">&lt;/groupId&gt;</span>
            <span class="tok-nt">&lt;artifactId&gt;</span>maven-assembly-plugin<span class="tok-nt">&lt;/artifactId&gt;</span>
            <span class="tok-nt">&lt;version&gt;</span>3.0.0<span class="tok-nt">&lt;/version&gt;</span>
            <span class="tok-nt">&lt;configuration&gt;</span>
                <span class="tok-nt">&lt;descriptorRefs&gt;</span>
                    <span class="tok-nt">&lt;descriptorRef&gt;</span>
                        jar-with-dependencies
                    <span class="tok-nt">&lt;/descriptorRef&gt;</span>
                <span class="tok-nt">&lt;/descriptorRefs&gt;</span>
            <span class="tok-nt">&lt;/configuration&gt;</span>
            <span class="tok-nt">&lt;executions&gt;</span>
                <span class="tok-nt">&lt;execution&gt;</span>
                    <span class="tok-nt">&lt;id&gt;</span>make-assembly<span class="tok-nt">&lt;/id&gt;</span>
                    <span class="tok-nt">&lt;phase&gt;</span>package<span class="tok-nt">&lt;/phase&gt;</span>
                    <span class="tok-nt">&lt;goals&gt;</span>
                        <span class="tok-nt">&lt;goal&gt;</span>single<span class="tok-nt">&lt;/goal&gt;</span>
                    <span class="tok-nt">&lt;/goals&gt;</span>
                <span class="tok-nt">&lt;/execution&gt;</span>
            <span class="tok-nt">&lt;/executions&gt;</span>
        <span class="tok-nt">&lt;/plugin&gt;</span>
    <span class="tok-nt">&lt;/plugins&gt;</span>
<span class="tok-nt">&lt;/build&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在HotItemsAnalysis子模块中，我们并没有引入更多的依赖，所以不需要改动pom文件。</p>
</div>
</div>
<div class="sect4">
<h5 id="_数据准备">数据准备</h5>
<div class="paragraph">
<p>在src/main/目录下，可以看到已有的默认源文件目录是java，我们可以将其改名为scala。将数据文件UserBehavior.csv复制到资源文件目录src/main/resources下，我们将从这里读取数据。
至此，我们的准备工作都已完成，接下来可以写代码了。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_模块代码实现">12.2.2. 模块代码实现</h4>
<div class="paragraph">
<p>我们将实现一个“实时热门商品”的需求，可以将“实时热门商品”翻译成程序员更好理解的需求：每隔5分钟输出最近一小时内点击量最多的前N个商品。将这个需求进行分解我们大概要做这么几件事情：
抽取出业务时间戳，告诉Flink框架基于业务时间做窗口
过滤出点击行为数据
按一小时的窗口大小，每5分钟统计一次，做滑动窗口聚合（Sliding Window）
按每个窗口聚合，输出每个窗口中点击量前N名的商品</p>
</div>
</div>
<div class="sect3">
<h4 id="_程序主体">12.2.3. 程序主体</h4>
<div class="paragraph">
<p>在src/main/scala下创建HotItems.scala文件，新建一个单例对象。定义样例类UserBehavior和ItemViewCount，在main函数中创建StreamExecutionEnvironment 并做配置，然后从UserBehavior.csv文件中读取数据，并包装成UserBehavior类型。代码如下：</p>
</div>
<div class="listingblock">
<div class="title">HotItemsAnalysis/src/main/scala/HotItems.scala</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">case</span> <span class="tok-k">class</span> <span class="tok-nc">UserBehavior</span><span class="tok-o">(</span><span class="tok-n">userId</span><span class="tok-k">:</span> <span class="tok-kt">Long</span><span class="tok-o">,</span> <span class="tok-n">itemId</span><span class="tok-k">:</span> <span class="tok-kt">Long</span><span class="tok-o">,</span> <span class="tok-n">categoryId</span><span class="tok-k">:</span> <span class="tok-kt">Int</span><span class="tok-o">,</span> <span class="tok-n">behavior</span><span class="tok-k">:</span> <span class="tok-kt">String</span><span class="tok-o">,</span> <span class="tok-n">timestamp</span><span class="tok-k">:</span> <span class="tok-kt">Long</span><span class="tok-o">)</span>

<span class="tok-k">case</span> <span class="tok-k">class</span> <span class="tok-nc">ItemViewCount</span><span class="tok-o">(</span><span class="tok-n">itemId</span><span class="tok-k">:</span> <span class="tok-kt">Long</span><span class="tok-o">,</span> <span class="tok-n">windowEnd</span><span class="tok-k">:</span> <span class="tok-kt">Long</span><span class="tok-o">,</span> <span class="tok-n">count</span><span class="tok-k">:</span> <span class="tok-kt">Long</span><span class="tok-o">)</span>

<span class="tok-k">object</span> <span class="tok-nc">HotItems</span> <span class="tok-o">{</span>
  <span class="tok-k">def</span> <span class="tok-n">main</span><span class="tok-o">(</span><span class="tok-n">args</span><span class="tok-k">:</span> <span class="tok-kt">Array</span><span class="tok-o">[</span><span class="tok-kt">String</span><span class="tok-o">])</span><span class="tok-k">:</span> <span class="tok-kt">Unit</span> <span class="tok-o">=</span> <span class="tok-o">{</span>
    <span class="tok-c1">// 创建一个 StreamExecutionEnvironment</span>
    <span class="tok-k">val</span> <span class="tok-n">env</span> <span class="tok-k">=</span> <span class="tok-nc">StreamExecutionEnvironment</span><span class="tok-o">.</span><span class="tok-n">getExecutionEnvironment</span>
    <span class="tok-c1">// 设定Time类型为EventTime</span>
    <span class="tok-n">env</span><span class="tok-o">.</span><span class="tok-n">setStreamTimeCharacteristic</span><span class="tok-o">(</span><span class="tok-nc">TimeCharacteristic</span><span class="tok-o">.</span><span class="tok-nc">EventTime</span><span class="tok-o">)</span>
    <span class="tok-c1">// 为了打印到控制台的结果不乱序，我们配置全局的并发为1，这里改变并发对结果正确性没有影响</span>
    <span class="tok-n">env</span><span class="tok-o">.</span><span class="tok-n">setParallelism</span><span class="tok-o">(</span><span class="tok-mi">1</span><span class="tok-o">)</span>
    <span class="tok-k">val</span> <span class="tok-n">stream</span> <span class="tok-k">=</span> <span class="tok-n">env</span>
      <span class="tok-c1">// 以window下为例，需替换成自己的路径</span>
      <span class="tok-o">.</span><span class="tok-n">readTextFile</span><span class="tok-o">(</span><span class="tok-s">&quot;YOUR_PATH\\resources\\UserBehavior.csv&quot;</span><span class="tok-o">)</span>
      <span class="tok-o">.</span><span class="tok-n">map</span><span class="tok-o">(</span><span class="tok-n">line</span> <span class="tok-k">=&gt;</span> <span class="tok-o">{</span>
        <span class="tok-k">val</span> <span class="tok-n">linearray</span> <span class="tok-k">=</span> <span class="tok-n">line</span><span class="tok-o">.</span><span class="tok-n">split</span><span class="tok-o">(</span><span class="tok-s">&quot;,&quot;</span><span class="tok-o">)</span>
        <span class="tok-nc">UserBehavior</span><span class="tok-o">(</span><span class="tok-n">linearray</span><span class="tok-o">(</span><span class="tok-mi">0</span><span class="tok-o">).</span><span class="tok-n">toLong</span><span class="tok-o">,</span> <span class="tok-n">linearray</span><span class="tok-o">(</span><span class="tok-mi">1</span><span class="tok-o">).</span><span class="tok-n">toLong</span><span class="tok-o">,</span> <span class="tok-n">linearray</span><span class="tok-o">(</span><span class="tok-mi">2</span><span class="tok-o">).</span><span class="tok-n">toInt</span><span class="tok-o">,</span> <span class="tok-n">linearray</span><span class="tok-o">(</span><span class="tok-mi">3</span><span class="tok-o">),</span> <span class="tok-n">linearray</span><span class="tok-o">(</span><span class="tok-mi">4</span><span class="tok-o">).</span><span class="tok-n">toLong</span><span class="tok-o">)</span>
      <span class="tok-o">})</span>
      <span class="tok-c1">// 指定时间戳和watermark</span>
      <span class="tok-o">.</span><span class="tok-n">assignAscendingTimestamps</span><span class="tok-o">(</span><span class="tok-k">_</span><span class="tok-o">.</span><span class="tok-n">timestamp</span> <span class="tok-o">*</span> <span class="tok-mi">1000</span><span class="tok-o">)</span>

    <span class="tok-n">env</span><span class="tok-o">.</span><span class="tok-n">execute</span><span class="tok-o">(</span><span class="tok-s">&quot;Hot Items Job&quot;</span><span class="tok-o">)</span>
  <span class="tok-o">}</span>
<span class="tok-o">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这里注意，我们需要统计业务时间上的每小时的点击量，所以要基于EventTime来处理。那么如果让Flink按照我们想要的业务时间来处理呢？这里主要有两件事情要做。</p>
</div>
<div class="paragraph">
<p>第一件是告诉Flink我们现在按照EventTime模式进行处理，Flink默认使用ProcessingTime处理，所以我们要显式设置如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-n">env</span><span class="tok-o">.</span><span class="tok-n">setStreamTimeCharacteristic</span><span class="tok-o">(</span><span class="tok-nc">TimeCharacteristic</span><span class="tok-o">.</span><span class="tok-nc">EventTime</span><span class="tok-o">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>第二件事情是指定如何获得业务时间，以及生成Watermark。Watermark是用来追踪业务事件的概念，可以理解成EventTime世界中的时钟，用来指示当前处理到什么时刻的数据了。由于我们的数据源的数据已经经过整理，没有乱序，即事件的时间戳是单调递增的，所以可以将每条数据的业务时间就当做Watermark。这里我们用assignAscendingTimestamps来实现时间戳的抽取和Watermark的生成。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
真实业务场景一般都是乱序的，所以一般不用<code>assignAscendingTimestamps</code>，而是使用<code>BoundedOutOfOrdernessTimestampExtractor</code>。
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-o">.</span><span class="tok-n">assignAscendingTimestamps</span><span class="tok-o">(</span><span class="tok-k">_</span><span class="tok-o">.</span><span class="tok-n">timestamp</span> <span class="tok-o">*</span> <span class="tok-mi">1000</span><span class="tok-o">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这样我们就得到了一个带有时间标记的数据流了，后面就能做一些窗口的操作。</p>
</div>
</div>
<div class="sect3">
<h4 id="_过滤出点击事件">12.2.4. 过滤出点击事件</h4>
<div class="paragraph">
<p>在开始窗口操作之前，先回顾下需求"每隔5分钟输出过去一小时内点击量最多的前N个商品"。由于原始数据中存在点击、购买、收藏、喜欢各种行为的数据，但是我们只需要统计点击量，所以先使用filter将点击行为数据过滤出来。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-o">.</span><span class="tok-n">filter</span><span class="tok-o">(</span><span class="tok-k">_</span><span class="tok-o">.</span><span class="tok-n">behavior</span> <span class="tok-o">==</span> <span class="tok-s">&quot;pv&quot;</span><span class="tok-o">)</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_设置滑动窗口统计点击量">12.2.5. 设置滑动窗口，统计点击量</h4>
<div class="paragraph">
<p>由于要每隔5分钟统计一次最近一小时每个商品的点击量，所以窗口大小是一小时，每隔5分钟滑动一次。即分别要统计[09:00, 10:00), [09:05, 10:05), [09:10, 10:10)…等窗口的商品点击量。是一个常见的滑动窗口需求（Sliding Window）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-o">.</span><span class="tok-n">keyBy</span><span class="tok-o">(</span><span class="tok-s">&quot;itemId&quot;</span><span class="tok-o">)</span>
<span class="tok-o">.</span><span class="tok-n">timeWindow</span><span class="tok-o">(</span><span class="tok-nc">Time</span><span class="tok-o">.</span><span class="tok-n">minutes</span><span class="tok-o">(</span><span class="tok-mi">60</span><span class="tok-o">),</span> <span class="tok-nc">Time</span><span class="tok-o">.</span><span class="tok-n">minutes</span><span class="tok-o">(</span><span class="tok-mi">5</span><span class="tok-o">))</span>
<span class="tok-o">.</span><span class="tok-n">aggregate</span><span class="tok-o">(</span><span class="tok-k">new</span> <span class="tok-nc">CountAgg</span><span class="tok-o">(),</span> <span class="tok-k">new</span> <span class="tok-nc">WindowResultFunction</span><span class="tok-o">());</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>我们使用<code>.keyBy("itemId")</code>对商品进行分组，使用<code>.timeWindow(Time size, Time slide)</code>对每个商品做滑动窗口（1小时窗口，5分钟滑动一次）。然后我们使用<code>.aggregate(AggregateFunction af, WindowFunction wf)</code>做增量的聚合操作，它能使用<code>AggregateFunction</code>提前聚合掉数据，减少<code>state</code>的存储压力。较之<code>.apply(WindowFunction wf)</code>会将窗口中的数据都存储下来，最后一起计算要高效地多。这里的<code>CountAgg</code>实现了<code>AggregateFunction</code>接口，功能是统计窗口中的条数，即遇到一条数据就加一。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-c1">// COUNT统计的聚合函数实现，每出现一条记录就加一</span>
<span class="tok-k">class</span> <span class="tok-nc">CountAgg</span> <span class="tok-k">extends</span> <span class="tok-nc">AggregateFunction</span><span class="tok-o">[</span><span class="tok-kt">UserBehavior</span>, <span class="tok-kt">Long</span>, <span class="tok-kt">Long</span><span class="tok-o">]</span> <span class="tok-o">{</span>
  <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">createAccumulator</span><span class="tok-o">()</span><span class="tok-k">:</span> <span class="tok-kt">Long</span> <span class="tok-o">=</span> <span class="tok-mi">0L</span>
  <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">add</span><span class="tok-o">(</span><span class="tok-n">userBehavior</span><span class="tok-k">:</span> <span class="tok-kt">UserBehavior</span><span class="tok-o">,</span> <span class="tok-n">acc</span><span class="tok-k">:</span> <span class="tok-kt">Long</span><span class="tok-o">)</span><span class="tok-k">:</span> <span class="tok-kt">Long</span> <span class="tok-o">=</span> <span class="tok-n">acc</span> <span class="tok-o">+</span> <span class="tok-mi">1</span>
  <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">getResult</span><span class="tok-o">(</span><span class="tok-n">acc</span><span class="tok-k">:</span> <span class="tok-kt">Long</span><span class="tok-o">)</span><span class="tok-k">:</span> <span class="tok-kt">Long</span> <span class="tok-o">=</span> <span class="tok-n">acc</span>
  <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">merge</span><span class="tok-o">(</span><span class="tok-n">acc1</span><span class="tok-k">:</span> <span class="tok-kt">Long</span><span class="tok-o">,</span> <span class="tok-n">acc2</span><span class="tok-k">:</span> <span class="tok-kt">Long</span><span class="tok-o">)</span><span class="tok-k">:</span> <span class="tok-kt">Long</span> <span class="tok-o">=</span> <span class="tok-n">acc1</span> <span class="tok-o">+</span> <span class="tok-n">acc2</span>
<span class="tok-o">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>聚合操作<code>.aggregate(AggregateFunction af, WindowFunction wf)</code>的第二个参数<code>WindowFunction</code>将每个<code>key</code>每个窗口聚合后的结果带上其他信息进行输出。我们这里实现的<code>WindowResultFunction</code>将&lt;主键商品ID，窗口，点击量&gt;封装成了<code>ItemViewCount</code>进行输出。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-c1">// 商品点击量(窗口操作的输出类型)</span>
<span class="tok-k">case</span> <span class="tok-k">class</span> <span class="tok-nc">ItemViewCount</span><span class="tok-o">(</span><span class="tok-n">itemId</span><span class="tok-k">:</span> <span class="tok-kt">Long</span><span class="tok-o">,</span> <span class="tok-n">windowEnd</span><span class="tok-k">:</span> <span class="tok-kt">Long</span><span class="tok-o">,</span> <span class="tok-n">count</span><span class="tok-k">:</span> <span class="tok-kt">Long</span><span class="tok-o">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>代码如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-c1">// 用于输出窗口的结果</span>
<span class="tok-k">class</span> <span class="tok-nc">WindowResultFunction</span> <span class="tok-k">extends</span> <span class="tok-nc">WindowFunction</span><span class="tok-o">[</span><span class="tok-kt">Long</span>, <span class="tok-kt">ItemViewCount</span>, <span class="tok-kt">Tuple</span>, <span class="tok-kt">TimeWindow</span><span class="tok-o">]</span> <span class="tok-o">{</span>
  <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">apply</span><span class="tok-o">(</span><span class="tok-n">key</span><span class="tok-k">:</span> <span class="tok-kt">Tuple</span><span class="tok-o">,</span> <span class="tok-n">window</span><span class="tok-k">:</span> <span class="tok-kt">TimeWindow</span><span class="tok-o">,</span> <span class="tok-n">aggregateResult</span><span class="tok-k">:</span> <span class="tok-kt">Iterable</span><span class="tok-o">[</span><span class="tok-kt">Long</span><span class="tok-o">],</span> <span class="tok-n">collector</span><span class="tok-k">:</span> <span class="tok-kt">Collector</span><span class="tok-o">[</span><span class="tok-kt">ItemViewCount</span><span class="tok-o">])</span> <span class="tok-k">:</span> <span class="tok-kt">Unit</span> <span class="tok-o">=</span> <span class="tok-o">{</span>
    <span class="tok-k">val</span> <span class="tok-n">itemId</span><span class="tok-k">:</span> <span class="tok-kt">Long</span> <span class="tok-o">=</span> <span class="tok-n">key</span><span class="tok-o">.</span><span class="tok-n">asInstanceOf</span><span class="tok-o">[</span><span class="tok-kt">Tuple1</span><span class="tok-o">[</span><span class="tok-kt">Long</span><span class="tok-o">]].</span><span class="tok-n">f0</span>
    <span class="tok-k">val</span> <span class="tok-n">count</span> <span class="tok-k">=</span> <span class="tok-n">aggregateResult</span><span class="tok-o">.</span><span class="tok-n">iterator</span><span class="tok-o">.</span><span class="tok-n">next</span>
    <span class="tok-n">collector</span><span class="tok-o">.</span><span class="tok-n">collect</span><span class="tok-o">(</span><span class="tok-nc">ItemViewCount</span><span class="tok-o">(</span><span class="tok-n">itemId</span><span class="tok-o">,</span> <span class="tok-n">window</span><span class="tok-o">.</span><span class="tok-n">getEnd</span><span class="tok-o">,</span> <span class="tok-n">count</span><span class="tok-o">))</span>
  <span class="tok-o">}</span>
<span class="tok-o">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>现在我们就得到了每个商品在每个窗口的点击量的数据流。</p>
</div>
<div class="sect4">
<h5 id="_计算最热门top_n商品">计算最热门Top N商品</h5>
<div class="paragraph">
<p>为了统计每个窗口下最热门的商品，我们需要再次按窗口进行分组，这里根据ItemViewCount中的windowEnd进行keyBy()操作。然后使用ProcessFunction实现一个自定义的TopN函数TopNHotItems来计算点击量排名前3名的商品，并将排名结果格式化成字符串，便于后续输出。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-o">.</span><span class="tok-n">keyBy</span><span class="tok-o">(</span><span class="tok-s">&quot;windowEnd&quot;</span><span class="tok-o">)</span>
<span class="tok-o">.</span><span class="tok-n">process</span><span class="tok-o">(</span><span class="tok-k">new</span> <span class="tok-nc">TopNHotItems</span><span class="tok-o">(</span><span class="tok-mi">3</span><span class="tok-o">))</span> <span class="tok-c1">// 求点击量前3名的商品</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>ProcessFunction是Flink提供的一个low-level API，用于实现更高级的功能。它主要提供了定时器timer的功能（支持EventTime或ProcessingTime）。本案例中我们将利用timer来判断何时收齐了某个window下所有商品的点击量数据。由于Watermark的进度是全局的，在processElement方法中，每当收到一条数据ItemViewCount，我们就注册一个windowEnd+1的定时器（Flink框架会自动忽略同一时间的重复注册）。windowEnd+1的定时器被触发时，意味着收到了windowEnd+1的Watermark，即收齐了该windowEnd下的所有商品窗口统计值。我们在onTimer()中处理将收集的所有商品及点击量进行排序，选出TopN，并将排名信息格式化成字符串后进行输出。</p>
</div>
<div class="paragraph">
<p>这里我们还使用了ListState&lt;ItemViewCount&gt;来存储收到的每条ItemViewCount消息，保证在发生故障时，状态数据的不丢失和一致性。ListState是Flink提供的类似Java List接口的State API，它集成了框架的checkpoint机制，自动做到了exactly-once的语义保证。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span>  <span class="tok-c1">// 求某个窗口中前 N 名的热门点击商品，key 为窗口时间戳，输出为 TopN 的结果字符串</span>
  <span class="tok-k">class</span> <span class="tok-nc">TopNHotItems</span><span class="tok-o">(</span><span class="tok-n">topSize</span><span class="tok-k">:</span> <span class="tok-kt">Int</span><span class="tok-o">)</span> <span class="tok-k">extends</span> <span class="tok-nc">KeyedProcessFunction</span><span class="tok-o">[</span><span class="tok-kt">Tuple</span>, <span class="tok-kt">ItemViewCount</span>, <span class="tok-kt">String</span><span class="tok-o">]</span> <span class="tok-o">{</span>
    <span class="tok-k">private</span> <span class="tok-k">var</span> <span class="tok-n">itemState</span> <span class="tok-k">:</span> <span class="tok-kt">ListState</span><span class="tok-o">[</span><span class="tok-kt">ItemViewCount</span><span class="tok-o">]</span> <span class="tok-k">=</span> <span class="tok-k">_</span>

    <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">open</span><span class="tok-o">(</span><span class="tok-n">parameters</span><span class="tok-k">:</span> <span class="tok-kt">Configuration</span><span class="tok-o">)</span><span class="tok-k">:</span> <span class="tok-kt">Unit</span> <span class="tok-o">=</span> <span class="tok-o">{</span>
      <span class="tok-k">super</span><span class="tok-o">.</span><span class="tok-n">open</span><span class="tok-o">(</span><span class="tok-n">parameters</span><span class="tok-o">)</span>
      <span class="tok-c1">// 命名状态变量的名字和状态变量的类型</span>
      <span class="tok-k">val</span> <span class="tok-n">itemsStateDesc</span> <span class="tok-k">=</span> <span class="tok-k">new</span> <span class="tok-nc">ListStateDescriptor</span><span class="tok-o">[</span><span class="tok-kt">ItemViewCount</span><span class="tok-o">](</span><span class="tok-s">&quot;itemState-state&quot;</span><span class="tok-o">,</span> <span class="tok-n">classOf</span><span class="tok-o">[</span><span class="tok-kt">ItemViewCount</span><span class="tok-o">])</span>
      <span class="tok-c1">// 定义状态变量</span>
      <span class="tok-n">itemState</span> <span class="tok-k">=</span> <span class="tok-n">getRuntimeContext</span><span class="tok-o">.</span><span class="tok-n">getListState</span><span class="tok-o">(</span><span class="tok-n">itemsStateDesc</span><span class="tok-o">)</span>
    <span class="tok-o">}</span>

    <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">processElement</span><span class="tok-o">(</span><span class="tok-n">input</span><span class="tok-k">:</span> <span class="tok-kt">ItemViewCount</span><span class="tok-o">,</span> <span class="tok-n">context</span><span class="tok-k">:</span> <span class="tok-kt">KeyedProcessFunction</span><span class="tok-o">[</span><span class="tok-kt">Tuple</span>, <span class="tok-kt">ItemViewCount</span>, <span class="tok-kt">String</span><span class="tok-o">]</span><span class="tok-k">#</span><span class="tok-nc">Context</span><span class="tok-o">,</span> <span class="tok-n">collector</span><span class="tok-k">:</span> <span class="tok-kt">Collector</span><span class="tok-o">[</span><span class="tok-kt">String</span><span class="tok-o">])</span><span class="tok-k">:</span> <span class="tok-kt">Unit</span> <span class="tok-o">=</span> <span class="tok-o">{</span>
      <span class="tok-c1">// 每条数据都保存到状态中</span>
      <span class="tok-n">itemState</span><span class="tok-o">.</span><span class="tok-n">add</span><span class="tok-o">(</span><span class="tok-n">input</span><span class="tok-o">)</span>
      <span class="tok-c1">// 注册 windowEnd+1 的 EventTime Timer, 当触发时，说明收齐了属于windowEnd窗口的所有商品数据</span>
      <span class="tok-c1">// 也就是当程序看到windowend + 1的水位线watermark时，触发onTimer回调函数</span>
      <span class="tok-n">context</span><span class="tok-o">.</span><span class="tok-n">timerService</span><span class="tok-o">.</span><span class="tok-n">registerEventTimeTimer</span><span class="tok-o">(</span><span class="tok-n">input</span><span class="tok-o">.</span><span class="tok-n">windowEnd</span> <span class="tok-o">+</span> <span class="tok-mi">1</span><span class="tok-o">)</span>
    <span class="tok-o">}</span>

    <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">onTimer</span><span class="tok-o">(</span><span class="tok-n">timestamp</span><span class="tok-k">:</span> <span class="tok-kt">Long</span><span class="tok-o">,</span> <span class="tok-n">ctx</span><span class="tok-k">:</span> <span class="tok-kt">KeyedProcessFunction</span><span class="tok-o">[</span><span class="tok-kt">Tuple</span>, <span class="tok-kt">ItemViewCount</span>, <span class="tok-kt">String</span><span class="tok-o">]</span><span class="tok-k">#</span><span class="tok-nc">OnTimerContext</span><span class="tok-o">,</span> <span class="tok-n">out</span><span class="tok-k">:</span> <span class="tok-kt">Collector</span><span class="tok-o">[</span><span class="tok-kt">String</span><span class="tok-o">])</span><span class="tok-k">:</span> <span class="tok-kt">Unit</span> <span class="tok-o">=</span> <span class="tok-o">{</span>
      <span class="tok-c1">// 获取收到的所有商品点击量</span>
      <span class="tok-k">val</span> <span class="tok-n">allItems</span><span class="tok-k">:</span> <span class="tok-kt">ListBuffer</span><span class="tok-o">[</span><span class="tok-kt">ItemViewCount</span><span class="tok-o">]</span> <span class="tok-k">=</span> <span class="tok-nc">ListBuffer</span><span class="tok-o">()</span>
      <span class="tok-k">import</span> <span class="tok-nn">scala.collection.JavaConversions._</span>
      <span class="tok-k">for</span> <span class="tok-o">(</span><span class="tok-n">item</span> <span class="tok-k">&lt;-</span> <span class="tok-n">itemState</span><span class="tok-o">.</span><span class="tok-n">get</span><span class="tok-o">)</span> <span class="tok-o">{</span>
        <span class="tok-n">allItems</span> <span class="tok-o">+=</span> <span class="tok-n">item</span>
      <span class="tok-o">}</span>
      <span class="tok-c1">// 提前清除状态中的数据，释放空间</span>
      <span class="tok-n">itemState</span><span class="tok-o">.</span><span class="tok-n">clear</span><span class="tok-o">()</span>
      <span class="tok-c1">// 按照点击量从大到小排序</span>
      <span class="tok-k">val</span> <span class="tok-n">sortedItems</span> <span class="tok-k">=</span> <span class="tok-n">allItems</span><span class="tok-o">.</span><span class="tok-n">sortBy</span><span class="tok-o">(</span><span class="tok-k">_</span><span class="tok-o">.</span><span class="tok-n">count</span><span class="tok-o">)(</span><span class="tok-nc">Ordering</span><span class="tok-o">.</span><span class="tok-nc">Long</span><span class="tok-o">.</span><span class="tok-n">reverse</span><span class="tok-o">).</span><span class="tok-n">take</span><span class="tok-o">(</span><span class="tok-n">topSize</span><span class="tok-o">)</span>
      <span class="tok-c1">// 将排名信息格式化成 String, 便于打印</span>
      <span class="tok-k">val</span> <span class="tok-n">result</span><span class="tok-k">:</span> <span class="tok-kt">StringBuilder</span> <span class="tok-o">=</span> <span class="tok-k">new</span> <span class="tok-nc">StringBuilder</span>
      <span class="tok-n">result</span><span class="tok-o">.</span><span class="tok-n">append</span><span class="tok-o">(</span><span class="tok-s">&quot;====================================\n&quot;</span><span class="tok-o">)</span>
      <span class="tok-n">result</span><span class="tok-o">.</span><span class="tok-n">append</span><span class="tok-o">(</span><span class="tok-s">&quot;时间: &quot;</span><span class="tok-o">).</span><span class="tok-n">append</span><span class="tok-o">(</span><span class="tok-k">new</span> <span class="tok-nc">Timestamp</span><span class="tok-o">(</span><span class="tok-n">timestamp</span> <span class="tok-o">-</span> <span class="tok-mi">1</span><span class="tok-o">)).</span><span class="tok-n">append</span><span class="tok-o">(</span><span class="tok-s">&quot;\n&quot;</span><span class="tok-o">)</span>

      <span class="tok-k">for</span><span class="tok-o">(</span><span class="tok-n">i</span> <span class="tok-k">&lt;-</span> <span class="tok-n">sortedItems</span><span class="tok-o">.</span><span class="tok-n">indices</span><span class="tok-o">){</span>
        <span class="tok-k">val</span> <span class="tok-n">currentItem</span><span class="tok-k">:</span> <span class="tok-kt">ItemViewCount</span> <span class="tok-o">=</span> <span class="tok-n">sortedItems</span><span class="tok-o">(</span><span class="tok-n">i</span><span class="tok-o">)</span>
        <span class="tok-c1">// e.g.  No1：  商品ID=12224  浏览量=2413</span>
        <span class="tok-n">result</span><span class="tok-o">.</span><span class="tok-n">append</span><span class="tok-o">(</span><span class="tok-s">&quot;No&quot;</span><span class="tok-o">).</span><span class="tok-n">append</span><span class="tok-o">(</span><span class="tok-n">i</span><span class="tok-o">+</span><span class="tok-mi">1</span><span class="tok-o">).</span><span class="tok-n">append</span><span class="tok-o">(</span><span class="tok-s">&quot;:&quot;</span><span class="tok-o">)</span>
              <span class="tok-o">.</span><span class="tok-n">append</span><span class="tok-o">(</span><span class="tok-s">&quot;  商品ID=&quot;</span><span class="tok-o">).</span><span class="tok-n">append</span><span class="tok-o">(</span><span class="tok-n">currentItem</span><span class="tok-o">.</span><span class="tok-n">itemId</span><span class="tok-o">)</span>
              <span class="tok-o">.</span><span class="tok-n">append</span><span class="tok-o">(</span><span class="tok-s">&quot;  浏览量=&quot;</span><span class="tok-o">).</span><span class="tok-n">append</span><span class="tok-o">(</span><span class="tok-n">currentItem</span><span class="tok-o">.</span><span class="tok-n">count</span><span class="tok-o">).</span><span class="tok-n">append</span><span class="tok-o">(</span><span class="tok-s">&quot;\n&quot;</span><span class="tok-o">)</span>
      <span class="tok-o">}</span>
      <span class="tok-n">result</span><span class="tok-o">.</span><span class="tok-n">append</span><span class="tok-o">(</span><span class="tok-s">&quot;====================================\n\n&quot;</span><span class="tok-o">)</span>
      <span class="tok-c1">// 控制输出频率，模拟实时滚动结果</span>
      <span class="tok-nc">Thread</span><span class="tok-o">.</span><span class="tok-n">sleep</span><span class="tok-o">(</span><span class="tok-mi">1000</span><span class="tok-o">)</span>
      <span class="tok-n">out</span><span class="tok-o">.</span><span class="tok-n">collect</span><span class="tok-o">(</span><span class="tok-n">result</span><span class="tok-o">.</span><span class="tok-n">toString</span><span class="tok-o">)</span>
    <span class="tok-o">}</span>
  <span class="tok-o">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>最后我们可以在main函数中将结果打印输出到控制台，方便实时观测：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-o">.</span><span class="tok-n">print</span><span class="tok-o">()</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>至此整个程序代码全部完成，我们直接运行main函数，就可以在控制台看到不断输出的各个时间点统计出的热门商品。</p>
</div>
</div>
<div class="sect4">
<h5 id="_完整代码">完整代码</h5>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">import</span> <span class="tok-nn">java.sql.Timestamp</span>
<span class="tok-k">import</span> <span class="tok-nn">java.util.</span><span class="tok-o">{</span><span class="tok-nc">ArrayList</span><span class="tok-o">,</span> <span class="tok-nc">Comparator</span><span class="tok-o">,</span> <span class="tok-nc">List</span><span class="tok-o">}</span>

<span class="tok-k">import</span> <span class="tok-nn">org.apache.flink.streaming.api.TimeCharacteristic</span>
<span class="tok-k">import</span> <span class="tok-nn">org.apache.flink.streaming.api.scala.StreamExecutionEnvironment</span>
<span class="tok-k">import</span> <span class="tok-nn">org.apache.flink.streaming.api.scala._</span>
<span class="tok-k">import</span> <span class="tok-nn">org.apache.flink.streaming.api.windowing.time.Time</span>
<span class="tok-k">import</span> <span class="tok-nn">org.apache.flink.api.common.functions.AggregateFunction</span>
<span class="tok-k">import</span> <span class="tok-nn">org.apache.flink.streaming.api.scala.function.WindowFunction</span>
<span class="tok-k">import</span> <span class="tok-nn">org.apache.flink.streaming.api.windowing.windows.TimeWindow</span>
<span class="tok-k">import</span> <span class="tok-nn">org.apache.flink.api.java.tuple.Tuple</span>
<span class="tok-k">import</span> <span class="tok-nn">org.apache.flink.api.java.tuple.Tuple1</span>
<span class="tok-k">import</span> <span class="tok-nn">org.apache.flink.util.Collector</span>
<span class="tok-k">import</span> <span class="tok-nn">org.apache.flink.streaming.api.functions.KeyedProcessFunction</span>
<span class="tok-k">import</span> <span class="tok-nn">org.apache.flink.api.common.state.ListState</span>
<span class="tok-k">import</span> <span class="tok-nn">org.apache.flink.api.common.state.ListStateDescriptor</span>
<span class="tok-k">import</span> <span class="tok-nn">org.apache.flink.configuration.Configuration</span>

<span class="tok-k">import</span> <span class="tok-nn">scala.collection.mutable.ListBuffer</span>

<span class="tok-k">case</span> <span class="tok-k">class</span> <span class="tok-nc">UserBehavior</span><span class="tok-o">(</span><span class="tok-n">userId</span><span class="tok-k">:</span> <span class="tok-kt">Long</span><span class="tok-o">,</span> <span class="tok-n">itemId</span><span class="tok-k">:</span> <span class="tok-kt">Long</span><span class="tok-o">,</span> <span class="tok-n">categoryId</span><span class="tok-k">:</span> <span class="tok-kt">Int</span><span class="tok-o">,</span> <span class="tok-n">behavior</span><span class="tok-k">:</span> <span class="tok-kt">String</span><span class="tok-o">,</span> <span class="tok-n">timestamp</span><span class="tok-k">:</span> <span class="tok-kt">Long</span><span class="tok-o">)</span>

<span class="tok-k">case</span> <span class="tok-k">class</span> <span class="tok-nc">ItemViewCount</span><span class="tok-o">(</span><span class="tok-n">itemId</span><span class="tok-k">:</span> <span class="tok-kt">Long</span><span class="tok-o">,</span> <span class="tok-n">windowEnd</span><span class="tok-k">:</span> <span class="tok-kt">Long</span><span class="tok-o">,</span> <span class="tok-n">count</span><span class="tok-k">:</span> <span class="tok-kt">Long</span><span class="tok-o">)</span>

<span class="tok-k">object</span> <span class="tok-nc">HotItems</span> <span class="tok-o">{</span>

  <span class="tok-k">def</span> <span class="tok-n">main</span><span class="tok-o">(</span><span class="tok-n">args</span><span class="tok-k">:</span> <span class="tok-kt">Array</span><span class="tok-o">[</span><span class="tok-kt">String</span><span class="tok-o">])</span><span class="tok-k">:</span> <span class="tok-kt">Unit</span> <span class="tok-o">=</span> <span class="tok-o">{</span>
    <span class="tok-k">val</span> <span class="tok-n">env</span> <span class="tok-k">=</span> <span class="tok-nc">StreamExecutionEnvironment</span><span class="tok-o">.</span><span class="tok-n">getExecutionEnvironment</span>
    <span class="tok-n">env</span><span class="tok-o">.</span><span class="tok-n">setStreamTimeCharacteristic</span><span class="tok-o">(</span><span class="tok-nc">TimeCharacteristic</span><span class="tok-o">.</span><span class="tok-nc">EventTime</span><span class="tok-o">)</span>
    <span class="tok-n">env</span><span class="tok-o">.</span><span class="tok-n">setParallelism</span><span class="tok-o">(</span><span class="tok-mi">1</span><span class="tok-o">)</span>
    <span class="tok-k">val</span> <span class="tok-n">stream</span> <span class="tok-k">=</span> <span class="tok-n">env</span>
      <span class="tok-o">.</span><span class="tok-n">readTextFile</span><span class="tok-o">(</span><span class="tok-s">&quot;YOUR_PATH\\resources\\UserBehavior.csv&quot;</span><span class="tok-o">)</span>
      <span class="tok-o">.</span><span class="tok-n">map</span><span class="tok-o">(</span><span class="tok-n">line</span> <span class="tok-k">=&gt;</span> <span class="tok-o">{</span>
        <span class="tok-k">val</span> <span class="tok-n">linearray</span> <span class="tok-k">=</span> <span class="tok-n">line</span><span class="tok-o">.</span><span class="tok-n">split</span><span class="tok-o">(</span><span class="tok-s">&quot;,&quot;</span><span class="tok-o">)</span>
        <span class="tok-nc">UserBehavior</span><span class="tok-o">(</span><span class="tok-n">linearray</span><span class="tok-o">(</span><span class="tok-mi">0</span><span class="tok-o">).</span><span class="tok-n">toLong</span><span class="tok-o">,</span> <span class="tok-n">linearray</span><span class="tok-o">(</span><span class="tok-mi">1</span><span class="tok-o">).</span><span class="tok-n">toLong</span><span class="tok-o">,</span> <span class="tok-n">linearray</span><span class="tok-o">(</span><span class="tok-mi">2</span><span class="tok-o">).</span><span class="tok-n">toInt</span><span class="tok-o">,</span> <span class="tok-n">linearray</span><span class="tok-o">(</span><span class="tok-mi">3</span><span class="tok-o">),</span> <span class="tok-n">linearray</span><span class="tok-o">(</span><span class="tok-mi">4</span><span class="tok-o">).</span><span class="tok-n">toLong</span><span class="tok-o">)</span>
      <span class="tok-o">})</span>
      <span class="tok-o">.</span><span class="tok-n">assignAscendingTimestamps</span><span class="tok-o">(</span><span class="tok-k">_</span><span class="tok-o">.</span><span class="tok-n">timestamp</span> <span class="tok-o">*</span> <span class="tok-mi">1000</span><span class="tok-o">)</span>
      <span class="tok-o">.</span><span class="tok-n">filter</span><span class="tok-o">(</span><span class="tok-k">_</span><span class="tok-o">.</span><span class="tok-n">behavior</span><span class="tok-o">==</span><span class="tok-s">&quot;pv&quot;</span><span class="tok-o">)</span>
      <span class="tok-o">.</span><span class="tok-n">keyBy</span><span class="tok-o">(</span><span class="tok-s">&quot;itemId&quot;</span><span class="tok-o">)</span>
      <span class="tok-o">.</span><span class="tok-n">timeWindow</span><span class="tok-o">(</span><span class="tok-nc">Time</span><span class="tok-o">.</span><span class="tok-n">minutes</span><span class="tok-o">(</span><span class="tok-mi">60</span><span class="tok-o">),</span> <span class="tok-nc">Time</span><span class="tok-o">.</span><span class="tok-n">minutes</span><span class="tok-o">(</span><span class="tok-mi">5</span><span class="tok-o">))</span>
      <span class="tok-o">.</span><span class="tok-n">aggregate</span><span class="tok-o">(</span><span class="tok-k">new</span> <span class="tok-nc">CountAgg</span><span class="tok-o">(),</span> <span class="tok-k">new</span> <span class="tok-nc">WindowResultFunction</span><span class="tok-o">())</span>
      <span class="tok-o">.</span><span class="tok-n">keyBy</span><span class="tok-o">(</span><span class="tok-mi">1</span><span class="tok-o">)</span>
      <span class="tok-o">.</span><span class="tok-n">process</span><span class="tok-o">(</span><span class="tok-k">new</span> <span class="tok-nc">TopNHotItems</span><span class="tok-o">(</span><span class="tok-mi">3</span><span class="tok-o">))</span>
      <span class="tok-o">.</span><span class="tok-n">print</span><span class="tok-o">()</span>

    <span class="tok-n">env</span><span class="tok-o">.</span><span class="tok-n">execute</span><span class="tok-o">(</span><span class="tok-s">&quot;Hot Items Job&quot;</span><span class="tok-o">)</span>
  <span class="tok-o">}</span>

  <span class="tok-c1">// COUNT 统计的聚合函数实现，每出现一条记录加一</span>
  <span class="tok-k">class</span> <span class="tok-nc">CountAgg</span> <span class="tok-k">extends</span> <span class="tok-nc">AggregateFunction</span><span class="tok-o">[</span><span class="tok-kt">UserBehavior</span>, <span class="tok-kt">Long</span>, <span class="tok-kt">Long</span><span class="tok-o">]</span> <span class="tok-o">{</span>
    <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">createAccumulator</span><span class="tok-o">()</span><span class="tok-k">:</span> <span class="tok-kt">Long</span> <span class="tok-o">=</span> <span class="tok-mi">0L</span>
    <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">add</span><span class="tok-o">(</span><span class="tok-n">userBehavior</span><span class="tok-k">:</span> <span class="tok-kt">UserBehavior</span><span class="tok-o">,</span> <span class="tok-n">acc</span><span class="tok-k">:</span> <span class="tok-kt">Long</span><span class="tok-o">)</span><span class="tok-k">:</span> <span class="tok-kt">Long</span> <span class="tok-o">=</span> <span class="tok-n">acc</span> <span class="tok-o">+</span> <span class="tok-mi">1</span>
    <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">getResult</span><span class="tok-o">(</span><span class="tok-n">acc</span><span class="tok-k">:</span> <span class="tok-kt">Long</span><span class="tok-o">)</span><span class="tok-k">:</span> <span class="tok-kt">Long</span> <span class="tok-o">=</span> <span class="tok-n">acc</span>
    <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">merge</span><span class="tok-o">(</span><span class="tok-n">acc1</span><span class="tok-k">:</span> <span class="tok-kt">Long</span><span class="tok-o">,</span> <span class="tok-n">acc2</span><span class="tok-k">:</span> <span class="tok-kt">Long</span><span class="tok-o">)</span><span class="tok-k">:</span> <span class="tok-kt">Long</span> <span class="tok-o">=</span> <span class="tok-n">acc1</span> <span class="tok-o">+</span> <span class="tok-n">acc2</span>
  <span class="tok-o">}</span>
  <span class="tok-c1">// 用于输出窗口的结果</span>
  <span class="tok-k">class</span> <span class="tok-nc">WindowResultFunction</span> <span class="tok-k">extends</span> <span class="tok-nc">WindowFunction</span><span class="tok-o">[</span><span class="tok-kt">Long</span>, <span class="tok-kt">ItemViewCount</span>, <span class="tok-kt">Tuple</span>, <span class="tok-kt">TimeWindow</span><span class="tok-o">]</span> <span class="tok-o">{</span>
    <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">apply</span><span class="tok-o">(</span><span class="tok-n">key</span><span class="tok-k">:</span> <span class="tok-kt">Tuple</span><span class="tok-o">,</span> <span class="tok-n">window</span><span class="tok-k">:</span> <span class="tok-kt">TimeWindow</span><span class="tok-o">,</span> <span class="tok-n">aggregateResult</span><span class="tok-k">:</span> <span class="tok-kt">Iterable</span><span class="tok-o">[</span><span class="tok-kt">Long</span><span class="tok-o">],</span> <span class="tok-n">collector</span><span class="tok-k">:</span> <span class="tok-kt">Collector</span><span class="tok-o">[</span><span class="tok-kt">ItemViewCount</span><span class="tok-o">])</span> <span class="tok-k">:</span> <span class="tok-kt">Unit</span> <span class="tok-o">=</span> <span class="tok-o">{</span>
      <span class="tok-k">val</span> <span class="tok-n">itemId</span><span class="tok-k">:</span> <span class="tok-kt">Long</span> <span class="tok-o">=</span> <span class="tok-n">key</span><span class="tok-o">.</span><span class="tok-n">asInstanceOf</span><span class="tok-o">[</span><span class="tok-kt">Tuple1</span><span class="tok-o">[</span><span class="tok-kt">Long</span><span class="tok-o">]].</span><span class="tok-n">f0</span>
      <span class="tok-k">val</span> <span class="tok-n">count</span> <span class="tok-k">=</span> <span class="tok-n">aggregateResult</span><span class="tok-o">.</span><span class="tok-n">iterator</span><span class="tok-o">.</span><span class="tok-n">next</span>
      <span class="tok-n">collector</span><span class="tok-o">.</span><span class="tok-n">collect</span><span class="tok-o">(</span><span class="tok-nc">ItemViewCount</span><span class="tok-o">(</span><span class="tok-n">itemId</span><span class="tok-o">,</span> <span class="tok-n">window</span><span class="tok-o">.</span><span class="tok-n">getEnd</span><span class="tok-o">,</span> <span class="tok-n">count</span><span class="tok-o">))</span>
    <span class="tok-o">}</span>
  <span class="tok-o">}</span>

<span class="tok-c1">// 求某个窗口中前 N 名的热门点击商品，key 为窗口时间戳，输出为 TopN 的结果字符串</span>
  <span class="tok-k">class</span> <span class="tok-nc">TopNHotItems</span><span class="tok-o">(</span><span class="tok-n">topSize</span><span class="tok-k">:</span> <span class="tok-kt">Int</span><span class="tok-o">)</span> <span class="tok-k">extends</span> <span class="tok-nc">KeyedProcessFunction</span><span class="tok-o">[</span><span class="tok-kt">Tuple</span>, <span class="tok-kt">ItemViewCount</span>, <span class="tok-kt">String</span><span class="tok-o">]</span> <span class="tok-o">{</span>
    <span class="tok-k">private</span> <span class="tok-k">var</span> <span class="tok-n">itemState</span> <span class="tok-k">:</span> <span class="tok-kt">ListState</span><span class="tok-o">[</span><span class="tok-kt">ItemViewCount</span><span class="tok-o">]</span> <span class="tok-k">=</span> <span class="tok-k">_</span>

    <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">open</span><span class="tok-o">(</span><span class="tok-n">parameters</span><span class="tok-k">:</span> <span class="tok-kt">Configuration</span><span class="tok-o">)</span><span class="tok-k">:</span> <span class="tok-kt">Unit</span> <span class="tok-o">=</span> <span class="tok-o">{</span>
      <span class="tok-k">super</span><span class="tok-o">.</span><span class="tok-n">open</span><span class="tok-o">(</span><span class="tok-n">parameters</span><span class="tok-o">)</span>
      <span class="tok-c1">// 命名状态变量的名字和状态变量的类型</span>
      <span class="tok-k">val</span> <span class="tok-n">itemsStateDesc</span> <span class="tok-k">=</span> <span class="tok-k">new</span> <span class="tok-nc">ListStateDescriptor</span><span class="tok-o">[</span><span class="tok-kt">ItemViewCount</span><span class="tok-o">](</span><span class="tok-s">&quot;itemState-state&quot;</span><span class="tok-o">,</span> <span class="tok-n">classOf</span><span class="tok-o">[</span><span class="tok-kt">ItemViewCount</span><span class="tok-o">])</span>
      <span class="tok-c1">// 从运行时上下文中获取状态并赋值</span>
      <span class="tok-n">itemState</span> <span class="tok-k">=</span> <span class="tok-n">getRuntimeContext</span><span class="tok-o">.</span><span class="tok-n">getListState</span><span class="tok-o">(</span><span class="tok-n">itemsStateDesc</span><span class="tok-o">)</span>
    <span class="tok-o">}</span>

    <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">processElement</span><span class="tok-o">(</span><span class="tok-n">input</span><span class="tok-k">:</span> <span class="tok-kt">ItemViewCount</span><span class="tok-o">,</span> <span class="tok-n">context</span><span class="tok-k">:</span> <span class="tok-kt">KeyedProcessFunction</span><span class="tok-o">[</span><span class="tok-kt">Tuple</span>, <span class="tok-kt">ItemViewCount</span>, <span class="tok-kt">String</span><span class="tok-o">]</span><span class="tok-k">#</span><span class="tok-nc">Context</span><span class="tok-o">,</span> <span class="tok-n">collector</span><span class="tok-k">:</span> <span class="tok-kt">Collector</span><span class="tok-o">[</span><span class="tok-kt">String</span><span class="tok-o">])</span><span class="tok-k">:</span> <span class="tok-kt">Unit</span> <span class="tok-o">=</span> <span class="tok-o">{</span>
      <span class="tok-c1">// 每条数据都保存到状态中</span>
      <span class="tok-n">itemState</span><span class="tok-o">.</span><span class="tok-n">add</span><span class="tok-o">(</span><span class="tok-n">input</span><span class="tok-o">)</span>
      <span class="tok-c1">// 注册 windowEnd+1 的 EventTime Timer, 当触发时，说明收齐了属于windowEnd窗口的所有商品数据</span>
      <span class="tok-c1">// 也就是当程序看到windowend + 1的水位线watermark时，触发onTimer回调函数</span>
      <span class="tok-n">context</span><span class="tok-o">.</span><span class="tok-n">timerService</span><span class="tok-o">.</span><span class="tok-n">registerEventTimeTimer</span><span class="tok-o">(</span><span class="tok-n">input</span><span class="tok-o">.</span><span class="tok-n">windowEnd</span> <span class="tok-o">+</span> <span class="tok-mi">1</span><span class="tok-o">)</span>
    <span class="tok-o">}</span>

    <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">onTimer</span><span class="tok-o">(</span><span class="tok-n">timestamp</span><span class="tok-k">:</span> <span class="tok-kt">Long</span><span class="tok-o">,</span> <span class="tok-n">ctx</span><span class="tok-k">:</span> <span class="tok-kt">KeyedProcessFunction</span><span class="tok-o">[</span><span class="tok-kt">Tuple</span>, <span class="tok-kt">ItemViewCount</span>, <span class="tok-kt">String</span><span class="tok-o">]</span><span class="tok-k">#</span><span class="tok-nc">OnTimerContext</span><span class="tok-o">,</span> <span class="tok-n">out</span><span class="tok-k">:</span> <span class="tok-kt">Collector</span><span class="tok-o">[</span><span class="tok-kt">String</span><span class="tok-o">])</span><span class="tok-k">:</span> <span class="tok-kt">Unit</span> <span class="tok-o">=</span> <span class="tok-o">{</span>
      <span class="tok-c1">// 获取收到的所有商品点击量</span>
      <span class="tok-k">val</span> <span class="tok-n">allItems</span><span class="tok-k">:</span> <span class="tok-kt">ListBuffer</span><span class="tok-o">[</span><span class="tok-kt">ItemViewCount</span><span class="tok-o">]</span> <span class="tok-k">=</span> <span class="tok-nc">ListBuffer</span><span class="tok-o">()</span>
      <span class="tok-k">import</span> <span class="tok-nn">scala.collection.JavaConversions._</span>
      <span class="tok-k">for</span> <span class="tok-o">(</span><span class="tok-n">item</span> <span class="tok-k">&lt;-</span> <span class="tok-n">itemState</span><span class="tok-o">.</span><span class="tok-n">get</span><span class="tok-o">)</span> <span class="tok-o">{</span>
        <span class="tok-n">allItems</span> <span class="tok-o">+=</span> <span class="tok-n">item</span>
      <span class="tok-o">}</span>
      <span class="tok-c1">// 提前清除状态中的数据，释放空间</span>
      <span class="tok-n">itemState</span><span class="tok-o">.</span><span class="tok-n">clear</span><span class="tok-o">()</span>
      <span class="tok-c1">// 按照点击量从大到小排序</span>
      <span class="tok-k">val</span> <span class="tok-n">sortedItems</span> <span class="tok-k">=</span> <span class="tok-n">allItems</span><span class="tok-o">.</span><span class="tok-n">sortBy</span><span class="tok-o">(</span><span class="tok-k">_</span><span class="tok-o">.</span><span class="tok-n">count</span><span class="tok-o">)(</span><span class="tok-nc">Ordering</span><span class="tok-o">.</span><span class="tok-nc">Long</span><span class="tok-o">.</span><span class="tok-n">reverse</span><span class="tok-o">).</span><span class="tok-n">take</span><span class="tok-o">(</span><span class="tok-n">topSize</span><span class="tok-o">)</span>
      <span class="tok-c1">// 将排名信息格式化成 String, 便于打印</span>
      <span class="tok-k">val</span> <span class="tok-n">result</span><span class="tok-k">:</span> <span class="tok-kt">StringBuilder</span> <span class="tok-o">=</span> <span class="tok-k">new</span> <span class="tok-nc">StringBuilder</span>
      <span class="tok-n">result</span><span class="tok-o">.</span><span class="tok-n">append</span><span class="tok-o">(</span><span class="tok-s">&quot;====================================\n&quot;</span><span class="tok-o">)</span>
      <span class="tok-n">result</span><span class="tok-o">.</span><span class="tok-n">append</span><span class="tok-o">(</span><span class="tok-s">&quot;时间: &quot;</span><span class="tok-o">).</span><span class="tok-n">append</span><span class="tok-o">(</span><span class="tok-k">new</span> <span class="tok-nc">Timestamp</span><span class="tok-o">(</span><span class="tok-n">timestamp</span> <span class="tok-o">-</span> <span class="tok-mi">1</span><span class="tok-o">)).</span><span class="tok-n">append</span><span class="tok-o">(</span><span class="tok-s">&quot;\n&quot;</span><span class="tok-o">)</span>

      <span class="tok-k">for</span><span class="tok-o">(</span><span class="tok-n">i</span> <span class="tok-k">&lt;-</span> <span class="tok-n">sortedItems</span><span class="tok-o">.</span><span class="tok-n">indices</span><span class="tok-o">){</span>
        <span class="tok-k">val</span> <span class="tok-n">currentItem</span><span class="tok-k">:</span> <span class="tok-kt">ItemViewCount</span> <span class="tok-o">=</span> <span class="tok-n">sortedItems</span><span class="tok-o">(</span><span class="tok-n">i</span><span class="tok-o">)</span>

        <span class="tok-c1">// e.g. No1：商品ID=12224 浏览量=2413</span>
        <span class="tok-n">result</span>
          <span class="tok-o">.</span><span class="tok-n">append</span><span class="tok-o">(</span><span class="tok-s">&quot;No&quot;</span><span class="tok-o">)</span>
          <span class="tok-o">.</span><span class="tok-n">append</span><span class="tok-o">(</span><span class="tok-n">i</span><span class="tok-o">+</span><span class="tok-mi">1</span><span class="tok-o">)</span>
          <span class="tok-o">.</span><span class="tok-n">append</span><span class="tok-o">(</span><span class="tok-s">&quot;:&quot;</span><span class="tok-o">)</span>
          <span class="tok-o">.</span><span class="tok-n">append</span><span class="tok-o">(</span><span class="tok-s">&quot;  商品ID=&quot;</span><span class="tok-o">)</span>
          <span class="tok-o">.</span><span class="tok-n">append</span><span class="tok-o">(</span><span class="tok-n">currentItem</span><span class="tok-o">.</span><span class="tok-n">itemId</span><span class="tok-o">)</span>
          <span class="tok-o">.</span><span class="tok-n">append</span><span class="tok-o">(</span><span class="tok-s">&quot;  浏览量=&quot;</span><span class="tok-o">)</span>
          <span class="tok-o">.</span><span class="tok-n">append</span><span class="tok-o">(</span><span class="tok-n">currentItem</span><span class="tok-o">.</span><span class="tok-n">count</span><span class="tok-o">).</span><span class="tok-n">append</span><span class="tok-o">(</span><span class="tok-s">&quot;\n&quot;</span><span class="tok-o">)</span>
      <span class="tok-o">}</span>

      <span class="tok-n">result</span><span class="tok-o">.</span><span class="tok-n">append</span><span class="tok-o">(</span><span class="tok-s">&quot;====================================\n\n&quot;</span><span class="tok-o">)</span>
      <span class="tok-c1">// 控制输出频率，模拟实时滚动结果</span>
      <span class="tok-nc">Thread</span><span class="tok-o">.</span><span class="tok-n">sleep</span><span class="tok-o">(</span><span class="tok-mi">1000</span><span class="tok-o">)</span>
      <span class="tok-n">out</span><span class="tok-o">.</span><span class="tok-n">collect</span><span class="tok-o">(</span><span class="tok-n">result</span><span class="tok-o">.</span><span class="tok-n">toString</span><span class="tok-o">)</span>
    <span class="tok-o">}</span>
  <span class="tok-o">}</span>
<span class="tok-o">}</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_更换kafka作为数据源">更换Kafka作为数据源</h5>
<div class="paragraph">
<p>实际生产环境中，我们的数据流往往是从Kafka获取到的。如果要让代码更贴近生产实际，我们只需将source更换为Kafka即可：</p>
</div>
<div class="paragraph">
<p><strong>注意：这里Kafka的版本要用最新版的！</strong></p>
</div>
<div class="paragraph">
<p>Kafka依赖添加：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="xml"><span></span><span class="tok-nt">&lt;dependency&gt;</span>
    <span class="tok-nt">&lt;groupId&gt;</span>org.apache.flink<span class="tok-nt">&lt;/groupId&gt;</span>
    <span class="tok-nt">&lt;artifactId&gt;</span>flink-connector-kafka_${scala.binary.version}<span class="tok-nt">&lt;/artifactId&gt;</span>
    <span class="tok-nt">&lt;version&gt;</span>${flink.version}<span class="tok-nt">&lt;/version&gt;</span>
<span class="tok-nt">&lt;/dependency&gt;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">val</span> <span class="tok-n">properties</span> <span class="tok-k">=</span> <span class="tok-k">new</span> <span class="tok-nc">Properties</span><span class="tok-o">()</span>
<span class="tok-n">properties</span><span class="tok-o">.</span><span class="tok-n">setProperty</span><span class="tok-o">(</span><span class="tok-s">&quot;bootstrap.servers&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;localhost:9092&quot;</span><span class="tok-o">)</span>
<span class="tok-n">properties</span><span class="tok-o">.</span><span class="tok-n">setProperty</span><span class="tok-o">(</span><span class="tok-s">&quot;group.id&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;consumer-group&quot;</span><span class="tok-o">)</span>
<span class="tok-n">properties</span><span class="tok-o">.</span><span class="tok-n">setProperty</span><span class="tok-o">(</span><span class="tok-s">&quot;key.deserializer&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span><span class="tok-o">)</span>
<span class="tok-n">properties</span><span class="tok-o">.</span><span class="tok-n">setProperty</span><span class="tok-o">(</span><span class="tok-s">&quot;value.deserializer&quot;</span><span class="tok-o">,</span>
<span class="tok-s">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span><span class="tok-o">)</span>
<span class="tok-n">properties</span><span class="tok-o">.</span><span class="tok-n">setProperty</span><span class="tok-o">(</span><span class="tok-s">&quot;auto.offset.reset&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;latest&quot;</span><span class="tok-o">)</span>

<span class="tok-k">val</span> <span class="tok-n">env</span> <span class="tok-k">=</span> <span class="tok-nc">StreamExecutionEnvironment</span><span class="tok-o">.</span><span class="tok-n">getExecutionEnvironment</span>
<span class="tok-n">env</span><span class="tok-o">.</span><span class="tok-n">setStreamTimeCharacteristic</span><span class="tok-o">(</span><span class="tok-nc">TimeCharacteristic</span><span class="tok-o">.</span><span class="tok-nc">EventTime</span><span class="tok-o">)</span>
<span class="tok-n">env</span><span class="tok-o">.</span><span class="tok-n">setParallelism</span><span class="tok-o">(</span><span class="tok-mi">1</span><span class="tok-o">)</span>

<span class="tok-k">val</span> <span class="tok-n">stream</span> <span class="tok-k">=</span> <span class="tok-n">env</span>
  <span class="tok-o">.</span><span class="tok-n">addSource</span><span class="tok-o">(</span><span class="tok-k">new</span> <span class="tok-nc">FlinkKafkaConsumer</span><span class="tok-o">[</span><span class="tok-kt">String</span><span class="tok-o">](</span><span class="tok-s">&quot;hotitems&quot;</span><span class="tok-o">,</span> <span class="tok-k">new</span> <span class="tok-nc">SimpleStringSchema</span><span class="tok-o">(),</span> <span class="tok-n">properties</span><span class="tok-o">))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>当然，根据实际的需要，我们还可以将Sink指定为Kafka、ES、Redis或其它存储，这里就不一一展开实现了。</p>
</div>
<div class="paragraph">
<p>kafka生产者程序</p>
</div>
<div class="paragraph">
<p>添加依赖</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="xml"><span></span><span class="tok-nt">&lt;dependency&gt;</span>
    <span class="tok-nt">&lt;groupId&gt;</span>org.apache.kafka<span class="tok-nt">&lt;/groupId&gt;</span>
    <span class="tok-nt">&lt;artifactId&gt;</span>kafka_2.11<span class="tok-nt">&lt;/artifactId&gt;</span>
    <span class="tok-nt">&lt;version&gt;</span>2.2.0<span class="tok-nt">&lt;/version&gt;</span>
<span class="tok-nt">&lt;/dependency&gt;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">import</span> <span class="tok-nn">java.util.Properties</span>
<span class="tok-k">import</span> <span class="tok-nn">org.apache.kafka.clients.producer.</span><span class="tok-o">{</span><span class="tok-nc">KafkaProducer</span><span class="tok-o">,</span> <span class="tok-nc">ProducerRecord</span><span class="tok-o">}</span>

<span class="tok-k">object</span> <span class="tok-nc">KafkaProducerUtil</span> <span class="tok-o">{</span>

  <span class="tok-k">def</span> <span class="tok-n">main</span><span class="tok-o">(</span><span class="tok-n">args</span><span class="tok-k">:</span> <span class="tok-kt">Array</span><span class="tok-o">[</span><span class="tok-kt">String</span><span class="tok-o">])</span><span class="tok-k">:</span> <span class="tok-kt">Unit</span> <span class="tok-o">=</span> <span class="tok-o">{</span>
    <span class="tok-n">writeToKafka</span><span class="tok-o">(</span><span class="tok-s">&quot;hotitems&quot;</span><span class="tok-o">)</span>
  <span class="tok-o">}</span>

  <span class="tok-k">def</span> <span class="tok-n">writeToKafka</span><span class="tok-o">(</span><span class="tok-n">topic</span><span class="tok-k">:</span> <span class="tok-kt">String</span><span class="tok-o">)</span><span class="tok-k">:</span> <span class="tok-kt">Unit</span> <span class="tok-o">=</span> <span class="tok-o">{</span>
    <span class="tok-k">val</span> <span class="tok-n">props</span> <span class="tok-k">=</span> <span class="tok-k">new</span> <span class="tok-nc">Properties</span><span class="tok-o">()</span>
    <span class="tok-n">props</span><span class="tok-o">.</span><span class="tok-n">put</span><span class="tok-o">(</span><span class="tok-s">&quot;bootstrap.servers&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;localhost:9092&quot;</span><span class="tok-o">)</span>
    <span class="tok-n">props</span><span class="tok-o">.</span><span class="tok-n">put</span><span class="tok-o">(</span><span class="tok-s">&quot;key.serializer&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span><span class="tok-o">)</span>
    <span class="tok-n">props</span><span class="tok-o">.</span><span class="tok-n">put</span><span class="tok-o">(</span><span class="tok-s">&quot;value.serializer&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span><span class="tok-o">)</span>
    <span class="tok-k">val</span> <span class="tok-n">producer</span> <span class="tok-k">=</span> <span class="tok-k">new</span> <span class="tok-nc">KafkaProducer</span><span class="tok-o">[</span><span class="tok-kt">String</span>, <span class="tok-kt">String</span><span class="tok-o">](</span><span class="tok-n">props</span><span class="tok-o">)</span>
    <span class="tok-k">val</span> <span class="tok-n">resourcesPath</span> <span class="tok-k">=</span> <span class="tok-n">getClass</span><span class="tok-o">.</span><span class="tok-n">getResource</span><span class="tok-o">(</span><span class="tok-s">&quot;/UserBehavior.csv&quot;</span><span class="tok-o">)</span>
    <span class="tok-k">val</span> <span class="tok-n">bufferedSource</span> <span class="tok-k">=</span> <span class="tok-n">io</span><span class="tok-o">.</span><span class="tok-nc">Source</span><span class="tok-o">.</span><span class="tok-n">fromFile</span><span class="tok-o">(</span><span class="tok-n">resourcesPath</span><span class="tok-o">.</span><span class="tok-n">getPath</span><span class="tok-o">)</span>
    <span class="tok-k">for</span> <span class="tok-o">(</span><span class="tok-n">line</span> <span class="tok-k">&lt;-</span> <span class="tok-n">bufferedSource</span><span class="tok-o">.</span><span class="tok-n">getLines</span><span class="tok-o">)</span> <span class="tok-o">{</span>
      <span class="tok-k">val</span> <span class="tok-n">record</span> <span class="tok-k">=</span> <span class="tok-k">new</span> <span class="tok-nc">ProducerRecord</span><span class="tok-o">[</span><span class="tok-kt">String</span>, <span class="tok-kt">String</span><span class="tok-o">](</span><span class="tok-n">topic</span><span class="tok-o">,</span> <span class="tok-n">line</span><span class="tok-o">)</span>
      <span class="tok-n">producer</span><span class="tok-o">.</span><span class="tok-n">send</span><span class="tok-o">(</span><span class="tok-n">record</span><span class="tok-o">)</span>
    <span class="tok-o">}</span>
    <span class="tok-n">producer</span><span class="tok-o">.</span><span class="tok-n">close</span><span class="tok-o">()</span>
  <span class="tok-o">}</span>
<span class="tok-o">}</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_实时流量统计">12.3. 实时流量统计</h3>
<div class="ulist">
<ul>
<li>
<p>基本需求</p>
<div class="ulist">
<ul>
<li>
<p>从web服务器的日志中，统计实时的访问流量</p>
</li>
<li>
<p>统计每分钟的ip访问量，取出访问量最大的5个地址，每5秒更新一次</p>
</li>
</ul>
</div>
</li>
<li>
<p>解决思路</p>
<div class="ulist">
<ul>
<li>
<p>将apache服务器日志中的时间，转换为时间戳，作为Event Time</p>
</li>
<li>
<p>构建滑动窗口，窗口长度为1分钟，滑动距离为5秒</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_模块创建和数据准备">12.3.1. 模块创建和数据准备</h4>
<div class="paragraph">
<p>在UserBehaviorAnalysis下新建一个maven module作为子项目，命名为NetworkTrafficAnalysis。在这个子模块中，我们同样并没有引入更多的依赖，所以也不需要改动pom文件。</p>
</div>
<div class="paragraph">
<p>在src/main/目录下，将默认源文件目录java改名为scala。将apache服务器的日志文件apache.log复制到资源文件目录src/main/resources下，我们将从这里读取数据。</p>
</div>
</div>
<div class="sect3">
<h4 id="_代码实现">12.3.2. 代码实现</h4>
<div class="paragraph">
<p>我们现在要实现的模块是 “实时流量统计”。对于一个电商平台而言，用户登录的入口流量、不同页面的访问流量都是值得分析的重要数据，而这些数据，可以简单地从web服务器的日志中提取出来。我们在这里实现最基本的“页面浏览数”的统计，也就是读取服务器日志中的每一行log，统计在一段时间内用户访问url的次数。</p>
</div>
<div class="paragraph">
<p>具体做法为：每隔5秒，输出最近10分钟内访问量最多的前N个URL。可以看出，这个需求与之前“实时热门商品统计”非常类似，所以我们完全可以借鉴此前的代码。</p>
</div>
<div class="paragraph">
<p>在src/main/scala下创建TrafficAnalysis.scala文件，新建一个单例对象。定义样例类ApacheLogEvent，这是输入的日志数据流；另外还有UrlViewCount，这是窗口操作统计的输出数据类型。在main函数中创建StreamExecutionEnvironment并做配置，然后从apache.log文件中读取数据，并包装成ApacheLogEvent类型。</p>
</div>
<div class="paragraph">
<p>需要注意的是，原始日志中的时间是“dd/MM/yyyy:HH:mm:ss”的形式，需要定义一个DateTimeFormat将其转换为我们需要的时间戳格式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-o">.</span><span class="tok-n">map</span><span class="tok-o">(</span><span class="tok-n">line</span> <span class="tok-k">=&gt;</span> <span class="tok-o">{</span>
  <span class="tok-k">val</span> <span class="tok-n">linearray</span> <span class="tok-k">=</span> <span class="tok-n">line</span><span class="tok-o">.</span><span class="tok-n">split</span><span class="tok-o">(</span><span class="tok-s">&quot; &quot;</span><span class="tok-o">)</span>
  <span class="tok-k">val</span> <span class="tok-n">sdf</span> <span class="tok-k">=</span> <span class="tok-k">new</span> <span class="tok-nc">SimpleDateFormat</span><span class="tok-o">(</span><span class="tok-s">&quot;dd/MM/yyyy:HH:mm:ss&quot;</span><span class="tok-o">)</span>
  <span class="tok-k">val</span> <span class="tok-n">timestamp</span> <span class="tok-k">=</span> <span class="tok-n">sdf</span><span class="tok-o">.</span><span class="tok-n">parse</span><span class="tok-o">(</span><span class="tok-n">linearray</span><span class="tok-o">(</span><span class="tok-mi">3</span><span class="tok-o">)).</span><span class="tok-n">getTime</span>
  <span class="tok-nc">ApacheLogEvent</span><span class="tok-o">(</span><span class="tok-n">linearray</span><span class="tok-o">(</span><span class="tok-mi">0</span><span class="tok-o">),</span> <span class="tok-n">linearray</span><span class="tok-o">(</span><span class="tok-mi">2</span><span class="tok-o">),</span> <span class="tok-n">timestamp</span><span class="tok-o">,</span> <span class="tok-n">linearray</span><span class="tok-o">(</span><span class="tok-mi">5</span><span class="tok-o">),</span> <span class="tok-n">linearray</span><span class="tok-o">(</span><span class="tok-mi">6</span><span class="tok-o">))</span>
<span class="tok-o">})</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>完整代码如下：</p>
</div>
<div class="listingblock">
<div class="title">NetworkTrafficAnalysis/src/main/scala/TrafficAnalysis.scala</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">case</span> <span class="tok-k">class</span> <span class="tok-nc">ApacheLogEvent</span><span class="tok-o">(</span><span class="tok-n">ip</span><span class="tok-k">:</span> <span class="tok-kt">String</span><span class="tok-o">,</span> <span class="tok-n">userId</span><span class="tok-k">:</span> <span class="tok-kt">String</span><span class="tok-o">,</span> <span class="tok-n">eventTime</span><span class="tok-k">:</span> <span class="tok-kt">Long</span><span class="tok-o">,</span> <span class="tok-n">method</span><span class="tok-k">:</span> <span class="tok-kt">String</span><span class="tok-o">,</span> <span class="tok-n">url</span><span class="tok-k">:</span> <span class="tok-kt">String</span><span class="tok-o">)</span>

<span class="tok-k">case</span> <span class="tok-k">class</span> <span class="tok-nc">UrlViewCount</span><span class="tok-o">(</span><span class="tok-n">url</span><span class="tok-k">:</span> <span class="tok-kt">String</span><span class="tok-o">,</span> <span class="tok-n">windowEnd</span><span class="tok-k">:</span> <span class="tok-kt">Long</span><span class="tok-o">,</span> <span class="tok-n">count</span><span class="tok-k">:</span> <span class="tok-kt">Long</span><span class="tok-o">)</span>

<span class="tok-k">object</span> <span class="tok-nc">TrafficAnalysis</span> <span class="tok-o">{</span>

  <span class="tok-k">def</span> <span class="tok-n">main</span><span class="tok-o">(</span><span class="tok-n">args</span><span class="tok-k">:</span> <span class="tok-kt">Array</span><span class="tok-o">[</span><span class="tok-kt">String</span><span class="tok-o">])</span><span class="tok-k">:</span> <span class="tok-kt">Unit</span> <span class="tok-o">=</span> <span class="tok-o">{</span>
    <span class="tok-k">val</span> <span class="tok-n">env</span> <span class="tok-k">=</span> <span class="tok-nc">StreamExecutionEnvironment</span><span class="tok-o">.</span><span class="tok-n">getExecutionEnvironment</span>
    <span class="tok-n">env</span><span class="tok-o">.</span><span class="tok-n">setStreamTimeCharacteristic</span><span class="tok-o">(</span><span class="tok-nc">TimeCharacteristic</span><span class="tok-o">.</span><span class="tok-nc">EventTime</span><span class="tok-o">)</span>
    <span class="tok-n">env</span><span class="tok-o">.</span><span class="tok-n">setParallelism</span><span class="tok-o">(</span><span class="tok-mi">1</span><span class="tok-o">)</span>
    <span class="tok-k">val</span> <span class="tok-n">stream</span> <span class="tok-k">=</span> <span class="tok-n">env</span>
      <span class="tok-c1">// 以window下为例，需替换成自己的路径</span>
      <span class="tok-o">.</span><span class="tok-n">readTextFile</span><span class="tok-o">(</span><span class="tok-s">&quot;YOUR_PATH\\resources\\apache.log&quot;</span><span class="tok-o">)</span>
      <span class="tok-o">.</span><span class="tok-n">map</span><span class="tok-o">(</span><span class="tok-n">line</span> <span class="tok-k">=&gt;</span> <span class="tok-o">{</span>
        <span class="tok-k">val</span> <span class="tok-n">linearray</span> <span class="tok-k">=</span> <span class="tok-n">line</span><span class="tok-o">.</span><span class="tok-n">split</span><span class="tok-o">(</span><span class="tok-s">&quot; &quot;</span><span class="tok-o">)</span>
        <span class="tok-k">val</span> <span class="tok-n">simpleDateFormat</span> <span class="tok-k">=</span> <span class="tok-k">new</span> <span class="tok-nc">SimpleDateFormat</span><span class="tok-o">(</span><span class="tok-s">&quot;dd/MM/yyyy:HH:mm:ss&quot;</span><span class="tok-o">)</span>
        <span class="tok-k">val</span> <span class="tok-n">timestamp</span> <span class="tok-k">=</span> <span class="tok-n">simpleDateFormat</span><span class="tok-o">.</span><span class="tok-n">parse</span><span class="tok-o">(</span><span class="tok-n">linearray</span><span class="tok-o">(</span><span class="tok-mi">3</span><span class="tok-o">)).</span><span class="tok-n">getTime</span>
        <span class="tok-nc">ApacheLogEvent</span><span class="tok-o">(</span><span class="tok-n">linearray</span><span class="tok-o">(</span><span class="tok-mi">0</span><span class="tok-o">),</span> <span class="tok-n">linearray</span><span class="tok-o">(</span><span class="tok-mi">2</span><span class="tok-o">),</span> <span class="tok-n">timestamp</span><span class="tok-o">,</span> <span class="tok-n">linearray</span><span class="tok-o">(</span><span class="tok-mi">5</span><span class="tok-o">),</span> <span class="tok-n">linearray</span><span class="tok-o">(</span><span class="tok-mi">6</span><span class="tok-o">))</span>
      <span class="tok-o">})</span>
      <span class="tok-o">.</span><span class="tok-n">assignTimestampsAndWatermarks</span><span class="tok-o">(</span><span class="tok-k">new</span> <span class="tok-nc">BoundedOutOfOrdernessTimestampExtractor</span><span class="tok-o">[</span><span class="tok-kt">ApacheLogEvent</span><span class="tok-o">](</span><span class="tok-nc">Time</span><span class="tok-o">.</span><span class="tok-n">milliseconds</span><span class="tok-o">(</span><span class="tok-mi">1000</span><span class="tok-o">))</span> <span class="tok-o">{</span>
        <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">extractTimestamp</span><span class="tok-o">(</span><span class="tok-n">t</span><span class="tok-k">:</span> <span class="tok-kt">ApacheLogEvent</span><span class="tok-o">)</span><span class="tok-k">:</span> <span class="tok-kt">Long</span> <span class="tok-o">=</span> <span class="tok-o">{</span>
          <span class="tok-n">t</span><span class="tok-o">.</span><span class="tok-n">eventTime</span>
        <span class="tok-o">}</span>
      <span class="tok-o">})</span>
      <span class="tok-o">.</span><span class="tok-n">keyBy</span><span class="tok-o">(</span><span class="tok-s">&quot;url&quot;</span><span class="tok-o">)</span>
      <span class="tok-o">.</span><span class="tok-n">timeWindow</span><span class="tok-o">(</span><span class="tok-nc">Time</span><span class="tok-o">.</span><span class="tok-n">minutes</span><span class="tok-o">(</span><span class="tok-mi">10</span><span class="tok-o">),</span> <span class="tok-nc">Time</span><span class="tok-o">.</span><span class="tok-n">seconds</span><span class="tok-o">(</span><span class="tok-mi">5</span><span class="tok-o">))</span>
      <span class="tok-o">.</span><span class="tok-n">aggregate</span><span class="tok-o">(</span><span class="tok-k">new</span> <span class="tok-nc">CountAgg</span><span class="tok-o">(),</span> <span class="tok-k">new</span> <span class="tok-nc">WindowResultFunction</span><span class="tok-o">())</span>
      <span class="tok-o">.</span><span class="tok-n">keyBy</span><span class="tok-o">(</span><span class="tok-mi">1</span><span class="tok-o">)</span>
      <span class="tok-o">.</span><span class="tok-n">process</span><span class="tok-o">(</span><span class="tok-k">new</span> <span class="tok-nc">TopNHotUrls</span><span class="tok-o">(</span><span class="tok-mi">5</span><span class="tok-o">))</span>
      <span class="tok-o">.</span><span class="tok-n">print</span><span class="tok-o">()</span>

    <span class="tok-n">env</span><span class="tok-o">.</span><span class="tok-n">execute</span><span class="tok-o">(</span><span class="tok-s">&quot;Traffic Analysis Job&quot;</span><span class="tok-o">)</span>
  <span class="tok-o">}</span>

  <span class="tok-k">class</span> <span class="tok-nc">CountAgg</span> <span class="tok-k">extends</span> <span class="tok-nc">AggregateFunction</span><span class="tok-o">[</span><span class="tok-kt">ApacheLogEvent</span>, <span class="tok-kt">Long</span>, <span class="tok-kt">Long</span><span class="tok-o">]</span> <span class="tok-o">{</span>
    <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">createAccumulator</span><span class="tok-o">()</span><span class="tok-k">:</span> <span class="tok-kt">Long</span> <span class="tok-o">=</span> <span class="tok-mi">0L</span>
    <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">add</span><span class="tok-o">(</span><span class="tok-n">apacheLogEvent</span><span class="tok-k">:</span> <span class="tok-kt">ApacheLogEvent</span><span class="tok-o">,</span> <span class="tok-n">acc</span><span class="tok-k">:</span> <span class="tok-kt">Long</span><span class="tok-o">)</span><span class="tok-k">:</span> <span class="tok-kt">Long</span> <span class="tok-o">=</span> <span class="tok-n">acc</span> <span class="tok-o">+</span> <span class="tok-mi">1</span>
    <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">getResult</span><span class="tok-o">(</span><span class="tok-n">acc</span><span class="tok-k">:</span> <span class="tok-kt">Long</span><span class="tok-o">)</span><span class="tok-k">:</span> <span class="tok-kt">Long</span> <span class="tok-o">=</span> <span class="tok-n">acc</span>
    <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">merge</span><span class="tok-o">(</span><span class="tok-n">acc1</span><span class="tok-k">:</span> <span class="tok-kt">Long</span><span class="tok-o">,</span> <span class="tok-n">acc2</span><span class="tok-k">:</span> <span class="tok-kt">Long</span><span class="tok-o">)</span><span class="tok-k">:</span> <span class="tok-kt">Long</span> <span class="tok-o">=</span> <span class="tok-n">acc1</span> <span class="tok-o">+</span> <span class="tok-n">acc2</span>
  <span class="tok-o">}</span>

  <span class="tok-k">class</span> <span class="tok-nc">WindowResultFunction</span> <span class="tok-k">extends</span> <span class="tok-nc">WindowFunction</span><span class="tok-o">[</span><span class="tok-kt">Long</span>, <span class="tok-kt">UrlViewCount</span>, <span class="tok-kt">Tuple</span>, <span class="tok-kt">TimeWindow</span><span class="tok-o">]</span> <span class="tok-o">{</span>
    <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">apply</span><span class="tok-o">(</span><span class="tok-n">key</span><span class="tok-k">:</span> <span class="tok-kt">Tuple</span><span class="tok-o">,</span> <span class="tok-n">window</span><span class="tok-k">:</span> <span class="tok-kt">TimeWindow</span><span class="tok-o">,</span> <span class="tok-n">aggregateResult</span><span class="tok-k">:</span> <span class="tok-kt">Iterable</span><span class="tok-o">[</span><span class="tok-kt">Long</span><span class="tok-o">],</span> <span class="tok-n">collector</span><span class="tok-k">:</span> <span class="tok-kt">Collector</span><span class="tok-o">[</span><span class="tok-kt">UrlViewCount</span><span class="tok-o">])</span> <span class="tok-k">:</span> <span class="tok-kt">Unit</span> <span class="tok-o">=</span> <span class="tok-o">{</span>
      <span class="tok-k">val</span> <span class="tok-n">url</span><span class="tok-k">:</span> <span class="tok-kt">String</span> <span class="tok-o">=</span> <span class="tok-n">key</span><span class="tok-o">.</span><span class="tok-n">asInstanceOf</span><span class="tok-o">[</span><span class="tok-kt">Tuple1</span><span class="tok-o">[</span><span class="tok-kt">String</span><span class="tok-o">]].</span><span class="tok-n">f0</span>
      <span class="tok-k">val</span> <span class="tok-n">count</span> <span class="tok-k">=</span> <span class="tok-n">aggregateResult</span><span class="tok-o">.</span><span class="tok-n">iterator</span><span class="tok-o">.</span><span class="tok-n">next</span>
      <span class="tok-n">collector</span><span class="tok-o">.</span><span class="tok-n">collect</span><span class="tok-o">(</span><span class="tok-nc">UrlViewCount</span><span class="tok-o">(</span><span class="tok-n">url</span><span class="tok-o">,</span> <span class="tok-n">window</span><span class="tok-o">.</span><span class="tok-n">getEnd</span><span class="tok-o">,</span> <span class="tok-n">count</span><span class="tok-o">))</span>
    <span class="tok-o">}</span>
  <span class="tok-o">}</span>

  <span class="tok-k">class</span> <span class="tok-nc">TopNHotUrls</span><span class="tok-o">(</span><span class="tok-n">topsize</span><span class="tok-k">:</span> <span class="tok-kt">Int</span><span class="tok-o">)</span> <span class="tok-k">extends</span> <span class="tok-nc">KeyedProcessFunction</span><span class="tok-o">[</span><span class="tok-kt">Tuple</span>, <span class="tok-kt">UrlViewCount</span>, <span class="tok-kt">String</span><span class="tok-o">]</span> <span class="tok-o">{</span>
    <span class="tok-k">private</span> <span class="tok-k">var</span> <span class="tok-n">urlState</span> <span class="tok-k">:</span> <span class="tok-kt">ListState</span><span class="tok-o">[</span><span class="tok-kt">UrlViewCount</span><span class="tok-o">]</span> <span class="tok-k">=</span> <span class="tok-k">_</span>

    <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">open</span><span class="tok-o">(</span><span class="tok-n">parameters</span><span class="tok-k">:</span> <span class="tok-kt">Configuration</span><span class="tok-o">)</span><span class="tok-k">:</span> <span class="tok-kt">Unit</span> <span class="tok-o">=</span> <span class="tok-o">{</span>
      <span class="tok-k">super</span><span class="tok-o">.</span><span class="tok-n">open</span><span class="tok-o">(</span><span class="tok-n">parameters</span><span class="tok-o">)</span>
      <span class="tok-k">val</span> <span class="tok-n">urlStateDesc</span> <span class="tok-k">=</span> <span class="tok-k">new</span> <span class="tok-nc">ListStateDescriptor</span><span class="tok-o">[</span><span class="tok-kt">UrlViewCount</span><span class="tok-o">](</span><span class="tok-s">&quot;urlState-state&quot;</span><span class="tok-o">,</span> <span class="tok-n">classOf</span><span class="tok-o">[</span><span class="tok-kt">UrlViewCount</span><span class="tok-o">])</span>
      <span class="tok-n">urlState</span> <span class="tok-k">=</span> <span class="tok-n">getRuntimeContext</span><span class="tok-o">.</span><span class="tok-n">getListState</span><span class="tok-o">(</span><span class="tok-n">urlStateDesc</span><span class="tok-o">)</span>
    <span class="tok-o">}</span>

    <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">processElement</span><span class="tok-o">(</span><span class="tok-n">input</span><span class="tok-k">:</span> <span class="tok-kt">UrlViewCount</span><span class="tok-o">,</span> <span class="tok-n">context</span><span class="tok-k">:</span> <span class="tok-kt">KeyedProcessFunction</span><span class="tok-o">[</span><span class="tok-kt">Tuple</span>, <span class="tok-kt">UrlViewCount</span>, <span class="tok-kt">String</span><span class="tok-o">]</span><span class="tok-k">#</span><span class="tok-nc">Context</span><span class="tok-o">,</span> <span class="tok-n">collector</span><span class="tok-k">:</span> <span class="tok-kt">Collector</span><span class="tok-o">[</span><span class="tok-kt">String</span><span class="tok-o">])</span><span class="tok-k">:</span> <span class="tok-kt">Unit</span> <span class="tok-o">=</span> <span class="tok-o">{</span>
      <span class="tok-c1">// 每条数据都保存到状态中</span>
      <span class="tok-n">urlState</span><span class="tok-o">.</span><span class="tok-n">add</span><span class="tok-o">(</span><span class="tok-n">input</span><span class="tok-o">)</span>
      <span class="tok-n">context</span><span class="tok-o">.</span><span class="tok-n">timerService</span><span class="tok-o">.</span><span class="tok-n">registerEventTimeTimer</span><span class="tok-o">(</span><span class="tok-n">input</span><span class="tok-o">.</span><span class="tok-n">windowEnd</span> <span class="tok-o">+</span> <span class="tok-mi">1</span><span class="tok-o">)</span>
    <span class="tok-o">}</span>

    <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">onTimer</span><span class="tok-o">(</span><span class="tok-n">timestamp</span><span class="tok-k">:</span> <span class="tok-kt">Long</span><span class="tok-o">,</span> <span class="tok-n">ctx</span><span class="tok-k">:</span> <span class="tok-kt">KeyedProcessFunction</span><span class="tok-o">[</span><span class="tok-kt">Tuple</span>, <span class="tok-kt">UrlViewCount</span>, <span class="tok-kt">String</span><span class="tok-o">]</span><span class="tok-k">#</span><span class="tok-nc">OnTimerContext</span><span class="tok-o">,</span> <span class="tok-n">out</span><span class="tok-k">:</span> <span class="tok-kt">Collector</span><span class="tok-o">[</span><span class="tok-kt">String</span><span class="tok-o">])</span><span class="tok-k">:</span> <span class="tok-kt">Unit</span> <span class="tok-o">=</span> <span class="tok-o">{</span>
      <span class="tok-c1">// 获取收到的所有URL访问量</span>
      <span class="tok-k">val</span> <span class="tok-n">allUrlViews</span><span class="tok-k">:</span> <span class="tok-kt">ListBuffer</span><span class="tok-o">[</span><span class="tok-kt">UrlViewCount</span><span class="tok-o">]</span> <span class="tok-k">=</span> <span class="tok-nc">ListBuffer</span><span class="tok-o">()</span>
      <span class="tok-k">import</span> <span class="tok-nn">scala.collection.JavaConversions._</span>
      <span class="tok-k">for</span> <span class="tok-o">(</span><span class="tok-n">urlView</span> <span class="tok-k">&lt;-</span> <span class="tok-n">urlState</span><span class="tok-o">.</span><span class="tok-n">get</span><span class="tok-o">)</span> <span class="tok-o">{</span>
        <span class="tok-n">allUrlViews</span> <span class="tok-o">+=</span> <span class="tok-n">urlView</span>
      <span class="tok-o">}</span>
      <span class="tok-c1">// 提前清除状态中的数据，释放空间</span>
      <span class="tok-n">urlState</span><span class="tok-o">.</span><span class="tok-n">clear</span><span class="tok-o">()</span>
      <span class="tok-c1">// 按照访问量从大到小排序</span>
      <span class="tok-k">val</span> <span class="tok-n">sortedUrlViews</span> <span class="tok-k">=</span> <span class="tok-n">allUrlViews</span><span class="tok-o">.</span><span class="tok-n">sortBy</span><span class="tok-o">(</span><span class="tok-k">_</span><span class="tok-o">.</span><span class="tok-n">count</span><span class="tok-o">)(</span><span class="tok-nc">Ordering</span><span class="tok-o">.</span><span class="tok-nc">Long</span><span class="tok-o">.</span><span class="tok-n">reverse</span><span class="tok-o">)</span>
<span class="tok-o">.</span><span class="tok-n">take</span><span class="tok-o">(</span><span class="tok-n">topSize</span><span class="tok-o">)</span>
      <span class="tok-c1">// 将排名信息格式化成 String, 便于打印</span>
      <span class="tok-k">var</span> <span class="tok-n">result</span><span class="tok-k">:</span> <span class="tok-kt">StringBuilder</span> <span class="tok-o">=</span> <span class="tok-k">new</span> <span class="tok-nc">StringBuilder</span>
      <span class="tok-n">result</span><span class="tok-o">.</span><span class="tok-n">append</span><span class="tok-o">(</span><span class="tok-s">&quot;====================================\n&quot;</span><span class="tok-o">)</span>
      <span class="tok-n">result</span><span class="tok-o">.</span><span class="tok-n">append</span><span class="tok-o">(</span><span class="tok-s">&quot;时间: &quot;</span><span class="tok-o">).</span><span class="tok-n">append</span><span class="tok-o">(</span><span class="tok-k">new</span> <span class="tok-nc">Timestamp</span><span class="tok-o">(</span><span class="tok-n">timestamp</span> <span class="tok-o">-</span> <span class="tok-mi">1</span><span class="tok-o">)).</span><span class="tok-n">append</span><span class="tok-o">(</span><span class="tok-s">&quot;\n&quot;</span><span class="tok-o">)</span>

      <span class="tok-k">for</span> <span class="tok-o">(</span><span class="tok-n">i</span> <span class="tok-k">&lt;-</span> <span class="tok-n">sortedUrlViews</span><span class="tok-o">.</span><span class="tok-n">indices</span><span class="tok-o">)</span> <span class="tok-o">{</span>
        <span class="tok-k">val</span> <span class="tok-n">currentUrlView</span><span class="tok-k">:</span> <span class="tok-kt">UrlViewCount</span> <span class="tok-o">=</span> <span class="tok-n">sortedUrlViews</span><span class="tok-o">(</span><span class="tok-n">i</span><span class="tok-o">)</span>
        <span class="tok-c1">// e.g.  No1：  URL=/blog/tags/firefox?flav=rss20  流量=55</span>
        <span class="tok-n">result</span><span class="tok-o">.</span><span class="tok-n">append</span><span class="tok-o">(</span><span class="tok-s">&quot;No&quot;</span><span class="tok-o">).</span><span class="tok-n">append</span><span class="tok-o">(</span><span class="tok-n">i</span><span class="tok-o">+</span><span class="tok-mi">1</span><span class="tok-o">).</span><span class="tok-n">append</span><span class="tok-o">(</span><span class="tok-s">&quot;:&quot;</span><span class="tok-o">)</span>
              <span class="tok-o">.</span><span class="tok-n">append</span><span class="tok-o">(</span><span class="tok-s">&quot;  URL=&quot;</span><span class="tok-o">).</span><span class="tok-n">append</span><span class="tok-o">(</span><span class="tok-n">currentUrlView</span><span class="tok-o">.</span><span class="tok-n">url</span><span class="tok-o">)</span>
              <span class="tok-o">.</span><span class="tok-n">append</span><span class="tok-o">(</span><span class="tok-s">&quot;  流量=&quot;</span><span class="tok-o">).</span><span class="tok-n">append</span><span class="tok-o">(</span><span class="tok-n">currentUrlView</span><span class="tok-o">.</span><span class="tok-n">count</span><span class="tok-o">).</span><span class="tok-n">append</span><span class="tok-o">(</span><span class="tok-s">&quot;\n&quot;</span><span class="tok-o">)</span>
      <span class="tok-o">}</span>
      <span class="tok-n">result</span><span class="tok-o">.</span><span class="tok-n">append</span><span class="tok-o">(</span><span class="tok-s">&quot;====================================\n\n&quot;</span><span class="tok-o">)</span>
      <span class="tok-c1">// 控制输出频率，模拟实时滚动结果</span>
      <span class="tok-nc">Thread</span><span class="tok-o">.</span><span class="tok-n">sleep</span><span class="tok-o">(</span><span class="tok-mi">1000</span><span class="tok-o">)</span>
      <span class="tok-n">out</span><span class="tok-o">.</span><span class="tok-n">collect</span><span class="tok-o">(</span><span class="tok-n">result</span><span class="tok-o">.</span><span class="tok-n">toString</span><span class="tok-o">)</span>
    <span class="tok-o">}</span>
  <span class="tok-o">}</span>
<span class="tok-o">}</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_uv统计的布隆过滤器实现">12.4. Uv统计的布隆过滤器实现</h3>
<div class="paragraph">
<p>完整代码如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">package</span> <span class="tok-nn">com.atguigu</span>

<span class="tok-k">import</span> <span class="tok-nn">com.atguigu.UserBehavior.UserAction</span>
<span class="tok-k">import</span> <span class="tok-nn">org.apache.flink.streaming.api.TimeCharacteristic</span>
<span class="tok-k">import</span> <span class="tok-nn">org.apache.flink.streaming.api.scala._</span>
<span class="tok-k">import</span> <span class="tok-nn">org.apache.flink.streaming.api.scala.function.ProcessWindowFunction</span>
<span class="tok-k">import</span> <span class="tok-nn">org.apache.flink.streaming.api.windowing.time.Time</span>
<span class="tok-k">import</span> <span class="tok-nn">org.apache.flink.streaming.api.windowing.triggers.</span><span class="tok-o">{</span><span class="tok-nc">Trigger</span><span class="tok-o">,</span> <span class="tok-nc">TriggerResult</span><span class="tok-o">}</span>
<span class="tok-k">import</span> <span class="tok-nn">org.apache.flink.streaming.api.windowing.triggers.Trigger.TriggerContext</span>
<span class="tok-k">import</span> <span class="tok-nn">org.apache.flink.streaming.api.windowing.windows.TimeWindow</span>
<span class="tok-k">import</span> <span class="tok-nn">org.apache.flink.util.Collector</span>
<span class="tok-k">import</span> <span class="tok-nn">redis.clients.jedis.Jedis</span>

<span class="tok-k">object</span> <span class="tok-nc">UvWithBloomFilter</span> <span class="tok-o">{</span>
  <span class="tok-k">def</span> <span class="tok-n">main</span><span class="tok-o">(</span><span class="tok-n">args</span><span class="tok-k">:</span> <span class="tok-kt">Array</span><span class="tok-o">[</span><span class="tok-kt">String</span><span class="tok-o">])</span><span class="tok-k">:</span> <span class="tok-kt">Unit</span> <span class="tok-o">=</span> <span class="tok-o">{</span>
    <span class="tok-k">val</span> <span class="tok-n">env</span> <span class="tok-k">=</span> <span class="tok-nc">StreamExecutionEnvironment</span><span class="tok-o">.</span><span class="tok-n">getExecutionEnvironment</span>
    <span class="tok-n">env</span><span class="tok-o">.</span><span class="tok-n">setParallelism</span><span class="tok-o">(</span><span class="tok-mi">1</span><span class="tok-o">)</span>
    <span class="tok-n">env</span><span class="tok-o">.</span><span class="tok-n">setStreamTimeCharacteristic</span><span class="tok-o">(</span><span class="tok-nc">TimeCharacteristic</span><span class="tok-o">.</span><span class="tok-nc">EventTime</span><span class="tok-o">)</span>
    <span class="tok-k">val</span> <span class="tok-n">stream</span> <span class="tok-k">=</span> <span class="tok-n">env</span>
      <span class="tok-o">.</span><span class="tok-n">readTextFile</span><span class="tok-o">(</span><span class="tok-s">&quot;/Users/yuanzuo/Desktop/Flink0715Tutorial/src/main/resources/UserBehavior.csv&quot;</span><span class="tok-o">)</span>
      <span class="tok-o">.</span><span class="tok-n">map</span><span class="tok-o">(</span><span class="tok-n">line</span> <span class="tok-k">=&gt;</span> <span class="tok-o">{</span>
        <span class="tok-k">val</span> <span class="tok-n">arr</span> <span class="tok-k">=</span> <span class="tok-n">line</span><span class="tok-o">.</span><span class="tok-n">split</span><span class="tok-o">(</span><span class="tok-s">&quot;,&quot;</span><span class="tok-o">)</span>
        <span class="tok-nc">UserAction</span><span class="tok-o">(</span><span class="tok-n">arr</span><span class="tok-o">(</span><span class="tok-mi">0</span><span class="tok-o">),</span> <span class="tok-n">arr</span><span class="tok-o">(</span><span class="tok-mi">1</span><span class="tok-o">),</span> <span class="tok-n">arr</span><span class="tok-o">(</span><span class="tok-mi">2</span><span class="tok-o">),</span> <span class="tok-n">arr</span><span class="tok-o">(</span><span class="tok-mi">3</span><span class="tok-o">),</span> <span class="tok-n">arr</span><span class="tok-o">(</span><span class="tok-mi">4</span><span class="tok-o">).</span><span class="tok-n">toLong</span> <span class="tok-o">*</span> <span class="tok-mi">1000</span><span class="tok-o">)</span>
      <span class="tok-o">})</span>
      <span class="tok-o">.</span><span class="tok-n">assignAscendingTimestamps</span><span class="tok-o">(</span><span class="tok-k">_</span><span class="tok-o">.</span><span class="tok-n">ts</span><span class="tok-o">)</span>
      <span class="tok-o">.</span><span class="tok-n">filter</span><span class="tok-o">(</span><span class="tok-k">_</span><span class="tok-o">.</span><span class="tok-n">behavior</span> <span class="tok-o">==</span> <span class="tok-s">&quot;pv&quot;</span><span class="tok-o">)</span>
      <span class="tok-o">.</span><span class="tok-n">map</span><span class="tok-o">(</span><span class="tok-n">r</span> <span class="tok-k">=&gt;</span> <span class="tok-o">(</span><span class="tok-s">&quot;dummyKey&quot;</span><span class="tok-o">,</span> <span class="tok-n">r</span><span class="tok-o">.</span><span class="tok-n">userId</span><span class="tok-o">))</span>
      <span class="tok-o">.</span><span class="tok-n">keyBy</span><span class="tok-o">(</span><span class="tok-k">_</span><span class="tok-o">.</span><span class="tok-n">_1</span><span class="tok-o">)</span>
      <span class="tok-o">.</span><span class="tok-n">timeWindow</span><span class="tok-o">(</span><span class="tok-nc">Time</span><span class="tok-o">.</span><span class="tok-n">minutes</span><span class="tok-o">(</span><span class="tok-mi">60</span><span class="tok-o">),</span> <span class="tok-nc">Time</span><span class="tok-o">.</span><span class="tok-n">minutes</span><span class="tok-o">(</span><span class="tok-mi">5</span><span class="tok-o">))</span>
      <span class="tok-o">.</span><span class="tok-n">trigger</span><span class="tok-o">(</span><span class="tok-k">new</span> <span class="tok-nc">MyTrigger123</span><span class="tok-o">)</span>
      <span class="tok-o">.</span><span class="tok-n">process</span><span class="tok-o">(</span><span class="tok-k">new</span> <span class="tok-nc">MyProcess</span><span class="tok-o">)</span>

    <span class="tok-n">stream</span><span class="tok-o">.</span><span class="tok-n">print</span><span class="tok-o">()</span>
    <span class="tok-n">env</span><span class="tok-o">.</span><span class="tok-n">execute</span><span class="tok-o">()</span>
  <span class="tok-o">}</span>

  <span class="tok-k">class</span> <span class="tok-nc">MyProcess</span> <span class="tok-k">extends</span> <span class="tok-nc">ProcessWindowFunction</span><span class="tok-o">[(</span><span class="tok-kt">String</span>, <span class="tok-kt">String</span><span class="tok-o">)</span>, <span class="tok-o">(</span><span class="tok-kt">Long</span>, <span class="tok-kt">Long</span><span class="tok-o">)</span>, <span class="tok-kt">String</span>, <span class="tok-kt">TimeWindow</span><span class="tok-o">]</span> <span class="tok-o">{</span>
    <span class="tok-k">lazy</span> <span class="tok-k">val</span> <span class="tok-n">jedis</span> <span class="tok-k">=</span> <span class="tok-k">new</span> <span class="tok-nc">Jedis</span><span class="tok-o">(</span><span class="tok-s">&quot;localhost&quot;</span><span class="tok-o">,</span> <span class="tok-mi">6379</span><span class="tok-o">)</span>
    <span class="tok-k">lazy</span> <span class="tok-k">val</span> <span class="tok-n">bloom</span> <span class="tok-k">=</span> <span class="tok-k">new</span> <span class="tok-nc">Bloom</span><span class="tok-o">(</span><span class="tok-mi">1</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-mi">29</span><span class="tok-o">)</span>

    <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">process</span><span class="tok-o">(</span><span class="tok-n">key</span><span class="tok-k">:</span> <span class="tok-kt">String</span><span class="tok-o">,</span>
                         <span class="tok-n">context</span><span class="tok-k">:</span> <span class="tok-kt">Context</span><span class="tok-o">,</span>
                         <span class="tok-n">vals</span><span class="tok-k">:</span> <span class="tok-kt">Iterable</span><span class="tok-o">[(</span><span class="tok-kt">String</span>, <span class="tok-kt">String</span><span class="tok-o">)],</span>
                         <span class="tok-n">out</span><span class="tok-k">:</span> <span class="tok-kt">Collector</span><span class="tok-o">[(</span><span class="tok-kt">Long</span>, <span class="tok-kt">Long</span><span class="tok-o">)])</span><span class="tok-k">:</span> <span class="tok-kt">Unit</span> <span class="tok-o">=</span> <span class="tok-o">{</span>
      <span class="tok-k">val</span> <span class="tok-n">storeKey</span> <span class="tok-k">=</span> <span class="tok-n">context</span><span class="tok-o">.</span><span class="tok-n">window</span><span class="tok-o">.</span><span class="tok-n">getEnd</span><span class="tok-o">.</span><span class="tok-n">toString</span>
      <span class="tok-k">var</span> <span class="tok-n">count</span> <span class="tok-k">=</span> <span class="tok-mi">0L</span>

      <span class="tok-k">if</span> <span class="tok-o">(</span><span class="tok-n">jedis</span><span class="tok-o">.</span><span class="tok-n">hget</span><span class="tok-o">(</span><span class="tok-s">&quot;UvCountHashTable&quot;</span><span class="tok-o">,</span> <span class="tok-n">storeKey</span><span class="tok-o">)</span> <span class="tok-o">!=</span> <span class="tok-kc">null</span><span class="tok-o">)</span> <span class="tok-o">{</span>
        <span class="tok-n">count</span> <span class="tok-k">=</span> <span class="tok-n">jedis</span><span class="tok-o">.</span><span class="tok-n">hget</span><span class="tok-o">(</span><span class="tok-s">&quot;UvCountHashTable&quot;</span><span class="tok-o">,</span> <span class="tok-n">storeKey</span><span class="tok-o">).</span><span class="tok-n">toLong</span>
      <span class="tok-o">}</span>

      <span class="tok-k">val</span> <span class="tok-n">userId</span> <span class="tok-k">=</span> <span class="tok-n">vals</span><span class="tok-o">.</span><span class="tok-n">last</span><span class="tok-o">.</span><span class="tok-n">_2</span>
      <span class="tok-k">val</span> <span class="tok-n">offset</span> <span class="tok-k">=</span> <span class="tok-n">bloom</span><span class="tok-o">.</span><span class="tok-n">hash</span><span class="tok-o">(</span><span class="tok-n">userId</span><span class="tok-o">,</span> <span class="tok-mi">61</span><span class="tok-o">)</span>

      <span class="tok-k">val</span> <span class="tok-n">isExist</span> <span class="tok-k">=</span> <span class="tok-n">jedis</span><span class="tok-o">.</span><span class="tok-n">getbit</span><span class="tok-o">(</span><span class="tok-n">storeKey</span><span class="tok-o">,</span> <span class="tok-n">offset</span><span class="tok-o">)</span>
      <span class="tok-k">if</span> <span class="tok-o">(!</span><span class="tok-n">isExist</span><span class="tok-o">)</span> <span class="tok-o">{</span>
        <span class="tok-n">jedis</span><span class="tok-o">.</span><span class="tok-n">setbit</span><span class="tok-o">(</span><span class="tok-n">storeKey</span><span class="tok-o">,</span> <span class="tok-n">offset</span><span class="tok-o">,</span> <span class="tok-kc">true</span><span class="tok-o">)</span>
        <span class="tok-n">jedis</span><span class="tok-o">.</span><span class="tok-n">hset</span><span class="tok-o">(</span><span class="tok-s">&quot;UvCountHashTable&quot;</span><span class="tok-o">,</span> <span class="tok-n">storeKey</span><span class="tok-o">,</span> <span class="tok-o">(</span><span class="tok-n">count</span> <span class="tok-o">+</span> <span class="tok-mi">1</span><span class="tok-o">).</span><span class="tok-n">toString</span><span class="tok-o">)</span>
      <span class="tok-o">}</span>



<span class="tok-c1">//      out.collect((count, storeKey.toLong))</span>

    <span class="tok-o">}</span>
  <span class="tok-o">}</span>

  <span class="tok-k">class</span> <span class="tok-nc">MyTrigger123</span> <span class="tok-k">extends</span> <span class="tok-nc">Trigger</span><span class="tok-o">[(</span><span class="tok-kt">String</span>, <span class="tok-kt">String</span><span class="tok-o">)</span>, <span class="tok-kt">TimeWindow</span><span class="tok-o">]</span> <span class="tok-o">{</span>
    <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">onEventTime</span><span class="tok-o">(</span><span class="tok-n">time</span><span class="tok-k">:</span> <span class="tok-kt">Long</span><span class="tok-o">,</span>
                             <span class="tok-n">window</span><span class="tok-k">:</span> <span class="tok-kt">TimeWindow</span><span class="tok-o">,</span>
                             <span class="tok-n">ctx</span><span class="tok-k">:</span> <span class="tok-kt">TriggerContext</span><span class="tok-o">)</span><span class="tok-k">:</span> <span class="tok-kt">TriggerResult</span> <span class="tok-o">=</span> <span class="tok-o">{</span>
      <span class="tok-k">if</span> <span class="tok-o">(</span><span class="tok-n">ctx</span><span class="tok-o">.</span><span class="tok-n">getCurrentWatermark</span> <span class="tok-o">&gt;=</span> <span class="tok-n">window</span><span class="tok-o">.</span><span class="tok-n">getEnd</span><span class="tok-o">)</span> <span class="tok-o">{</span>
        <span class="tok-k">val</span> <span class="tok-n">jedis</span> <span class="tok-k">=</span> <span class="tok-k">new</span> <span class="tok-nc">Jedis</span><span class="tok-o">(</span><span class="tok-s">&quot;localhost&quot;</span><span class="tok-o">,</span> <span class="tok-mi">6379</span><span class="tok-o">)</span>
        <span class="tok-k">val</span> <span class="tok-n">key</span> <span class="tok-k">=</span> <span class="tok-n">window</span><span class="tok-o">.</span><span class="tok-n">getEnd</span><span class="tok-o">.</span><span class="tok-n">toString</span>
        <span class="tok-nc">TriggerResult</span><span class="tok-o">.</span><span class="tok-nc">FIRE_AND_PURGE</span>
        <span class="tok-n">println</span><span class="tok-o">(</span><span class="tok-n">key</span><span class="tok-o">,</span> <span class="tok-n">jedis</span><span class="tok-o">.</span><span class="tok-n">hget</span><span class="tok-o">(</span><span class="tok-s">&quot;UvCountHashTable&quot;</span><span class="tok-o">,</span> <span class="tok-n">key</span><span class="tok-o">))</span>
      <span class="tok-o">}</span>
      <span class="tok-nc">TriggerResult</span><span class="tok-o">.</span><span class="tok-nc">CONTINUE</span>
    <span class="tok-o">}</span>
    <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">onProcessingTime</span><span class="tok-o">(</span><span class="tok-n">time</span><span class="tok-k">:</span> <span class="tok-kt">Long</span><span class="tok-o">,</span>
                                  <span class="tok-n">window</span><span class="tok-k">:</span> <span class="tok-kt">TimeWindow</span><span class="tok-o">,</span>
                                  <span class="tok-n">ctx</span><span class="tok-k">:</span> <span class="tok-kt">TriggerContext</span><span class="tok-o">)</span><span class="tok-k">:</span> <span class="tok-kt">TriggerResult</span> <span class="tok-o">=</span> <span class="tok-o">{</span>
      <span class="tok-nc">TriggerResult</span><span class="tok-o">.</span><span class="tok-nc">CONTINUE</span>
    <span class="tok-o">}</span>
    <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">clear</span><span class="tok-o">(</span><span class="tok-n">window</span><span class="tok-k">:</span> <span class="tok-kt">TimeWindow</span><span class="tok-o">,</span> <span class="tok-n">ctx</span><span class="tok-k">:</span> <span class="tok-kt">Trigger.TriggerContext</span><span class="tok-o">)</span><span class="tok-k">:</span> <span class="tok-kt">Unit</span> <span class="tok-o">=</span> <span class="tok-o">{}</span>
    <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">onElement</span><span class="tok-o">(</span><span class="tok-n">element</span><span class="tok-k">:</span> <span class="tok-o">(</span><span class="tok-kt">String</span><span class="tok-o">,</span> <span class="tok-kt">String</span><span class="tok-o">),</span>
                           <span class="tok-n">timestamp</span><span class="tok-k">:</span> <span class="tok-kt">Long</span><span class="tok-o">,</span>
                           <span class="tok-n">window</span><span class="tok-k">:</span> <span class="tok-kt">TimeWindow</span><span class="tok-o">,</span>
                           <span class="tok-n">ctx</span><span class="tok-k">:</span> <span class="tok-kt">TriggerContext</span><span class="tok-o">)</span><span class="tok-k">:</span> <span class="tok-kt">TriggerResult</span> <span class="tok-o">=</span> <span class="tok-o">{</span>
      <span class="tok-nc">TriggerResult</span><span class="tok-o">.</span><span class="tok-nc">FIRE_AND_PURGE</span>
    <span class="tok-o">}</span>
  <span class="tok-o">}</span>

  <span class="tok-k">class</span> <span class="tok-nc">Bloom</span><span class="tok-o">(</span><span class="tok-n">size</span><span class="tok-k">:</span> <span class="tok-kt">Long</span><span class="tok-o">)</span> <span class="tok-k">extends</span> <span class="tok-nc">Serializable</span> <span class="tok-o">{</span>
    <span class="tok-k">private</span> <span class="tok-k">val</span> <span class="tok-n">cap</span> <span class="tok-k">=</span> <span class="tok-n">size</span>

    <span class="tok-k">def</span> <span class="tok-n">hash</span><span class="tok-o">(</span><span class="tok-n">value</span><span class="tok-k">:</span> <span class="tok-kt">String</span><span class="tok-o">,</span> <span class="tok-n">seed</span><span class="tok-k">:</span> <span class="tok-kt">Int</span><span class="tok-o">)</span><span class="tok-k">:</span> <span class="tok-kt">Long</span> <span class="tok-o">=</span> <span class="tok-o">{</span>
      <span class="tok-k">var</span> <span class="tok-n">result</span> <span class="tok-k">=</span> <span class="tok-mi">0</span>
      <span class="tok-k">for</span> <span class="tok-o">(</span><span class="tok-n">i</span> <span class="tok-k">&lt;-</span> <span class="tok-mi">0</span> <span class="tok-n">until</span> <span class="tok-n">value</span><span class="tok-o">.</span><span class="tok-n">length</span><span class="tok-o">)</span> <span class="tok-o">{</span>
        <span class="tok-n">result</span> <span class="tok-k">=</span> <span class="tok-n">result</span> <span class="tok-o">*</span> <span class="tok-n">seed</span> <span class="tok-o">+</span> <span class="tok-n">value</span><span class="tok-o">.</span><span class="tok-n">charAt</span><span class="tok-o">(</span><span class="tok-n">i</span><span class="tok-o">)</span>
      <span class="tok-o">}</span>
      <span class="tok-o">(</span><span class="tok-n">cap</span> <span class="tok-o">-</span> <span class="tok-mi">1</span><span class="tok-o">)</span> <span class="tok-o">&amp;</span> <span class="tok-n">result</span>
    <span class="tok-o">}</span>
  <span class="tok-o">}</span>
<span class="tok-o">}</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_app分渠道数据统计">12.5. APP分渠道数据统计</h3>
<div class="paragraph">
<p>完整代码如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">package</span> <span class="tok-nn">com.atguigu</span>

<span class="tok-k">import</span> <span class="tok-nn">java.util.</span><span class="tok-o">{</span><span class="tok-nc">Calendar</span><span class="tok-o">,</span> <span class="tok-nc">UUID</span><span class="tok-o">}</span>

<span class="tok-k">import</span> <span class="tok-nn">org.apache.flink.streaming.api.TimeCharacteristic</span>
<span class="tok-k">import</span> <span class="tok-nn">org.apache.flink.streaming.api.functions.source.RichParallelSourceFunction</span>
<span class="tok-k">import</span> <span class="tok-nn">org.apache.flink.streaming.api.functions.source.SourceFunction.SourceContext</span>
<span class="tok-k">import</span> <span class="tok-nn">org.apache.flink.streaming.api.scala._</span>
<span class="tok-k">import</span> <span class="tok-nn">org.apache.flink.streaming.api.scala.function.ProcessWindowFunction</span>
<span class="tok-k">import</span> <span class="tok-nn">org.apache.flink.streaming.api.windowing.time.Time</span>
<span class="tok-k">import</span> <span class="tok-nn">org.apache.flink.streaming.api.windowing.windows.TimeWindow</span>
<span class="tok-k">import</span> <span class="tok-nn">org.apache.flink.util.Collector</span>

<span class="tok-k">import</span> <span class="tok-nn">scala.util.Random</span>

<span class="tok-k">object</span> <span class="tok-nc">AppMarketingByChannel</span> <span class="tok-o">{</span>
  <span class="tok-k">case</span> <span class="tok-k">class</span> <span class="tok-nc">MarketingUserBehavior</span><span class="tok-o">(</span><span class="tok-n">userId</span><span class="tok-k">:</span> <span class="tok-kt">String</span><span class="tok-o">,</span>
                                   <span class="tok-n">behavior</span><span class="tok-k">:</span> <span class="tok-kt">String</span><span class="tok-o">,</span>
                                   <span class="tok-n">channel</span><span class="tok-k">:</span> <span class="tok-kt">String</span><span class="tok-o">,</span>
                                   <span class="tok-n">ts</span><span class="tok-k">:</span> <span class="tok-kt">Long</span><span class="tok-o">)</span>

  <span class="tok-k">class</span> <span class="tok-nc">SimulatedEventSource</span> <span class="tok-k">extends</span> <span class="tok-nc">RichParallelSourceFunction</span><span class="tok-o">[</span><span class="tok-kt">MarketingUserBehavior</span><span class="tok-o">]</span> <span class="tok-o">{</span>
    <span class="tok-k">var</span> <span class="tok-n">running</span> <span class="tok-k">=</span> <span class="tok-kc">true</span>

    <span class="tok-k">val</span> <span class="tok-n">channelSet</span> <span class="tok-k">=</span> <span class="tok-nc">Seq</span><span class="tok-o">(</span><span class="tok-s">&quot;AppStore&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;XiaomiStore&quot;</span><span class="tok-o">)</span>
    <span class="tok-k">val</span> <span class="tok-n">behaviorTypes</span> <span class="tok-k">=</span> <span class="tok-nc">Seq</span><span class="tok-o">(</span><span class="tok-s">&quot;BROWSE&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;CLICK&quot;</span><span class="tok-o">)</span>
    <span class="tok-k">val</span> <span class="tok-n">rand</span> <span class="tok-k">=</span> <span class="tok-k">new</span> <span class="tok-nc">Random</span>

    <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">run</span><span class="tok-o">(</span><span class="tok-n">ctx</span><span class="tok-k">:</span> <span class="tok-kt">SourceContext</span><span class="tok-o">[</span><span class="tok-kt">MarketingUserBehavior</span><span class="tok-o">])</span><span class="tok-k">:</span> <span class="tok-kt">Unit</span> <span class="tok-o">=</span> <span class="tok-o">{</span>
      <span class="tok-k">while</span> <span class="tok-o">(</span><span class="tok-n">running</span><span class="tok-o">)</span> <span class="tok-o">{</span>
        <span class="tok-k">val</span> <span class="tok-n">userId</span> <span class="tok-k">=</span> <span class="tok-nc">UUID</span><span class="tok-o">.</span><span class="tok-n">randomUUID</span><span class="tok-o">().</span><span class="tok-n">toString</span>
        <span class="tok-k">val</span> <span class="tok-n">behaviorType</span> <span class="tok-k">=</span> <span class="tok-n">behaviorTypes</span><span class="tok-o">(</span><span class="tok-n">rand</span><span class="tok-o">.</span><span class="tok-n">nextInt</span><span class="tok-o">(</span><span class="tok-n">behaviorTypes</span><span class="tok-o">.</span><span class="tok-n">size</span><span class="tok-o">))</span>
        <span class="tok-k">val</span> <span class="tok-n">channel</span> <span class="tok-k">=</span> <span class="tok-n">channelSet</span><span class="tok-o">(</span><span class="tok-n">rand</span><span class="tok-o">.</span><span class="tok-n">nextInt</span><span class="tok-o">(</span><span class="tok-n">channelSet</span><span class="tok-o">.</span><span class="tok-n">size</span><span class="tok-o">))</span>
        <span class="tok-k">val</span> <span class="tok-n">ts</span> <span class="tok-k">=</span> <span class="tok-nc">Calendar</span><span class="tok-o">.</span><span class="tok-n">getInstance</span><span class="tok-o">().</span><span class="tok-n">getTimeInMillis</span>

        <span class="tok-n">ctx</span><span class="tok-o">.</span><span class="tok-n">collect</span><span class="tok-o">(</span><span class="tok-nc">MarketingUserBehavior</span><span class="tok-o">(</span><span class="tok-n">userId</span><span class="tok-o">,</span> <span class="tok-n">behaviorType</span><span class="tok-o">,</span> <span class="tok-n">channel</span><span class="tok-o">,</span> <span class="tok-n">ts</span><span class="tok-o">))</span>

        <span class="tok-nc">Thread</span><span class="tok-o">.</span><span class="tok-n">sleep</span><span class="tok-o">(</span><span class="tok-mi">10</span><span class="tok-o">)</span>
      <span class="tok-o">}</span>
    <span class="tok-o">}</span>

    <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">cancel</span><span class="tok-o">()</span><span class="tok-k">:</span> <span class="tok-kt">Unit</span> <span class="tok-o">=</span> <span class="tok-n">running</span> <span class="tok-k">=</span> <span class="tok-kc">false</span>
  <span class="tok-o">}</span>

  <span class="tok-k">def</span> <span class="tok-n">main</span><span class="tok-o">(</span><span class="tok-n">args</span><span class="tok-k">:</span> <span class="tok-kt">Array</span><span class="tok-o">[</span><span class="tok-kt">String</span><span class="tok-o">])</span><span class="tok-k">:</span> <span class="tok-kt">Unit</span> <span class="tok-o">=</span> <span class="tok-o">{</span>
    <span class="tok-k">val</span> <span class="tok-n">env</span> <span class="tok-k">=</span> <span class="tok-nc">StreamExecutionEnvironment</span><span class="tok-o">.</span><span class="tok-n">getExecutionEnvironment</span>
    <span class="tok-n">env</span><span class="tok-o">.</span><span class="tok-n">setParallelism</span><span class="tok-o">(</span><span class="tok-mi">1</span><span class="tok-o">)</span>
    <span class="tok-n">env</span><span class="tok-o">.</span><span class="tok-n">setStreamTimeCharacteristic</span><span class="tok-o">(</span><span class="tok-nc">TimeCharacteristic</span><span class="tok-o">.</span><span class="tok-nc">EventTime</span><span class="tok-o">)</span>
    <span class="tok-k">val</span> <span class="tok-n">stream</span> <span class="tok-k">=</span> <span class="tok-n">env</span>
      <span class="tok-o">.</span><span class="tok-n">addSource</span><span class="tok-o">(</span><span class="tok-k">new</span> <span class="tok-nc">SimulatedEventSource</span><span class="tok-o">)</span>
      <span class="tok-o">.</span><span class="tok-n">assignAscendingTimestamps</span><span class="tok-o">(</span><span class="tok-k">_</span><span class="tok-o">.</span><span class="tok-n">ts</span><span class="tok-o">)</span>
      <span class="tok-o">.</span><span class="tok-n">filter</span><span class="tok-o">(</span><span class="tok-k">_</span><span class="tok-o">.</span><span class="tok-n">behavior</span> <span class="tok-o">!=</span> <span class="tok-s">&quot;UNINSTALL&quot;</span><span class="tok-o">)</span>
      <span class="tok-o">.</span><span class="tok-n">map</span><span class="tok-o">(</span><span class="tok-n">r</span> <span class="tok-k">=&gt;</span> <span class="tok-o">{</span>
        <span class="tok-o">((</span><span class="tok-n">r</span><span class="tok-o">.</span><span class="tok-n">channel</span><span class="tok-o">,</span> <span class="tok-n">r</span><span class="tok-o">.</span><span class="tok-n">behavior</span><span class="tok-o">),</span> <span class="tok-mi">1L</span><span class="tok-o">)</span>
      <span class="tok-o">})</span>
      <span class="tok-o">.</span><span class="tok-n">keyBy</span><span class="tok-o">(</span><span class="tok-k">_</span><span class="tok-o">.</span><span class="tok-n">_1</span><span class="tok-o">)</span>
      <span class="tok-o">.</span><span class="tok-n">timeWindow</span><span class="tok-o">(</span><span class="tok-nc">Time</span><span class="tok-o">.</span><span class="tok-n">seconds</span><span class="tok-o">(</span><span class="tok-mi">5</span><span class="tok-o">),</span> <span class="tok-nc">Time</span><span class="tok-o">.</span><span class="tok-n">seconds</span><span class="tok-o">(</span><span class="tok-mi">1</span><span class="tok-o">))</span>
      <span class="tok-o">.</span><span class="tok-n">process</span><span class="tok-o">(</span><span class="tok-k">new</span> <span class="tok-nc">MarketingCountByChannel</span><span class="tok-o">)</span>
    <span class="tok-n">stream</span><span class="tok-o">.</span><span class="tok-n">print</span><span class="tok-o">()</span>
    <span class="tok-n">env</span><span class="tok-o">.</span><span class="tok-n">execute</span><span class="tok-o">()</span>
  <span class="tok-o">}</span>

  <span class="tok-k">class</span> <span class="tok-nc">MarketingCountByChannel</span> <span class="tok-k">extends</span> <span class="tok-nc">ProcessWindowFunction</span><span class="tok-o">[((</span><span class="tok-kt">String</span>, <span class="tok-kt">String</span><span class="tok-o">)</span>, <span class="tok-kt">Long</span><span class="tok-o">)</span>,<span class="tok-o">(</span><span class="tok-kt">String</span>, <span class="tok-kt">Long</span>, <span class="tok-kt">Long</span><span class="tok-o">)</span>, <span class="tok-o">(</span><span class="tok-kt">String</span>, <span class="tok-kt">String</span><span class="tok-o">)</span>, <span class="tok-kt">TimeWindow</span><span class="tok-o">]</span> <span class="tok-o">{</span>
    <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">process</span><span class="tok-o">(</span><span class="tok-n">key</span><span class="tok-k">:</span>  <span class="tok-o">(</span><span class="tok-kt">String</span><span class="tok-o">,</span><span class="tok-kt">String</span><span class="tok-o">),</span>
                         <span class="tok-n">context</span><span class="tok-k">:</span> <span class="tok-kt">Context</span><span class="tok-o">,</span>
                         <span class="tok-n">elements</span><span class="tok-k">:</span> <span class="tok-kt">Iterable</span><span class="tok-o">[((</span><span class="tok-kt">String</span>, <span class="tok-kt">String</span><span class="tok-o">)</span>, <span class="tok-kt">Long</span><span class="tok-o">)],</span>
                         <span class="tok-n">out</span><span class="tok-k">:</span> <span class="tok-kt">Collector</span><span class="tok-o">[(</span><span class="tok-kt">String</span>, <span class="tok-kt">Long</span>, <span class="tok-kt">Long</span><span class="tok-o">)])</span><span class="tok-k">:</span> <span class="tok-kt">Unit</span> <span class="tok-o">=</span> <span class="tok-o">{</span>
<span class="tok-c1">//      val t = (&quot;a&quot;,)</span>

      <span class="tok-n">out</span><span class="tok-o">.</span><span class="tok-n">collect</span><span class="tok-o">((</span><span class="tok-n">key</span><span class="tok-o">.</span><span class="tok-n">_1</span><span class="tok-o">,</span> <span class="tok-n">elements</span><span class="tok-o">.</span><span class="tok-n">size</span><span class="tok-o">,</span> <span class="tok-n">context</span><span class="tok-o">.</span><span class="tok-n">window</span><span class="tok-o">.</span><span class="tok-n">getEnd</span><span class="tok-o">))</span>

    <span class="tok-o">}</span>
  <span class="tok-o">}</span>
<span class="tok-o">}</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_app不分渠道数据统计">12.6. APP不分渠道数据统计</h3>
<div class="paragraph">
<p>完整代码如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">package</span> <span class="tok-nn">com.atguigu</span>

<span class="tok-k">import</span> <span class="tok-nn">com.atguigu.AppMarketingByChannel.SimulatedEventSource</span>
<span class="tok-k">import</span> <span class="tok-nn">org.apache.flink.streaming.api.TimeCharacteristic</span>
<span class="tok-k">import</span> <span class="tok-nn">org.apache.flink.streaming.api.scala._</span>
<span class="tok-k">import</span> <span class="tok-nn">org.apache.flink.streaming.api.scala.function.ProcessWindowFunction</span>
<span class="tok-k">import</span> <span class="tok-nn">org.apache.flink.streaming.api.windowing.time.Time</span>
<span class="tok-k">import</span> <span class="tok-nn">org.apache.flink.streaming.api.windowing.windows.TimeWindow</span>
<span class="tok-k">import</span> <span class="tok-nn">org.apache.flink.util.Collector</span>

<span class="tok-k">object</span> <span class="tok-nc">AppMarketingStatistics</span> <span class="tok-o">{</span>
  <span class="tok-k">def</span> <span class="tok-n">main</span><span class="tok-o">(</span><span class="tok-n">args</span><span class="tok-k">:</span> <span class="tok-kt">Array</span><span class="tok-o">[</span><span class="tok-kt">String</span><span class="tok-o">])</span><span class="tok-k">:</span> <span class="tok-kt">Unit</span> <span class="tok-o">=</span> <span class="tok-o">{</span>
    <span class="tok-k">val</span> <span class="tok-n">env</span> <span class="tok-k">=</span> <span class="tok-nc">StreamExecutionEnvironment</span><span class="tok-o">.</span><span class="tok-n">getExecutionEnvironment</span>
    <span class="tok-n">env</span><span class="tok-o">.</span><span class="tok-n">setParallelism</span><span class="tok-o">(</span><span class="tok-mi">1</span><span class="tok-o">)</span>
    <span class="tok-n">env</span><span class="tok-o">.</span><span class="tok-n">setStreamTimeCharacteristic</span><span class="tok-o">(</span><span class="tok-nc">TimeCharacteristic</span><span class="tok-o">.</span><span class="tok-nc">EventTime</span><span class="tok-o">)</span>
    <span class="tok-k">val</span> <span class="tok-n">stream</span> <span class="tok-k">=</span> <span class="tok-n">env</span>
      <span class="tok-o">.</span><span class="tok-n">addSource</span><span class="tok-o">(</span><span class="tok-k">new</span> <span class="tok-nc">SimulatedEventSource</span><span class="tok-o">)</span>
      <span class="tok-o">.</span><span class="tok-n">assignAscendingTimestamps</span><span class="tok-o">(</span><span class="tok-k">_</span><span class="tok-o">.</span><span class="tok-n">ts</span><span class="tok-o">)</span>
      <span class="tok-o">.</span><span class="tok-n">filter</span><span class="tok-o">(</span><span class="tok-k">_</span><span class="tok-o">.</span><span class="tok-n">behavior</span> <span class="tok-o">!=</span> <span class="tok-s">&quot;UNINSTALL&quot;</span><span class="tok-o">)</span>
      <span class="tok-o">.</span><span class="tok-n">map</span><span class="tok-o">(</span><span class="tok-n">r</span> <span class="tok-k">=&gt;</span> <span class="tok-o">{</span>
        <span class="tok-o">(</span><span class="tok-s">&quot;dummyKey&quot;</span><span class="tok-o">,</span> <span class="tok-mi">1L</span><span class="tok-o">)</span>
      <span class="tok-o">})</span>
      <span class="tok-o">.</span><span class="tok-n">keyBy</span><span class="tok-o">(</span><span class="tok-k">_</span><span class="tok-o">.</span><span class="tok-n">_1</span><span class="tok-o">)</span>
      <span class="tok-o">.</span><span class="tok-n">timeWindow</span><span class="tok-o">(</span><span class="tok-nc">Time</span><span class="tok-o">.</span><span class="tok-n">seconds</span><span class="tok-o">(</span><span class="tok-mi">5</span><span class="tok-o">),</span> <span class="tok-nc">Time</span><span class="tok-o">.</span><span class="tok-n">seconds</span><span class="tok-o">(</span><span class="tok-mi">1</span><span class="tok-o">))</span>
      <span class="tok-o">.</span><span class="tok-n">process</span><span class="tok-o">(</span><span class="tok-k">new</span> <span class="tok-nc">MarketingCountTotal</span><span class="tok-o">)</span>
    <span class="tok-n">stream</span><span class="tok-o">.</span><span class="tok-n">print</span><span class="tok-o">()</span>
    <span class="tok-n">env</span><span class="tok-o">.</span><span class="tok-n">execute</span><span class="tok-o">()</span>
  <span class="tok-o">}</span>

  <span class="tok-k">class</span> <span class="tok-nc">MarketingCountTotal</span> <span class="tok-k">extends</span> <span class="tok-nc">ProcessWindowFunction</span><span class="tok-o">[(</span><span class="tok-kt">String</span>, <span class="tok-kt">Long</span><span class="tok-o">)</span>,
  <span class="tok-o">(</span><span class="tok-kt">String</span>, <span class="tok-kt">Long</span>, <span class="tok-kt">Long</span><span class="tok-o">)</span>, <span class="tok-kt">String</span>, <span class="tok-kt">TimeWindow</span><span class="tok-o">]</span> <span class="tok-o">{</span>
    <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">process</span><span class="tok-o">(</span><span class="tok-n">key</span><span class="tok-k">:</span> <span class="tok-kt">String</span><span class="tok-o">,</span>
                         <span class="tok-n">context</span><span class="tok-k">:</span> <span class="tok-kt">Context</span><span class="tok-o">,</span>
                         <span class="tok-n">elements</span><span class="tok-k">:</span> <span class="tok-kt">Iterable</span><span class="tok-o">[(</span><span class="tok-kt">String</span>, <span class="tok-kt">Long</span><span class="tok-o">)],</span>
                         <span class="tok-n">out</span><span class="tok-k">:</span> <span class="tok-kt">Collector</span><span class="tok-o">[(</span><span class="tok-kt">String</span>, <span class="tok-kt">Long</span>, <span class="tok-kt">Long</span><span class="tok-o">)])</span><span class="tok-k">:</span> <span class="tok-kt">Unit</span> <span class="tok-o">=</span> <span class="tok-o">{</span>
      <span class="tok-n">out</span><span class="tok-o">.</span><span class="tok-n">collect</span><span class="tok-o">((</span><span class="tok-n">key</span><span class="tok-o">,</span> <span class="tok-n">elements</span><span class="tok-o">.</span><span class="tok-n">size</span><span class="tok-o">,</span> <span class="tok-n">context</span><span class="tok-o">.</span><span class="tok-n">window</span><span class="tok-o">.</span><span class="tok-n">getEnd</span><span class="tok-o">))</span>
    <span class="tok-o">}</span>
  <span class="tok-o">}</span>
<span class="tok-o">}</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_恶意登陆课堂实现">12.7. 恶意登陆课堂实现</h3>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">package</span> <span class="tok-nn">com.atguigu</span>

<span class="tok-k">import</span> <span class="tok-nn">com.atguigu.FlinkCepExample.LoginEvent</span>
<span class="tok-k">import</span> <span class="tok-nn">org.apache.flink.api.common.state.</span><span class="tok-o">{</span><span class="tok-nc">ListStateDescriptor</span><span class="tok-o">,</span> <span class="tok-nc">ValueStateDescriptor</span><span class="tok-o">}</span>
<span class="tok-k">import</span> <span class="tok-nn">org.apache.flink.api.scala.typeutils.Types</span>
<span class="tok-k">import</span> <span class="tok-nn">org.apache.flink.cep.scala.pattern.Pattern</span>
<span class="tok-k">import</span> <span class="tok-nn">org.apache.flink.streaming.api.TimeCharacteristic</span>
<span class="tok-k">import</span> <span class="tok-nn">org.apache.flink.streaming.api.functions.KeyedProcessFunction</span>
<span class="tok-k">import</span> <span class="tok-nn">org.apache.flink.streaming.api.scala._</span>
<span class="tok-k">import</span> <span class="tok-nn">org.apache.flink.util.Collector</span>

<span class="tok-k">import</span> <span class="tok-nn">scala.collection.mutable.ListBuffer</span>

<span class="tok-k">object</span> <span class="tok-nc">LoginFailWithoutCEP</span> <span class="tok-o">{</span>
  <span class="tok-k">def</span> <span class="tok-n">main</span><span class="tok-o">(</span><span class="tok-n">args</span><span class="tok-k">:</span> <span class="tok-kt">Array</span><span class="tok-o">[</span><span class="tok-kt">String</span><span class="tok-o">])</span><span class="tok-k">:</span> <span class="tok-kt">Unit</span> <span class="tok-o">=</span> <span class="tok-o">{</span>
    <span class="tok-k">val</span> <span class="tok-n">env</span> <span class="tok-k">=</span> <span class="tok-nc">StreamExecutionEnvironment</span><span class="tok-o">.</span><span class="tok-n">getExecutionEnvironment</span>
    <span class="tok-n">env</span><span class="tok-o">.</span><span class="tok-n">setStreamTimeCharacteristic</span><span class="tok-o">(</span><span class="tok-nc">TimeCharacteristic</span><span class="tok-o">.</span><span class="tok-nc">EventTime</span><span class="tok-o">)</span>
    <span class="tok-n">env</span><span class="tok-o">.</span><span class="tok-n">setParallelism</span><span class="tok-o">(</span><span class="tok-mi">1</span><span class="tok-o">)</span>

    <span class="tok-k">val</span> <span class="tok-n">stream</span> <span class="tok-k">=</span> <span class="tok-n">env</span>
      <span class="tok-o">.</span><span class="tok-n">fromElements</span><span class="tok-o">(</span>
        <span class="tok-nc">LoginEvent</span><span class="tok-o">(</span><span class="tok-s">&quot;1&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;0.0.0.0&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;fail&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;1&quot;</span><span class="tok-o">),</span>
        <span class="tok-nc">LoginEvent</span><span class="tok-o">(</span><span class="tok-s">&quot;1&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;0.0.0.0&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;success&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;2&quot;</span><span class="tok-o">),</span>
        <span class="tok-nc">LoginEvent</span><span class="tok-o">(</span><span class="tok-s">&quot;1&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;0.0.0.0&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;fail&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;3&quot;</span><span class="tok-o">),</span>
        <span class="tok-nc">LoginEvent</span><span class="tok-o">(</span><span class="tok-s">&quot;1&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;0.0.0.0&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;fail&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;4&quot;</span><span class="tok-o">)</span>
      <span class="tok-o">)</span>
      <span class="tok-o">.</span><span class="tok-n">assignAscendingTimestamps</span><span class="tok-o">(</span><span class="tok-k">_</span><span class="tok-o">.</span><span class="tok-n">ts</span><span class="tok-o">.</span><span class="tok-n">toLong</span> <span class="tok-o">*</span> <span class="tok-mi">1000</span><span class="tok-o">)</span>
      <span class="tok-o">.</span><span class="tok-n">keyBy</span><span class="tok-o">(</span><span class="tok-k">_</span><span class="tok-o">.</span><span class="tok-n">userId</span><span class="tok-o">)</span>
      <span class="tok-o">.</span><span class="tok-n">process</span><span class="tok-o">(</span><span class="tok-k">new</span> <span class="tok-nc">MatchFunction</span><span class="tok-o">)</span>

    <span class="tok-n">stream</span><span class="tok-o">.</span><span class="tok-n">print</span><span class="tok-o">()</span>
    <span class="tok-n">env</span><span class="tok-o">.</span><span class="tok-n">execute</span><span class="tok-o">()</span>
  <span class="tok-o">}</span>

  <span class="tok-k">class</span> <span class="tok-nc">MatchFunction</span> <span class="tok-k">extends</span> <span class="tok-nc">KeyedProcessFunction</span><span class="tok-o">[</span><span class="tok-kt">String</span>, <span class="tok-kt">LoginEvent</span>, <span class="tok-kt">String</span><span class="tok-o">]</span> <span class="tok-o">{</span>

    <span class="tok-k">lazy</span> <span class="tok-k">val</span> <span class="tok-n">loginState</span> <span class="tok-k">=</span> <span class="tok-n">getRuntimeContext</span><span class="tok-o">.</span><span class="tok-n">getListState</span><span class="tok-o">(</span>
      <span class="tok-k">new</span> <span class="tok-nc">ListStateDescriptor</span><span class="tok-o">[</span><span class="tok-kt">LoginEvent</span><span class="tok-o">](</span><span class="tok-s">&quot;login-fail&quot;</span><span class="tok-o">,</span> <span class="tok-nc">Types</span><span class="tok-o">.</span><span class="tok-n">of</span><span class="tok-o">[</span><span class="tok-kt">LoginEvent</span><span class="tok-o">])</span>
    <span class="tok-o">)</span>

    <span class="tok-k">lazy</span> <span class="tok-k">val</span> <span class="tok-n">timestamp</span> <span class="tok-k">=</span> <span class="tok-n">getRuntimeContext</span><span class="tok-o">.</span><span class="tok-n">getState</span><span class="tok-o">(</span>
      <span class="tok-k">new</span> <span class="tok-nc">ValueStateDescriptor</span><span class="tok-o">[</span><span class="tok-kt">Long</span><span class="tok-o">](</span><span class="tok-s">&quot;ts&quot;</span><span class="tok-o">,</span> <span class="tok-nc">Types</span><span class="tok-o">.</span><span class="tok-n">of</span><span class="tok-o">[</span><span class="tok-kt">Long</span><span class="tok-o">])</span>
    <span class="tok-o">)</span>

    <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">processElement</span><span class="tok-o">(</span><span class="tok-n">value</span><span class="tok-k">:</span> <span class="tok-kt">LoginEvent</span><span class="tok-o">,</span>
                                <span class="tok-n">ctx</span><span class="tok-k">:</span> <span class="tok-kt">KeyedProcessFunction</span><span class="tok-o">[</span><span class="tok-kt">String</span>, <span class="tok-kt">LoginEvent</span>, <span class="tok-kt">String</span><span class="tok-o">]</span><span class="tok-k">#</span><span class="tok-nc">Context</span><span class="tok-o">,</span>
                                <span class="tok-n">out</span><span class="tok-k">:</span> <span class="tok-kt">Collector</span><span class="tok-o">[</span><span class="tok-kt">String</span><span class="tok-o">])</span><span class="tok-k">:</span> <span class="tok-kt">Unit</span> <span class="tok-o">=</span> <span class="tok-o">{</span>
      <span class="tok-k">if</span> <span class="tok-o">(</span><span class="tok-n">value</span><span class="tok-o">.</span><span class="tok-n">loginStatus</span> <span class="tok-o">==</span> <span class="tok-s">&quot;fail&quot;</span><span class="tok-o">)</span> <span class="tok-o">{</span>
        <span class="tok-n">loginState</span><span class="tok-o">.</span><span class="tok-n">add</span><span class="tok-o">(</span><span class="tok-n">value</span><span class="tok-o">)</span>
        <span class="tok-n">timestamp</span><span class="tok-o">.</span><span class="tok-n">update</span><span class="tok-o">(</span><span class="tok-n">value</span><span class="tok-o">.</span><span class="tok-n">ts</span><span class="tok-o">.</span><span class="tok-n">toLong</span> <span class="tok-o">*</span> <span class="tok-mi">1000</span> <span class="tok-o">+</span> <span class="tok-mi">5000L</span><span class="tok-o">)</span>
        <span class="tok-n">ctx</span><span class="tok-o">.</span><span class="tok-n">timerService</span><span class="tok-o">().</span><span class="tok-n">registerEventTimeTimer</span><span class="tok-o">(</span><span class="tok-n">value</span><span class="tok-o">.</span><span class="tok-n">ts</span><span class="tok-o">.</span><span class="tok-n">toLong</span> <span class="tok-o">*</span> <span class="tok-mi">1000</span> <span class="tok-o">+</span> <span class="tok-mi">5000L</span><span class="tok-o">)</span>
      <span class="tok-o">}</span>

      <span class="tok-k">if</span> <span class="tok-o">(</span><span class="tok-n">value</span><span class="tok-o">.</span><span class="tok-n">loginStatus</span> <span class="tok-o">==</span> <span class="tok-s">&quot;success&quot;</span><span class="tok-o">)</span> <span class="tok-o">{</span>
        <span class="tok-n">loginState</span><span class="tok-o">.</span><span class="tok-n">clear</span><span class="tok-o">()</span>
        <span class="tok-n">ctx</span><span class="tok-o">.</span><span class="tok-n">timerService</span><span class="tok-o">().</span><span class="tok-n">deleteEventTimeTimer</span><span class="tok-o">(</span><span class="tok-n">timestamp</span><span class="tok-o">.</span><span class="tok-n">value</span><span class="tok-o">())</span>
      <span class="tok-o">}</span>

    <span class="tok-o">}</span>

    <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">onTimer</span><span class="tok-o">(</span><span class="tok-n">ts</span><span class="tok-k">:</span> <span class="tok-kt">Long</span><span class="tok-o">,</span>
                         <span class="tok-n">ctx</span><span class="tok-k">:</span> <span class="tok-kt">KeyedProcessFunction</span><span class="tok-o">[</span><span class="tok-kt">String</span>, <span class="tok-kt">LoginEvent</span>, <span class="tok-kt">String</span><span class="tok-o">]</span><span class="tok-k">#</span><span class="tok-nc">OnTimerContext</span><span class="tok-o">,</span>
                         <span class="tok-n">out</span><span class="tok-k">:</span> <span class="tok-kt">Collector</span><span class="tok-o">[</span><span class="tok-kt">String</span><span class="tok-o">])</span><span class="tok-k">:</span> <span class="tok-kt">Unit</span> <span class="tok-o">=</span> <span class="tok-o">{</span>
      <span class="tok-k">val</span> <span class="tok-n">allLogins</span> <span class="tok-k">=</span> <span class="tok-nc">ListBuffer</span><span class="tok-o">[</span><span class="tok-kt">LoginEvent</span><span class="tok-o">]()</span>
      <span class="tok-k">import</span> <span class="tok-nn">scala.collection.JavaConversions._</span>
      <span class="tok-k">for</span> <span class="tok-o">(</span><span class="tok-n">login</span> <span class="tok-k">&lt;-</span> <span class="tok-n">loginState</span><span class="tok-o">.</span><span class="tok-n">get</span><span class="tok-o">)</span> <span class="tok-o">{</span>
        <span class="tok-n">allLogins</span> <span class="tok-o">+=</span> <span class="tok-n">login</span>
      <span class="tok-o">}</span>
      <span class="tok-n">loginState</span><span class="tok-o">.</span><span class="tok-n">clear</span><span class="tok-o">()</span>

      <span class="tok-k">if</span> <span class="tok-o">(</span><span class="tok-n">allLogins</span><span class="tok-o">.</span><span class="tok-n">length</span> <span class="tok-o">&gt;</span> <span class="tok-mi">1</span><span class="tok-o">)</span> <span class="tok-o">{</span>
        <span class="tok-n">out</span><span class="tok-o">.</span><span class="tok-n">collect</span><span class="tok-o">(</span><span class="tok-s">&quot;5s以内连续两次登陆失败&quot;</span><span class="tok-o">)</span>
      <span class="tok-o">}</span>
    <span class="tok-o">}</span>
  <span class="tok-o">}</span>
<span class="tok-o">}</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_恶意登录监控">12.8. 恶意登录监控</h3>
<div class="ulist">
<ul>
<li>
<p>基本需求</p>
<div class="ulist">
<ul>
<li>
<p>用户在短时间内频繁登录失败，有程序恶意攻击的可能</p>
</li>
<li>
<p>同一用户(可以是不同IP)在2秒内连续两次登录失败，需要报警</p>
</li>
</ul>
</div>
</li>
<li>
<p>解决思路</p>
<div class="ulist">
<ul>
<li>
<p>将用户的登录失败行为存入ListState，设定定时器10秒后触发，查看ListState中有几次失败登录</p>
</li>
<li>
<p>更加精确的检测，可以使用CEP库实现事件流的模式匹配</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_模块创建和数据准备_2">12.8.1. 模块创建和数据准备</h4>
<div class="paragraph">
<p>继续在UserBehaviorAnalysis下新建一个maven module作为子项目，命名为LoginFailDetect。在这个子模块中，我们将会用到flink的CEP库来实现事件流的模式匹配，所以需要在pom文件中引入CEP的相关依赖：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="xml"><span></span><span class="tok-nt">&lt;dependency&gt;</span>
    <span class="tok-nt">&lt;groupId&gt;</span>org.apache.flink<span class="tok-nt">&lt;/groupId&gt;</span>
    <span class="tok-nt">&lt;artifactId&gt;</span>flink-cep_${scala.binary.version}<span class="tok-nt">&lt;/artifactId&gt;</span>
    <span class="tok-nt">&lt;version&gt;</span>${flink.version}<span class="tok-nt">&lt;/version&gt;</span>
<span class="tok-nt">&lt;/dependency&gt;</span>
<span class="tok-nt">&lt;dependency&gt;</span>
    <span class="tok-nt">&lt;groupId&gt;</span>org.apache.flink<span class="tok-nt">&lt;/groupId&gt;</span>
    <span class="tok-nt">&lt;artifactId&gt;</span>flink-cep-scala_${scala.binary.version}<span class="tok-nt">&lt;/artifactId&gt;</span>
    <span class="tok-nt">&lt;version&gt;</span>${flink.version}<span class="tok-nt">&lt;/version&gt;</span>
<span class="tok-nt">&lt;/dependency&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>同样，在src/main/目录下，将默认源文件目录java改名为scala。</p>
</div>
</div>
<div class="sect3">
<h4 id="_代码实现_2">12.8.2. 代码实现</h4>
<div class="paragraph">
<p>对于网站而言，用户登录并不是频繁的业务操作。如果一个用户短时间内频繁登录失败，就有可能是出现了程序的恶意攻击，比如密码暴力破解。因此我们考虑，应该对用户的登录失败动作进行统计，具体来说，如果同一用户（可以是不同IP）在2秒之内连续两次登录失败，就认为存在恶意登录的风险，输出相关的信息进行报警提示。这是电商网站、也是几乎所有网站风控的基本一环。</p>
</div>
<div class="sect4">
<h5 id="_状态编程">状态编程</h5>
<div class="paragraph">
<p>由于同样引入了时间，我们可以想到，最简单的方法其实与之前的热门统计类似，只需要按照用户ID分流，然后遇到登录失败的事件时将其保存在ListState中，然后设置一个定时器，2秒后触发。定时器触发时检查状态中的登录失败事件个数，如果大于等于2，那么就输出报警信息。</p>
</div>
<div class="paragraph">
<p>在src/main/scala下创建LoginFail.scala文件，新建一个单例对象。定义样例类LoginEvent，这是输入的登录事件流。由于没有现成的登录数据，我们用几条自定义的示例数据来做演示。</p>
</div>
<div class="paragraph">
<p>代码如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">case</span> <span class="tok-k">class</span> <span class="tok-nc">LoginEvent</span><span class="tok-o">(</span><span class="tok-n">userId</span><span class="tok-k">:</span> <span class="tok-kt">Long</span><span class="tok-o">,</span> <span class="tok-n">ip</span><span class="tok-k">:</span> <span class="tok-kt">String</span><span class="tok-o">,</span> <span class="tok-n">eventType</span><span class="tok-k">:</span> <span class="tok-kt">String</span><span class="tok-o">,</span> <span class="tok-n">eventTime</span><span class="tok-k">:</span> <span class="tok-kt">Long</span><span class="tok-o">)</span>

<span class="tok-k">object</span> <span class="tok-nc">LoginFail</span> <span class="tok-o">{</span>

  <span class="tok-k">def</span> <span class="tok-n">main</span><span class="tok-o">(</span><span class="tok-n">args</span><span class="tok-k">:</span> <span class="tok-kt">Array</span><span class="tok-o">[</span><span class="tok-kt">String</span><span class="tok-o">])</span><span class="tok-k">:</span> <span class="tok-kt">Unit</span> <span class="tok-o">=</span> <span class="tok-o">{</span>

    <span class="tok-k">val</span> <span class="tok-n">env</span> <span class="tok-k">=</span> <span class="tok-nc">StreamExecutionEnvironment</span><span class="tok-o">.</span><span class="tok-n">getExecutionEnvironment</span>
    <span class="tok-n">env</span><span class="tok-o">.</span><span class="tok-n">setStreamTimeCharacteristic</span><span class="tok-o">(</span><span class="tok-nc">TimeCharacteristic</span><span class="tok-o">.</span><span class="tok-nc">EventTime</span><span class="tok-o">)</span>
    <span class="tok-n">env</span><span class="tok-o">.</span><span class="tok-n">setParallelism</span><span class="tok-o">(</span><span class="tok-mi">1</span><span class="tok-o">)</span>

    <span class="tok-k">val</span> <span class="tok-n">loginEventStream</span> <span class="tok-k">=</span> <span class="tok-n">env</span>
      <span class="tok-o">.</span><span class="tok-n">fromCollection</span><span class="tok-o">(</span><span class="tok-nc">List</span><span class="tok-o">(</span>
        <span class="tok-nc">LoginEvent</span><span class="tok-o">(</span><span class="tok-mi">1</span><span class="tok-o">,</span> <span class="tok-s">&quot;192.168.0.1&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;fail&quot;</span><span class="tok-o">,</span> <span class="tok-mi">1558430842</span><span class="tok-o">),</span>
        <span class="tok-nc">LoginEvent</span><span class="tok-o">(</span><span class="tok-mi">1</span><span class="tok-o">,</span> <span class="tok-s">&quot;192.168.0.2&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;fail&quot;</span><span class="tok-o">,</span> <span class="tok-mi">1558430843</span><span class="tok-o">),</span>
        <span class="tok-nc">LoginEvent</span><span class="tok-o">(</span><span class="tok-mi">1</span><span class="tok-o">,</span> <span class="tok-s">&quot;192.168.0.3&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;fail&quot;</span><span class="tok-o">,</span> <span class="tok-mi">1558430844</span><span class="tok-o">),</span>
        <span class="tok-nc">LoginEvent</span><span class="tok-o">(</span><span class="tok-mi">2</span><span class="tok-o">,</span> <span class="tok-s">&quot;192.168.10.10&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;success&quot;</span><span class="tok-o">,</span> <span class="tok-mi">1558430845</span><span class="tok-o">)</span>
      <span class="tok-o">))</span>
      <span class="tok-o">.</span><span class="tok-n">assignAscendingTimestamps</span><span class="tok-o">(</span><span class="tok-k">_</span><span class="tok-o">.</span><span class="tok-n">eventTime</span> <span class="tok-o">*</span> <span class="tok-mi">1000</span><span class="tok-o">)</span>
      <span class="tok-o">.</span><span class="tok-n">keyBy</span><span class="tok-o">(</span><span class="tok-k">_</span><span class="tok-o">.</span><span class="tok-n">userId</span><span class="tok-o">)</span>
      <span class="tok-o">.</span><span class="tok-n">process</span><span class="tok-o">(</span><span class="tok-k">new</span> <span class="tok-nc">MatchFunction</span><span class="tok-o">())</span>
      <span class="tok-o">.</span><span class="tok-n">print</span><span class="tok-o">()</span>

    <span class="tok-n">env</span><span class="tok-o">.</span><span class="tok-n">execute</span><span class="tok-o">(</span><span class="tok-s">&quot;Login Fail Detect Job&quot;</span><span class="tok-o">)</span>
  <span class="tok-o">}</span>

  <span class="tok-k">class</span> <span class="tok-nc">MatchFunction</span> <span class="tok-k">extends</span> <span class="tok-nc">KeyedProcessFunction</span><span class="tok-o">[</span><span class="tok-kt">Long</span>, <span class="tok-kt">LoginEvent</span>, <span class="tok-kt">LoginEvent</span><span class="tok-o">]</span> <span class="tok-o">{</span>

    <span class="tok-c1">// 定义状态变量</span>
    <span class="tok-k">lazy</span> <span class="tok-k">val</span> <span class="tok-n">loginState</span><span class="tok-k">:</span> <span class="tok-kt">ListState</span><span class="tok-o">[</span><span class="tok-kt">LoginEvent</span><span class="tok-o">]</span> <span class="tok-k">=</span> <span class="tok-n">getRuntimeContext</span><span class="tok-o">.</span><span class="tok-n">getListState</span><span class="tok-o">(</span><span class="tok-k">new</span> <span class="tok-nc">ListStateDescriptor</span><span class="tok-o">[</span><span class="tok-kt">LoginEvent</span><span class="tok-o">](</span><span class="tok-s">&quot;saved login&quot;</span><span class="tok-o">,</span> <span class="tok-n">classOf</span><span class="tok-o">[</span><span class="tok-kt">LoginEvent</span><span class="tok-o">]))</span>

    <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">processElement</span><span class="tok-o">(</span><span class="tok-n">login</span><span class="tok-k">:</span> <span class="tok-kt">LoginEvent</span><span class="tok-o">,</span>
                                <span class="tok-n">context</span><span class="tok-k">:</span> <span class="tok-kt">KeyedProcessFunction</span><span class="tok-o">[</span><span class="tok-kt">Long</span>, <span class="tok-kt">LoginEvent</span>, <span class="tok-kt">LoginEvent</span><span class="tok-o">]</span><span class="tok-k">#</span><span class="tok-nc">Context</span><span class="tok-o">,</span>
                                <span class="tok-n">out</span><span class="tok-k">:</span> <span class="tok-kt">Collector</span><span class="tok-o">[</span><span class="tok-kt">LoginEvent</span><span class="tok-o">])</span><span class="tok-k">:</span> <span class="tok-kt">Unit</span> <span class="tok-o">=</span> <span class="tok-o">{</span>

      <span class="tok-k">if</span> <span class="tok-o">(</span><span class="tok-n">login</span><span class="tok-o">.</span><span class="tok-n">eventType</span> <span class="tok-o">==</span> <span class="tok-s">&quot;fail&quot;</span><span class="tok-o">)</span> <span class="tok-o">{</span>
        <span class="tok-n">loginState</span><span class="tok-o">.</span><span class="tok-n">add</span><span class="tok-o">(</span><span class="tok-n">login</span><span class="tok-o">)</span>
      <span class="tok-o">}</span>
      <span class="tok-c1">// 注册定时器，触发事件设定为2秒后</span>
      <span class="tok-n">context</span><span class="tok-o">.</span><span class="tok-n">timerService</span><span class="tok-o">.</span><span class="tok-n">registerEventTimeTimer</span><span class="tok-o">(</span><span class="tok-n">login</span><span class="tok-o">.</span><span class="tok-n">eventTime</span> <span class="tok-o">+</span> <span class="tok-mi">2</span> <span class="tok-o">*</span> <span class="tok-mi">1000</span><span class="tok-o">)</span>
    <span class="tok-o">}</span>

    <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">onTimer</span><span class="tok-o">(</span><span class="tok-n">timestamp</span><span class="tok-k">:</span> <span class="tok-kt">Long</span><span class="tok-o">,</span>
                         <span class="tok-n">ctx</span><span class="tok-k">:</span> <span class="tok-kt">KeyedProcessFunction</span><span class="tok-o">[</span><span class="tok-kt">Long</span>, <span class="tok-kt">LoginEvent</span>, <span class="tok-kt">LoginEvent</span><span class="tok-o">]</span><span class="tok-k">#</span><span class="tok-nc">OnTimerContext</span><span class="tok-o">,</span>
                         <span class="tok-n">out</span><span class="tok-k">:</span> <span class="tok-kt">Collector</span><span class="tok-o">[</span><span class="tok-kt">LoginEvent</span><span class="tok-o">])</span><span class="tok-k">:</span> <span class="tok-kt">Unit</span> <span class="tok-o">=</span> <span class="tok-o">{</span>

      <span class="tok-k">val</span> <span class="tok-n">allLogins</span><span class="tok-k">:</span> <span class="tok-kt">ListBuffer</span><span class="tok-o">[</span><span class="tok-kt">LoginEvent</span><span class="tok-o">]</span> <span class="tok-k">=</span> <span class="tok-nc">ListBuffer</span><span class="tok-o">()</span>
      <span class="tok-k">import</span> <span class="tok-nn">scala.collection.JavaConversions._</span>
      <span class="tok-k">for</span> <span class="tok-o">(</span><span class="tok-n">login</span> <span class="tok-k">&lt;-</span> <span class="tok-n">loginState</span><span class="tok-o">.</span><span class="tok-n">get</span><span class="tok-o">)</span> <span class="tok-o">{</span>
        <span class="tok-n">allLogins</span> <span class="tok-o">+=</span> <span class="tok-n">login</span>
      <span class="tok-o">}</span>
      <span class="tok-n">loginState</span><span class="tok-o">.</span><span class="tok-n">clear</span><span class="tok-o">()</span>

      <span class="tok-k">if</span> <span class="tok-o">(</span><span class="tok-n">allLogins</span><span class="tok-o">.</span><span class="tok-n">length</span> <span class="tok-o">&gt;</span> <span class="tok-mi">1</span><span class="tok-o">)</span> <span class="tok-o">{</span>
        <span class="tok-n">out</span><span class="tok-o">.</span><span class="tok-n">collect</span><span class="tok-o">(</span><span class="tok-n">allLogins</span><span class="tok-o">.</span><span class="tok-n">head</span><span class="tok-o">)</span>
      <span class="tok-o">}</span>
    <span class="tok-o">}</span>
  <span class="tok-o">}</span>
<span class="tok-o">}</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_cep编程">CEP编程</h5>
<div class="paragraph">
<p>上一节的代码实现中我们可以看到，直接把每次登录失败的数据存起来、设置定时器一段时间后再读取，这种做法尽管简单，但和我们开始的需求还是略有差异的。这种做法只能隔2秒之后去判断一下这期间是否有多次失败登录，而不是在一次登录失败之后、再一次登录失败时就立刻报警。这个需求如果严格实现起来，相当于要判断任意紧邻的事件，是否符合某种模式。这听起来就很复杂了，那有什么方式可以方便地实现呢？</p>
</div>
<div class="paragraph">
<p>很幸运，flink为我们提供了CEP（Complex Event Processing，复杂事件处理）库，用于在流中筛选符合某种复杂模式的事件。接下来我们就基于CEP来完成这个模块的实现。</p>
</div>
<div class="paragraph">
<p>在src/main/scala下继续创建LoginFailWithCep.scala文件，新建一个单例对象。样例类LoginEvent由于在LoginFail.scala已经定义，我们在同一个模块中就不需要再定义了。</p>
</div>
<div class="paragraph">
<p>代码如下：</p>
</div>
<div class="listingblock">
<div class="title">LoginFailDetect/src/main/scala/LoginFailWithCep.scala</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">object</span> <span class="tok-nc">LoginFailWithCep</span> <span class="tok-o">{</span>

  <span class="tok-k">def</span> <span class="tok-n">main</span><span class="tok-o">(</span><span class="tok-n">args</span><span class="tok-k">:</span> <span class="tok-kt">Array</span><span class="tok-o">[</span><span class="tok-kt">String</span><span class="tok-o">])</span><span class="tok-k">:</span> <span class="tok-kt">Unit</span> <span class="tok-o">=</span> <span class="tok-o">{</span>

    <span class="tok-k">val</span> <span class="tok-n">env</span> <span class="tok-k">=</span> <span class="tok-nc">StreamExecutionEnvironment</span><span class="tok-o">.</span><span class="tok-n">getExecutionEnvironment</span>
    <span class="tok-n">env</span><span class="tok-o">.</span><span class="tok-n">setStreamTimeCharacteristic</span><span class="tok-o">(</span><span class="tok-nc">TimeCharacteristic</span><span class="tok-o">.</span><span class="tok-nc">EventTime</span><span class="tok-o">)</span>
    <span class="tok-n">env</span><span class="tok-o">.</span><span class="tok-n">setParallelism</span><span class="tok-o">(</span><span class="tok-mi">1</span><span class="tok-o">)</span>

    <span class="tok-k">val</span> <span class="tok-n">loginEventStream</span> <span class="tok-k">=</span> <span class="tok-n">env</span><span class="tok-o">.</span><span class="tok-n">fromCollection</span><span class="tok-o">(</span><span class="tok-nc">List</span><span class="tok-o">(</span>
      <span class="tok-nc">LoginEvent</span><span class="tok-o">(</span><span class="tok-mi">1</span><span class="tok-o">,</span> <span class="tok-s">&quot;192.168.0.1&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;fail&quot;</span><span class="tok-o">,</span> <span class="tok-mi">1558430842</span><span class="tok-o">),</span>
      <span class="tok-nc">LoginEvent</span><span class="tok-o">(</span><span class="tok-mi">1</span><span class="tok-o">,</span> <span class="tok-s">&quot;192.168.0.2&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;fail&quot;</span><span class="tok-o">,</span> <span class="tok-mi">1558430843</span><span class="tok-o">),</span>
      <span class="tok-nc">LoginEvent</span><span class="tok-o">(</span><span class="tok-mi">1</span><span class="tok-o">,</span> <span class="tok-s">&quot;192.168.0.3&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;fail&quot;</span><span class="tok-o">,</span> <span class="tok-mi">1558430844</span><span class="tok-o">),</span>
      <span class="tok-nc">LoginEvent</span><span class="tok-o">(</span><span class="tok-mi">2</span><span class="tok-o">,</span> <span class="tok-s">&quot;192.168.10.10&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;success&quot;</span><span class="tok-o">,</span> <span class="tok-mi">1558430845</span><span class="tok-o">)</span>
    <span class="tok-o">)).</span><span class="tok-n">assignAscendingTimestamps</span><span class="tok-o">(</span><span class="tok-k">_</span><span class="tok-o">.</span><span class="tok-n">eventTime</span> <span class="tok-o">*</span> <span class="tok-mi">1000</span><span class="tok-o">)</span>


    <span class="tok-c1">// 定义匹配模式</span>
    <span class="tok-k">val</span> <span class="tok-n">loginFailPattern</span> <span class="tok-k">=</span> <span class="tok-nc">Pattern</span>
      <span class="tok-o">.</span><span class="tok-n">begin</span><span class="tok-o">[</span><span class="tok-kt">LoginEvent</span><span class="tok-o">](</span><span class="tok-s">&quot;begin&quot;</span><span class="tok-o">)</span>
      <span class="tok-o">.</span><span class="tok-n">where</span><span class="tok-o">(</span><span class="tok-k">_</span><span class="tok-o">.</span><span class="tok-n">eventType</span> <span class="tok-o">==</span> <span class="tok-s">&quot;fail&quot;</span><span class="tok-o">)</span>
      <span class="tok-o">.</span><span class="tok-n">next</span><span class="tok-o">(</span><span class="tok-s">&quot;next&quot;</span><span class="tok-o">)</span>
      <span class="tok-o">.</span><span class="tok-n">where</span><span class="tok-o">(</span><span class="tok-k">_</span><span class="tok-o">.</span><span class="tok-n">eventType</span> <span class="tok-o">==</span> <span class="tok-s">&quot;fail&quot;</span><span class="tok-o">)</span>
      <span class="tok-o">.</span><span class="tok-n">within</span><span class="tok-o">(</span><span class="tok-nc">Time</span><span class="tok-o">.</span><span class="tok-n">seconds</span><span class="tok-o">(</span><span class="tok-mi">2</span><span class="tok-o">))</span>


    <span class="tok-c1">// 在数据流中匹配出定义好的模式</span>
    <span class="tok-k">val</span> <span class="tok-n">patternStream</span> <span class="tok-k">=</span> <span class="tok-nc">CEP</span><span class="tok-o">.</span><span class="tok-n">pattern</span><span class="tok-o">(</span><span class="tok-n">loginEventStream</span><span class="tok-o">.</span><span class="tok-n">keyBy</span><span class="tok-o">(</span><span class="tok-k">_</span><span class="tok-o">.</span><span class="tok-n">userId</span><span class="tok-o">),</span> <span class="tok-n">loginFailPattern</span><span class="tok-o">)</span>

    <span class="tok-c1">// .select方法传入一个 pattern select function，当检测到定义好的模式序列时就会调用</span>
    <span class="tok-k">val</span> <span class="tok-n">loginFailDataStream</span> <span class="tok-k">=</span> <span class="tok-n">patternStream</span>
      <span class="tok-o">.</span><span class="tok-n">select</span><span class="tok-o">((</span><span class="tok-n">pattern</span><span class="tok-k">:</span> <span class="tok-kt">Map</span><span class="tok-o">[</span><span class="tok-kt">String</span>, <span class="tok-kt">Iterable</span><span class="tok-o">[</span><span class="tok-kt">LoginEvent</span><span class="tok-o">]])</span> <span class="tok-k">=&gt;</span> <span class="tok-o">{</span>
        <span class="tok-k">val</span> <span class="tok-n">first</span> <span class="tok-k">=</span> <span class="tok-n">pattern</span><span class="tok-o">.</span><span class="tok-n">getOrElse</span><span class="tok-o">(</span><span class="tok-s">&quot;begin&quot;</span><span class="tok-o">,</span> <span class="tok-kc">null</span><span class="tok-o">).</span><span class="tok-n">iterator</span><span class="tok-o">.</span><span class="tok-n">next</span><span class="tok-o">()</span>
        <span class="tok-k">val</span> <span class="tok-n">second</span> <span class="tok-k">=</span> <span class="tok-n">pattern</span><span class="tok-o">.</span><span class="tok-n">getOrElse</span><span class="tok-o">(</span><span class="tok-s">&quot;next&quot;</span><span class="tok-o">,</span> <span class="tok-kc">null</span><span class="tok-o">).</span><span class="tok-n">iterator</span><span class="tok-o">.</span><span class="tok-n">next</span><span class="tok-o">()</span>
        <span class="tok-o">(</span><span class="tok-n">second</span><span class="tok-o">.</span><span class="tok-n">userId</span><span class="tok-o">,</span> <span class="tok-n">second</span><span class="tok-o">.</span><span class="tok-n">ip</span><span class="tok-o">,</span> <span class="tok-n">second</span><span class="tok-o">.</span><span class="tok-n">eventType</span><span class="tok-o">)</span>
      <span class="tok-o">})</span>
    <span class="tok-c1">// 将匹配到的符合条件的事件打印出来</span>
    <span class="tok-n">loginFailDataStream</span><span class="tok-o">.</span><span class="tok-n">print</span><span class="tok-o">()</span>
    <span class="tok-n">env</span><span class="tok-o">.</span><span class="tok-n">execute</span><span class="tok-o">(</span><span class="tok-s">&quot;Login Fail Detect Job&quot;</span><span class="tok-o">)</span>
  <span class="tok-o">}</span>
<span class="tok-o">}</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_订单支付实时监控">12.9. 订单支付实时监控</h3>
<div class="ulist">
<ul>
<li>
<p>基本需求</p>
<div class="ulist">
<ul>
<li>
<p>用户下单之后，应设置订单失效时间，以提高用户支付的意愿，并降低系统风险</p>
</li>
<li>
<p>用户下单后15分钟未支付，则输出监控信息</p>
</li>
</ul>
</div>
</li>
<li>
<p>解决思路</p>
<div class="ulist">
<ul>
<li>
<p>利用CEP库进行事件流的模式匹配，并设定匹配的时间间隔</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="_模块创建和数据准备_3">12.9.1. 模块创建和数据准备</h4>
<div class="paragraph">
<p>同样地，在UserBehaviorAnalysis下新建一个maven module作为子项目，命名为OrderTimeoutDetect。在这个子模块中，我们同样将会用到flink的CEP库来实现事件流的模式匹配，所以需要在pom文件中引入CEP的相关依赖：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="xml"><span></span><span class="tok-nt">&lt;dependency&gt;</span>
    <span class="tok-nt">&lt;groupId&gt;</span>org.apache.flink<span class="tok-nt">&lt;/groupId&gt;</span>
    <span class="tok-nt">&lt;artifactId&gt;</span>flink-cep_${scala.binary.version}<span class="tok-nt">&lt;/artifactId&gt;</span>
    <span class="tok-nt">&lt;version&gt;</span>${flink.version}<span class="tok-nt">&lt;/version&gt;</span>
<span class="tok-nt">&lt;/dependency&gt;</span>
<span class="tok-nt">&lt;dependency&gt;</span>
    <span class="tok-nt">&lt;groupId&gt;</span>org.apache.flink<span class="tok-nt">&lt;/groupId&gt;</span>
    <span class="tok-nt">&lt;artifactId&gt;</span>flink-cep-scala_${scala.binary.version}<span class="tok-nt">&lt;/artifactId&gt;</span>
    <span class="tok-nt">&lt;version&gt;</span>${flink.version}<span class="tok-nt">&lt;/version&gt;</span>
<span class="tok-nt">&lt;/dependency&gt;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>同样，在src/main/目录下，将默认源文件目录java改名为scala。</p>
</div>
</div>
<div class="sect3">
<h4 id="_代码实现_3">12.9.2. 代码实现</h4>
<div class="paragraph">
<p>在电商平台中，最终创造收入和利润的是用户下单购买的环节；更具体一点，是用户真正完成支付动作的时候。用户下单的行为可以表明用户对商品的需求，但在现实中，并不是每次下单都会被用户立刻支付。当拖延一段时间后，用户支付的意愿会降低。所以为了让用户更有紧迫感从而提高支付转化率，同时也为了防范订单支付环节的安全风险，电商网站往往会对订单状态进行监控，设置一个失效时间（比如15分钟），如果下单后一段时间仍未支付，订单就会被取消。</p>
</div>
<div class="paragraph">
<p>我们将会利用CEP库来实现这个功能。我们先将事件流按照订单号orderId分流，然后定义这样的一个事件模式：在15分钟内，事件“create”与“pay”严格紧邻：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">val</span> <span class="tok-n">orderPayPattern</span> <span class="tok-k">=</span> <span class="tok-nc">Pattern</span><span class="tok-o">.</span><span class="tok-n">begin</span><span class="tok-o">[</span><span class="tok-kt">OrderEvent</span><span class="tok-o">](</span><span class="tok-s">&quot;begin&quot;</span><span class="tok-o">)</span>
  <span class="tok-o">.</span><span class="tok-n">where</span><span class="tok-o">(</span><span class="tok-k">_</span><span class="tok-o">.</span><span class="tok-n">eventType</span> <span class="tok-o">==</span> <span class="tok-s">&quot;create&quot;</span><span class="tok-o">)</span>
  <span class="tok-o">.</span><span class="tok-n">next</span><span class="tok-o">(</span><span class="tok-s">&quot;next&quot;</span><span class="tok-o">)</span>
  <span class="tok-o">.</span><span class="tok-n">where</span><span class="tok-o">(</span><span class="tok-k">_</span><span class="tok-o">.</span><span class="tok-n">eventType</span> <span class="tok-o">==</span> <span class="tok-s">&quot;pay&quot;</span><span class="tok-o">)</span>
  <span class="tok-o">.</span><span class="tok-n">within</span><span class="tok-o">(</span><span class="tok-nc">Time</span><span class="tok-o">.</span><span class="tok-n">seconds</span><span class="tok-o">(</span><span class="tok-mi">5</span><span class="tok-o">))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这样调用.select方法时，就可以同时获取到匹配出的事件和超时未匹配的事件了。
在src/main/scala下继续创建OrderTimeout.scala文件，新建一个单例对象。定义样例类OrderEvent，这是输入的订单事件流；另外还有OrderResult，这是输出显示的订单状态结果。由于没有现成的数据，我们还是用几条自定义的示例数据来做演示。
完整代码如下：</p>
</div>
<div class="listingblock">
<div class="title">OrderTimeoutDetect/src/main/scala/OrderTimeout.scala</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">import</span> <span class="tok-nn">org.apache.flink.cep.scala.CEP</span>
<span class="tok-k">import</span> <span class="tok-nn">org.apache.flink.cep.scala.pattern.Pattern</span>
<span class="tok-k">import</span> <span class="tok-nn">org.apache.flink.streaming.api.scala._</span>
<span class="tok-k">import</span> <span class="tok-nn">org.apache.flink.streaming.api.windowing.time.Time</span>
<span class="tok-k">import</span> <span class="tok-nn">org.apache.flink.streaming.api.TimeCharacteristic</span>
<span class="tok-k">import</span> <span class="tok-nn">org.apache.flink.util.Collector</span>
<span class="tok-k">import</span> <span class="tok-nn">scala.collection.Map</span>

<span class="tok-k">case</span> <span class="tok-k">class</span> <span class="tok-nc">OrderEvent</span><span class="tok-o">(</span><span class="tok-n">orderId</span><span class="tok-k">:</span> <span class="tok-kt">String</span><span class="tok-o">,</span> <span class="tok-n">eventType</span><span class="tok-k">:</span> <span class="tok-kt">String</span><span class="tok-o">,</span> <span class="tok-n">eventTime</span><span class="tok-k">:</span> <span class="tok-kt">String</span><span class="tok-o">)</span>

<span class="tok-k">object</span> <span class="tok-nc">OrderTimeout</span> <span class="tok-o">{</span>

  <span class="tok-k">def</span> <span class="tok-n">main</span><span class="tok-o">(</span><span class="tok-n">args</span><span class="tok-k">:</span> <span class="tok-kt">Array</span><span class="tok-o">[</span><span class="tok-kt">String</span><span class="tok-o">])</span><span class="tok-k">:</span> <span class="tok-kt">Unit</span> <span class="tok-o">=</span> <span class="tok-o">{</span>

    <span class="tok-k">val</span> <span class="tok-n">env</span> <span class="tok-k">=</span> <span class="tok-nc">StreamExecutionEnvironment</span><span class="tok-o">.</span><span class="tok-n">getExecutionEnvironment</span>
    <span class="tok-n">env</span><span class="tok-o">.</span><span class="tok-n">setParallelism</span><span class="tok-o">(</span><span class="tok-mi">1</span><span class="tok-o">)</span>
    <span class="tok-n">env</span><span class="tok-o">.</span><span class="tok-n">setStreamTimeCharacteristic</span><span class="tok-o">(</span><span class="tok-nc">TimeCharacteristic</span><span class="tok-o">.</span><span class="tok-nc">EventTime</span><span class="tok-o">)</span>

    <span class="tok-k">val</span> <span class="tok-n">orderEventStream</span> <span class="tok-k">=</span> <span class="tok-n">env</span><span class="tok-o">.</span><span class="tok-n">fromCollection</span><span class="tok-o">(</span><span class="tok-nc">List</span><span class="tok-o">(</span>
      <span class="tok-nc">OrderEvent</span><span class="tok-o">(</span><span class="tok-s">&quot;1&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;create&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;1558430842&quot;</span><span class="tok-o">),</span>
      <span class="tok-nc">OrderEvent</span><span class="tok-o">(</span><span class="tok-s">&quot;2&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;create&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;1558430843&quot;</span><span class="tok-o">),</span>
      <span class="tok-nc">OrderEvent</span><span class="tok-o">(</span><span class="tok-s">&quot;2&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;pay&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;1558430844&quot;</span><span class="tok-o">),</span>
      <span class="tok-nc">OrderEvent</span><span class="tok-o">(</span><span class="tok-s">&quot;3&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;pay&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;1558430942&quot;</span><span class="tok-o">),</span>
      <span class="tok-nc">OrderEvent</span><span class="tok-o">(</span><span class="tok-s">&quot;4&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;pay&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;1558430943&quot;</span><span class="tok-o">)</span>
    <span class="tok-o">)).</span><span class="tok-n">assignAscendingTimestamps</span><span class="tok-o">(</span><span class="tok-k">_</span><span class="tok-o">.</span><span class="tok-n">eventTime</span><span class="tok-o">.</span><span class="tok-n">toLong</span> <span class="tok-o">*</span> <span class="tok-mi">1000</span><span class="tok-o">)</span>

<span class="tok-c1">//    val orders: DataStream[String] = env.socketTextStream(&quot;localhost&quot;, 9999)</span>
<span class="tok-c1">//</span>
<span class="tok-c1">//    val orderEventStream = orders</span>
<span class="tok-c1">//      .map(s =&gt; {</span>
<span class="tok-c1">//        println(s)</span>
<span class="tok-c1">//        val slist = s.split(&quot;\\|&quot;)</span>
<span class="tok-c1">//        println(slist)</span>
<span class="tok-c1">//        OrderEvent(slist(0), slist(1), slist(2))</span>
<span class="tok-c1">//      })</span>
<span class="tok-c1">//      .assignAscendingTimestamps(_.eventTime.toLong * 1000)</span>

    <span class="tok-k">val</span> <span class="tok-n">orderPayPattern</span> <span class="tok-k">=</span> <span class="tok-nc">Pattern</span><span class="tok-o">.</span><span class="tok-n">begin</span><span class="tok-o">[</span><span class="tok-kt">OrderEvent</span><span class="tok-o">](</span><span class="tok-s">&quot;begin&quot;</span><span class="tok-o">)</span>
      <span class="tok-o">.</span><span class="tok-n">where</span><span class="tok-o">(</span><span class="tok-k">_</span><span class="tok-o">.</span><span class="tok-n">eventType</span><span class="tok-o">.</span><span class="tok-n">equals</span><span class="tok-o">(</span><span class="tok-s">&quot;create&quot;</span><span class="tok-o">))</span>
      <span class="tok-o">.</span><span class="tok-n">next</span><span class="tok-o">(</span><span class="tok-s">&quot;next&quot;</span><span class="tok-o">)</span>
      <span class="tok-o">.</span><span class="tok-n">where</span><span class="tok-o">(</span><span class="tok-k">_</span><span class="tok-o">.</span><span class="tok-n">eventType</span><span class="tok-o">.</span><span class="tok-n">equals</span><span class="tok-o">(</span><span class="tok-s">&quot;pay&quot;</span><span class="tok-o">))</span>
      <span class="tok-o">.</span><span class="tok-n">within</span><span class="tok-o">(</span><span class="tok-nc">Time</span><span class="tok-o">.</span><span class="tok-n">seconds</span><span class="tok-o">(</span><span class="tok-mi">5</span><span class="tok-o">))</span>

    <span class="tok-k">val</span> <span class="tok-n">orderTimeoutOutput</span> <span class="tok-k">=</span> <span class="tok-nc">OutputTag</span><span class="tok-o">[</span><span class="tok-kt">OrderEvent</span><span class="tok-o">](</span><span class="tok-s">&quot;orderTimeout&quot;</span><span class="tok-o">)</span>

    <span class="tok-k">val</span> <span class="tok-n">patternStream</span> <span class="tok-k">=</span> <span class="tok-nc">CEP</span><span class="tok-o">.</span><span class="tok-n">pattern</span><span class="tok-o">(</span><span class="tok-n">orderEventStream</span><span class="tok-o">.</span><span class="tok-n">keyBy</span><span class="tok-o">(</span><span class="tok-s">&quot;orderId&quot;</span><span class="tok-o">),</span> <span class="tok-n">orderPayPattern</span><span class="tok-o">)</span>

    <span class="tok-k">val</span> <span class="tok-n">timeoutFunction</span> <span class="tok-k">=</span> <span class="tok-o">(</span><span class="tok-n">map</span><span class="tok-k">:</span> <span class="tok-kt">Map</span><span class="tok-o">[</span><span class="tok-kt">String</span>, <span class="tok-kt">Iterable</span><span class="tok-o">[</span><span class="tok-kt">OrderEvent</span><span class="tok-o">]],</span> <span class="tok-n">timestamp</span><span class="tok-k">:</span> <span class="tok-kt">Long</span><span class="tok-o">,</span> <span class="tok-n">out</span><span class="tok-k">:</span> <span class="tok-kt">Collector</span><span class="tok-o">[</span><span class="tok-kt">OrderEvent</span><span class="tok-o">])</span> <span class="tok-k">=&gt;</span> <span class="tok-o">{</span>
      <span class="tok-n">print</span><span class="tok-o">(</span><span class="tok-n">timestamp</span><span class="tok-o">)</span>
      <span class="tok-k">val</span> <span class="tok-n">orderStart</span> <span class="tok-k">=</span> <span class="tok-n">map</span><span class="tok-o">.</span><span class="tok-n">get</span><span class="tok-o">(</span><span class="tok-s">&quot;begin&quot;</span><span class="tok-o">).</span><span class="tok-n">get</span><span class="tok-o">.</span><span class="tok-n">head</span>
      <span class="tok-n">out</span><span class="tok-o">.</span><span class="tok-n">collect</span><span class="tok-o">(</span><span class="tok-n">orderStart</span><span class="tok-o">)</span>
    <span class="tok-o">}</span>

    <span class="tok-k">val</span> <span class="tok-n">selectFunction</span> <span class="tok-k">=</span> <span class="tok-o">(</span><span class="tok-n">map</span><span class="tok-k">:</span> <span class="tok-kt">Map</span><span class="tok-o">[</span><span class="tok-kt">String</span>, <span class="tok-kt">Iterable</span><span class="tok-o">[</span><span class="tok-kt">OrderEvent</span><span class="tok-o">]],</span> <span class="tok-n">out</span><span class="tok-k">:</span> <span class="tok-kt">Collector</span><span class="tok-o">[</span><span class="tok-kt">OrderEvent</span><span class="tok-o">])</span> <span class="tok-k">=&gt;</span> <span class="tok-o">{</span>
    <span class="tok-o">}</span>

    <span class="tok-k">val</span> <span class="tok-n">timeoutOrder</span> <span class="tok-k">=</span> <span class="tok-n">patternStream</span><span class="tok-o">.</span><span class="tok-n">flatSelect</span><span class="tok-o">(</span><span class="tok-n">orderTimeoutOutput</span><span class="tok-o">)(</span><span class="tok-n">timeoutFunction</span><span class="tok-o">)(</span><span class="tok-n">selectFunction</span><span class="tok-o">)</span>

    <span class="tok-n">timeoutOrder</span><span class="tok-o">.</span><span class="tok-n">getSideOutput</span><span class="tok-o">(</span><span class="tok-n">orderTimeoutOutput</span><span class="tok-o">).</span><span class="tok-n">print</span><span class="tok-o">()</span>

    <span class="tok-n">env</span><span class="tok-o">.</span><span class="tok-n">execute</span>

  <span class="tok-o">}</span>
<span class="tok-o">}</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_使用process_function实现订单超时需求">12.9.3. 使用Process Function实现订单超时需求</h4>
<div class="listingblock">
<div class="title">OrderTimeoutWithoutCep.scala</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">import</span> <span class="tok-nn">org.apache.flink.api.common.state.</span><span class="tok-o">{</span><span class="tok-nc">ValueState</span><span class="tok-o">,</span> <span class="tok-nc">ValueStateDescriptor</span><span class="tok-o">}</span>
<span class="tok-k">import</span> <span class="tok-nn">org.apache.flink.streaming.api.TimeCharacteristic</span>
<span class="tok-k">import</span> <span class="tok-nn">org.apache.flink.streaming.api.functions.KeyedProcessFunction</span>
<span class="tok-k">import</span> <span class="tok-nn">org.apache.flink.streaming.api.scala.StreamExecutionEnvironment</span>
<span class="tok-k">import</span> <span class="tok-nn">org.apache.flink.streaming.api.scala._</span>
<span class="tok-k">import</span> <span class="tok-nn">org.apache.flink.util.Collector</span>

<span class="tok-k">case</span> <span class="tok-k">class</span> <span class="tok-nc">OrderEvent1</span><span class="tok-o">(</span><span class="tok-n">orderId</span><span class="tok-k">:</span> <span class="tok-kt">String</span><span class="tok-o">,</span>
                      <span class="tok-n">eventType</span><span class="tok-k">:</span> <span class="tok-kt">String</span><span class="tok-o">,</span>
                      <span class="tok-n">eventTime</span><span class="tok-k">:</span> <span class="tok-kt">String</span><span class="tok-o">)</span>

<span class="tok-k">object</span> <span class="tok-nc">OrderTimeoutWithoutCep</span> <span class="tok-o">{</span>
  <span class="tok-k">def</span> <span class="tok-n">main</span><span class="tok-o">(</span><span class="tok-n">args</span><span class="tok-k">:</span> <span class="tok-kt">Array</span><span class="tok-o">[</span><span class="tok-kt">String</span><span class="tok-o">])</span><span class="tok-k">:</span> <span class="tok-kt">Unit</span> <span class="tok-o">=</span> <span class="tok-o">{</span>
    <span class="tok-k">val</span> <span class="tok-n">env</span> <span class="tok-k">=</span> <span class="tok-nc">StreamExecutionEnvironment</span><span class="tok-o">.</span><span class="tok-n">getExecutionEnvironment</span>
    <span class="tok-n">env</span><span class="tok-o">.</span><span class="tok-n">setParallelism</span><span class="tok-o">(</span><span class="tok-mi">1</span><span class="tok-o">)</span>
    <span class="tok-n">env</span><span class="tok-o">.</span><span class="tok-n">setStreamTimeCharacteristic</span><span class="tok-o">(</span><span class="tok-nc">TimeCharacteristic</span><span class="tok-o">.</span><span class="tok-nc">EventTime</span><span class="tok-o">)</span>

    <span class="tok-k">val</span> <span class="tok-n">orderEventsStream</span> <span class="tok-k">=</span> <span class="tok-n">env</span><span class="tok-o">.</span><span class="tok-n">fromCollection</span><span class="tok-o">(</span><span class="tok-nc">List</span><span class="tok-o">(</span>
      <span class="tok-nc">OrderEvent1</span><span class="tok-o">(</span><span class="tok-s">&quot;1&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;create&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;1558430842&quot;</span><span class="tok-o">),</span>
      <span class="tok-nc">OrderEvent1</span><span class="tok-o">(</span><span class="tok-s">&quot;2&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;create&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;1558430843&quot;</span><span class="tok-o">),</span>
      <span class="tok-nc">OrderEvent1</span><span class="tok-o">(</span><span class="tok-s">&quot;2&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;pay&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;1558430844&quot;</span><span class="tok-o">),</span>
      <span class="tok-nc">OrderEvent1</span><span class="tok-o">(</span><span class="tok-s">&quot;3&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;pay&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;1558430942&quot;</span><span class="tok-o">),</span>
      <span class="tok-nc">OrderEvent1</span><span class="tok-o">(</span><span class="tok-s">&quot;4&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;pay&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;1558430943&quot;</span><span class="tok-o">)</span>
    <span class="tok-o">)).</span><span class="tok-n">assignAscendingTimestamps</span><span class="tok-o">(</span><span class="tok-k">_</span><span class="tok-o">.</span><span class="tok-n">eventTime</span><span class="tok-o">.</span><span class="tok-n">toLong</span> <span class="tok-o">*</span> <span class="tok-mi">1000</span><span class="tok-o">)</span>

    <span class="tok-k">val</span> <span class="tok-n">orders</span> <span class="tok-k">=</span> <span class="tok-n">orderEventsStream</span>
      <span class="tok-o">.</span><span class="tok-n">keyBy</span><span class="tok-o">(</span><span class="tok-k">_</span><span class="tok-o">.</span><span class="tok-n">orderId</span><span class="tok-o">)</span>
      <span class="tok-o">.</span><span class="tok-n">process</span><span class="tok-o">(</span><span class="tok-k">new</span> <span class="tok-nc">OrderMatchFunction</span><span class="tok-o">)</span>
      <span class="tok-o">.</span><span class="tok-n">print</span><span class="tok-o">()</span>

    <span class="tok-n">env</span><span class="tok-o">.</span><span class="tok-n">execute</span>
  <span class="tok-o">}</span>

  <span class="tok-k">class</span> <span class="tok-nc">OrderMatchFunction</span> <span class="tok-k">extends</span> <span class="tok-nc">KeyedProcessFunction</span><span class="tok-o">[</span><span class="tok-kt">String</span>,
    <span class="tok-kt">OrderEvent1</span>, <span class="tok-kt">OrderEvent1</span><span class="tok-o">]</span> <span class="tok-o">{</span>
    <span class="tok-k">lazy</span> <span class="tok-k">val</span> <span class="tok-n">orderState</span><span class="tok-k">:</span> <span class="tok-kt">ValueState</span><span class="tok-o">[</span><span class="tok-kt">OrderEvent1</span><span class="tok-o">]</span> <span class="tok-k">=</span> <span class="tok-n">getRuntimeContext</span>
      <span class="tok-o">.</span><span class="tok-n">getState</span><span class="tok-o">(</span><span class="tok-k">new</span> <span class="tok-nc">ValueStateDescriptor</span><span class="tok-o">[</span><span class="tok-kt">OrderEvent1</span><span class="tok-o">](</span><span class="tok-s">&quot;saved order&quot;</span><span class="tok-o">,</span>
        <span class="tok-n">classOf</span><span class="tok-o">[</span><span class="tok-kt">OrderEvent1</span><span class="tok-o">]))</span>

    <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">processElement</span><span class="tok-o">(</span><span class="tok-n">order</span><span class="tok-k">:</span> <span class="tok-kt">OrderEvent1</span><span class="tok-o">,</span>
                                <span class="tok-n">context</span><span class="tok-k">:</span> <span class="tok-kt">KeyedProcessFunction</span><span class="tok-o">[</span>
                                  <span class="tok-kt">String</span>, <span class="tok-kt">OrderEvent1</span>, <span class="tok-kt">OrderEvent1</span><span class="tok-o">]</span><span class="tok-k">#</span><span class="tok-nc">Context</span><span class="tok-o">,</span>
                                <span class="tok-n">out</span><span class="tok-k">:</span> <span class="tok-kt">Collector</span><span class="tok-o">[</span><span class="tok-kt">OrderEvent1</span><span class="tok-o">])</span><span class="tok-k">:</span> <span class="tok-kt">Unit</span> <span class="tok-o">=</span> <span class="tok-o">{</span>
      <span class="tok-k">val</span> <span class="tok-n">timerService</span> <span class="tok-k">=</span> <span class="tok-n">context</span><span class="tok-o">.</span><span class="tok-n">timerService</span>

      <span class="tok-k">if</span> <span class="tok-o">(</span><span class="tok-n">order</span><span class="tok-o">.</span><span class="tok-n">eventType</span> <span class="tok-o">==</span> <span class="tok-s">&quot;create&quot;</span><span class="tok-o">)</span> <span class="tok-o">{</span>
        <span class="tok-k">if</span> <span class="tok-o">(</span><span class="tok-n">orderState</span><span class="tok-o">.</span><span class="tok-n">value</span><span class="tok-o">()</span> <span class="tok-o">==</span> <span class="tok-kc">null</span><span class="tok-o">)</span> <span class="tok-o">{</span>
          <span class="tok-n">orderState</span><span class="tok-o">.</span><span class="tok-n">update</span><span class="tok-o">(</span><span class="tok-n">order</span><span class="tok-o">)</span>
        <span class="tok-o">}</span>
      <span class="tok-o">}</span> <span class="tok-k">else</span> <span class="tok-o">{</span>
        <span class="tok-n">orderState</span><span class="tok-o">.</span><span class="tok-n">update</span><span class="tok-o">(</span><span class="tok-n">order</span><span class="tok-o">)</span>
      <span class="tok-o">}</span>

      <span class="tok-n">timerService</span><span class="tok-o">.</span><span class="tok-n">registerEventTimeTimer</span><span class="tok-o">(</span>
        <span class="tok-n">order</span><span class="tok-o">.</span><span class="tok-n">eventTime</span><span class="tok-o">.</span><span class="tok-n">toLong</span> <span class="tok-o">*</span> <span class="tok-mi">1000</span> <span class="tok-o">+</span> <span class="tok-mi">5</span> <span class="tok-o">*</span> <span class="tok-mi">1000</span>
      <span class="tok-o">)</span>
    <span class="tok-o">}</span>

    <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">onTimer</span><span class="tok-o">(</span><span class="tok-n">timestamp</span><span class="tok-k">:</span> <span class="tok-kt">Long</span><span class="tok-o">,</span>
                         <span class="tok-n">ctx</span><span class="tok-k">:</span> <span class="tok-kt">KeyedProcessFunction</span><span class="tok-o">[</span>
                           <span class="tok-kt">String</span>, <span class="tok-kt">OrderEvent1</span>, <span class="tok-kt">OrderEvent1</span><span class="tok-o">]</span><span class="tok-k">#</span><span class="tok-nc">OnTimerContext</span><span class="tok-o">,</span>
                         <span class="tok-n">out</span><span class="tok-k">:</span> <span class="tok-kt">Collector</span><span class="tok-o">[</span><span class="tok-kt">OrderEvent1</span><span class="tok-o">])</span><span class="tok-k">:</span> <span class="tok-kt">Unit</span> <span class="tok-o">=</span> <span class="tok-o">{</span>
      <span class="tok-k">val</span> <span class="tok-n">savedOrder</span> <span class="tok-k">=</span> <span class="tok-n">orderState</span><span class="tok-o">.</span><span class="tok-n">value</span><span class="tok-o">()</span>

      <span class="tok-k">if</span> <span class="tok-o">(</span><span class="tok-n">savedOrder</span> <span class="tok-o">!=</span> <span class="tok-kc">null</span> <span class="tok-o">&amp;&amp;</span>
        <span class="tok-o">(</span><span class="tok-n">savedOrder</span><span class="tok-o">.</span><span class="tok-n">eventType</span> <span class="tok-o">==</span> <span class="tok-s">&quot;create&quot;</span><span class="tok-o">))</span> <span class="tok-o">{</span>
        <span class="tok-n">out</span><span class="tok-o">.</span><span class="tok-n">collect</span><span class="tok-o">(</span><span class="tok-n">savedOrder</span><span class="tok-o">)</span>
      <span class="tok-o">}</span>

      <span class="tok-n">orderState</span><span class="tok-o">.</span><span class="tok-n">clear</span><span class="tok-o">()</span>
    <span class="tok-o">}</span>
  <span class="tok-o">}</span>
<span class="tok-o">}</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_实现两条流的join">12.10. 实现两条流的join</h3>
<div class="imageblock">
<div class="content">
<img src="images/twostreamsjoin.png" alt="twostreamsjoin">
</div>
<div class="title">Figure 2. 示意图</div>
</div>
<div class="listingblock">
<div class="title">TwoStreamsJoin.scala</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="scala"><span></span><span class="tok-k">import</span> <span class="tok-nn">org.apache.flink.api.common.state.</span><span class="tok-o">{</span><span class="tok-nc">ValueState</span><span class="tok-o">,</span> <span class="tok-nc">ValueStateDescriptor</span><span class="tok-o">}</span>
<span class="tok-k">import</span> <span class="tok-nn">org.apache.flink.streaming.api.TimeCharacteristic</span>
<span class="tok-k">import</span> <span class="tok-nn">org.apache.flink.streaming.api.functions.co.CoProcessFunction</span>
<span class="tok-k">import</span> <span class="tok-nn">org.apache.flink.streaming.api.scala.OutputTag</span>
<span class="tok-k">import</span> <span class="tok-nn">org.apache.flink.streaming.api.scala._</span>
<span class="tok-k">import</span> <span class="tok-nn">org.apache.flink.util.Collector</span>

<span class="tok-k">case</span> <span class="tok-k">class</span> <span class="tok-nc">OrderEvent</span><span class="tok-o">(</span><span class="tok-n">orderId</span><span class="tok-k">:</span> <span class="tok-kt">String</span><span class="tok-o">,</span>
                      <span class="tok-n">eventType</span><span class="tok-k">:</span> <span class="tok-kt">String</span><span class="tok-o">,</span>
                      <span class="tok-n">eventTime</span><span class="tok-k">:</span> <span class="tok-kt">String</span><span class="tok-o">)</span>

<span class="tok-k">case</span> <span class="tok-k">class</span> <span class="tok-nc">PayEvent</span><span class="tok-o">(</span><span class="tok-n">orderId</span><span class="tok-k">:</span> <span class="tok-kt">String</span><span class="tok-o">,</span>
                    <span class="tok-n">eventType</span><span class="tok-k">:</span> <span class="tok-kt">String</span><span class="tok-o">,</span>
                    <span class="tok-n">eventTime</span><span class="tok-k">:</span> <span class="tok-kt">String</span><span class="tok-o">)</span>

<span class="tok-k">object</span> <span class="tok-nc">TwoStreamsJoin</span> <span class="tok-o">{</span>
  <span class="tok-k">val</span> <span class="tok-n">unmatchedOrders</span> <span class="tok-k">=</span> <span class="tok-k">new</span> <span class="tok-nc">OutputTag</span><span class="tok-o">[</span><span class="tok-kt">OrderEvent</span><span class="tok-o">](</span><span class="tok-s">&quot;unmatchedOrders&quot;</span><span class="tok-o">){}</span>
  <span class="tok-k">val</span> <span class="tok-n">unmatchedPays</span> <span class="tok-k">=</span> <span class="tok-k">new</span> <span class="tok-nc">OutputTag</span><span class="tok-o">[</span><span class="tok-kt">PayEvent</span><span class="tok-o">](</span><span class="tok-s">&quot;unmatchedPays&quot;</span><span class="tok-o">){}</span>

  <span class="tok-k">def</span> <span class="tok-n">main</span><span class="tok-o">(</span><span class="tok-n">args</span><span class="tok-k">:</span> <span class="tok-kt">Array</span><span class="tok-o">[</span><span class="tok-kt">String</span><span class="tok-o">])</span><span class="tok-k">:</span> <span class="tok-kt">Unit</span> <span class="tok-o">=</span> <span class="tok-o">{</span>
    <span class="tok-k">val</span> <span class="tok-n">env</span> <span class="tok-k">=</span> <span class="tok-nc">StreamExecutionEnvironment</span><span class="tok-o">.</span><span class="tok-n">getExecutionEnvironment</span>
    <span class="tok-n">env</span><span class="tok-o">.</span><span class="tok-n">setStreamTimeCharacteristic</span><span class="tok-o">(</span><span class="tok-nc">TimeCharacteristic</span><span class="tok-o">.</span><span class="tok-nc">EventTime</span><span class="tok-o">)</span>
    <span class="tok-n">env</span><span class="tok-o">.</span><span class="tok-n">setParallelism</span><span class="tok-o">(</span><span class="tok-mi">1</span><span class="tok-o">)</span>

    <span class="tok-k">val</span> <span class="tok-n">orders</span> <span class="tok-k">=</span> <span class="tok-n">env</span>
      <span class="tok-o">.</span><span class="tok-n">fromCollection</span><span class="tok-o">(</span><span class="tok-nc">List</span><span class="tok-o">(</span>
      <span class="tok-nc">OrderEvent</span><span class="tok-o">(</span><span class="tok-s">&quot;1&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;create&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;1558430842&quot;</span><span class="tok-o">),</span>
      <span class="tok-nc">OrderEvent</span><span class="tok-o">(</span><span class="tok-s">&quot;2&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;create&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;1558430843&quot;</span><span class="tok-o">),</span>
      <span class="tok-nc">OrderEvent</span><span class="tok-o">(</span><span class="tok-s">&quot;1&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;pay&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;1558430844&quot;</span><span class="tok-o">),</span>
      <span class="tok-nc">OrderEvent</span><span class="tok-o">(</span><span class="tok-s">&quot;2&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;pay&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;1558430845&quot;</span><span class="tok-o">),</span>
      <span class="tok-nc">OrderEvent</span><span class="tok-o">(</span><span class="tok-s">&quot;3&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;create&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;1558430849&quot;</span><span class="tok-o">),</span>
      <span class="tok-nc">OrderEvent</span><span class="tok-o">(</span><span class="tok-s">&quot;3&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;pay&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;1558430849&quot;</span><span class="tok-o">)</span>
    <span class="tok-o">)).</span><span class="tok-n">assignAscendingTimestamps</span><span class="tok-o">(</span><span class="tok-k">_</span><span class="tok-o">.</span><span class="tok-n">eventTime</span><span class="tok-o">.</span><span class="tok-n">toLong</span> <span class="tok-o">*</span> <span class="tok-mi">1000</span><span class="tok-o">)</span>
      <span class="tok-o">.</span><span class="tok-n">keyBy</span><span class="tok-o">(</span><span class="tok-s">&quot;orderId&quot;</span><span class="tok-o">)</span>

    <span class="tok-k">val</span> <span class="tok-n">pays</span> <span class="tok-k">=</span> <span class="tok-n">env</span><span class="tok-o">.</span><span class="tok-n">fromCollection</span><span class="tok-o">(</span><span class="tok-nc">List</span><span class="tok-o">(</span>
      <span class="tok-nc">PayEvent</span><span class="tok-o">(</span><span class="tok-s">&quot;1&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;weixin&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;1558430847&quot;</span><span class="tok-o">),</span>
      <span class="tok-nc">PayEvent</span><span class="tok-o">(</span><span class="tok-s">&quot;2&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;zhifubao&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;1558430848&quot;</span><span class="tok-o">),</span>
      <span class="tok-nc">PayEvent</span><span class="tok-o">(</span><span class="tok-s">&quot;4&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;zhifubao&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;1558430850&quot;</span><span class="tok-o">)</span>
    <span class="tok-o">)).</span><span class="tok-n">assignAscendingTimestamps</span><span class="tok-o">(</span><span class="tok-k">_</span><span class="tok-o">.</span><span class="tok-n">eventTime</span><span class="tok-o">.</span><span class="tok-n">toLong</span> <span class="tok-o">*</span> <span class="tok-mi">1000</span><span class="tok-o">)</span>
      <span class="tok-o">.</span><span class="tok-n">keyBy</span><span class="tok-o">(</span><span class="tok-s">&quot;orderId&quot;</span><span class="tok-o">)</span>

    <span class="tok-k">val</span> <span class="tok-n">processed</span> <span class="tok-k">=</span> <span class="tok-n">orders</span>
      <span class="tok-o">.</span><span class="tok-n">connect</span><span class="tok-o">(</span><span class="tok-n">pays</span><span class="tok-o">)</span>
      <span class="tok-o">.</span><span class="tok-n">process</span><span class="tok-o">(</span><span class="tok-k">new</span> <span class="tok-nc">EnrichmentFunction</span><span class="tok-o">)</span>

    <span class="tok-n">processed</span><span class="tok-o">.</span><span class="tok-n">getSideOutput</span><span class="tok-o">[</span><span class="tok-kt">PayEvent</span><span class="tok-o">](</span><span class="tok-n">unmatchedPays</span><span class="tok-o">).</span><span class="tok-n">print</span><span class="tok-o">()</span>
    <span class="tok-n">processed</span><span class="tok-o">.</span><span class="tok-n">getSideOutput</span><span class="tok-o">[</span><span class="tok-kt">OrderEvent</span><span class="tok-o">](</span><span class="tok-n">unmatchedOrders</span><span class="tok-o">).</span><span class="tok-n">print</span><span class="tok-o">()</span>

    <span class="tok-n">env</span><span class="tok-o">.</span><span class="tok-n">execute</span>
  <span class="tok-o">}</span>

  <span class="tok-k">class</span> <span class="tok-nc">EnrichmentFunction</span> <span class="tok-k">extends</span> <span class="tok-nc">CoProcessFunction</span><span class="tok-o">[</span>
    <span class="tok-kt">OrderEvent</span>, <span class="tok-kt">PayEvent</span>, <span class="tok-o">(</span><span class="tok-kt">OrderEvent</span>, <span class="tok-kt">PayEvent</span><span class="tok-o">)]</span> <span class="tok-o">{</span>
    <span class="tok-k">lazy</span> <span class="tok-k">val</span> <span class="tok-n">orderState</span><span class="tok-k">:</span> <span class="tok-kt">ValueState</span><span class="tok-o">[</span><span class="tok-kt">OrderEvent</span><span class="tok-o">]</span> <span class="tok-k">=</span> <span class="tok-n">getRuntimeContext</span>
      <span class="tok-o">.</span><span class="tok-n">getState</span><span class="tok-o">(</span><span class="tok-k">new</span> <span class="tok-nc">ValueStateDescriptor</span><span class="tok-o">[</span><span class="tok-kt">OrderEvent</span><span class="tok-o">](</span><span class="tok-s">&quot;saved order&quot;</span><span class="tok-o">,</span>
        <span class="tok-n">classOf</span><span class="tok-o">[</span><span class="tok-kt">OrderEvent</span><span class="tok-o">]))</span>

    <span class="tok-k">lazy</span> <span class="tok-k">val</span> <span class="tok-n">payState</span><span class="tok-k">:</span> <span class="tok-kt">ValueState</span><span class="tok-o">[</span><span class="tok-kt">PayEvent</span><span class="tok-o">]</span> <span class="tok-k">=</span> <span class="tok-n">getRuntimeContext</span>
      <span class="tok-o">.</span><span class="tok-n">getState</span><span class="tok-o">(</span><span class="tok-k">new</span> <span class="tok-nc">ValueStateDescriptor</span><span class="tok-o">[</span><span class="tok-kt">PayEvent</span><span class="tok-o">](</span><span class="tok-s">&quot;saved pay&quot;</span><span class="tok-o">,</span>
        <span class="tok-n">classOf</span><span class="tok-o">[</span><span class="tok-kt">PayEvent</span><span class="tok-o">]))</span>

    <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">processElement1</span><span class="tok-o">(</span><span class="tok-n">order</span><span class="tok-k">:</span> <span class="tok-kt">OrderEvent</span><span class="tok-o">,</span>
                                 <span class="tok-n">context</span><span class="tok-k">:</span> <span class="tok-kt">CoProcessFunction</span><span class="tok-o">[</span>
                                   <span class="tok-kt">OrderEvent</span>,
                                   <span class="tok-kt">PayEvent</span>,
                                   <span class="tok-o">(</span><span class="tok-kt">OrderEvent</span>, <span class="tok-kt">PayEvent</span><span class="tok-o">)]</span><span class="tok-k">#</span><span class="tok-nc">Context</span><span class="tok-o">,</span>
                                 <span class="tok-n">out</span><span class="tok-k">:</span> <span class="tok-kt">Collector</span><span class="tok-o">[(</span><span class="tok-kt">OrderEvent</span>, <span class="tok-kt">PayEvent</span><span class="tok-o">)])</span><span class="tok-k">:</span> <span class="tok-kt">Unit</span> <span class="tok-o">=</span> <span class="tok-o">{</span>
      <span class="tok-k">val</span> <span class="tok-n">pay</span> <span class="tok-k">=</span> <span class="tok-n">payState</span><span class="tok-o">.</span><span class="tok-n">value</span><span class="tok-o">()</span>

      <span class="tok-k">if</span> <span class="tok-o">(</span><span class="tok-n">pay</span> <span class="tok-o">!=</span> <span class="tok-kc">null</span><span class="tok-o">)</span> <span class="tok-o">{</span>
        <span class="tok-n">payState</span><span class="tok-o">.</span><span class="tok-n">clear</span><span class="tok-o">()</span>
        <span class="tok-n">out</span><span class="tok-o">.</span><span class="tok-n">collect</span><span class="tok-o">((</span><span class="tok-n">order</span><span class="tok-o">,</span> <span class="tok-n">pay</span><span class="tok-o">))</span>
      <span class="tok-o">}</span> <span class="tok-k">else</span> <span class="tok-o">{</span>
        <span class="tok-n">orderState</span><span class="tok-o">.</span><span class="tok-n">update</span><span class="tok-o">(</span><span class="tok-n">order</span><span class="tok-o">)</span>
        <span class="tok-c1">// as soon as the watermark arrives,</span>
        <span class="tok-c1">// we can stop waiting for the corresponding pay</span>
        <span class="tok-n">context</span><span class="tok-o">.</span><span class="tok-n">timerService</span>
          <span class="tok-o">.</span><span class="tok-n">registerEventTimeTimer</span><span class="tok-o">(</span><span class="tok-n">order</span><span class="tok-o">.</span><span class="tok-n">eventTime</span><span class="tok-o">.</span><span class="tok-n">toLong</span> <span class="tok-o">*</span> <span class="tok-mi">1000</span><span class="tok-o">)</span>
      <span class="tok-o">}</span>
    <span class="tok-o">}</span>

    <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">processElement2</span><span class="tok-o">(</span><span class="tok-n">pay</span><span class="tok-k">:</span> <span class="tok-kt">PayEvent</span><span class="tok-o">,</span>
                                 <span class="tok-n">context</span><span class="tok-k">:</span> <span class="tok-kt">CoProcessFunction</span><span class="tok-o">[</span>
                                   <span class="tok-kt">OrderEvent</span>,
                                   <span class="tok-kt">PayEvent</span>,
                                   <span class="tok-o">(</span><span class="tok-kt">OrderEvent</span>, <span class="tok-kt">PayEvent</span><span class="tok-o">)]</span><span class="tok-k">#</span><span class="tok-nc">Context</span><span class="tok-o">,</span>
                                 <span class="tok-n">out</span><span class="tok-k">:</span> <span class="tok-kt">Collector</span><span class="tok-o">[(</span><span class="tok-kt">OrderEvent</span>, <span class="tok-kt">PayEvent</span><span class="tok-o">)])</span><span class="tok-k">:</span> <span class="tok-kt">Unit</span> <span class="tok-o">=</span> <span class="tok-o">{</span>
      <span class="tok-k">val</span> <span class="tok-n">order</span> <span class="tok-k">=</span> <span class="tok-n">orderState</span><span class="tok-o">.</span><span class="tok-n">value</span><span class="tok-o">()</span>

      <span class="tok-k">if</span> <span class="tok-o">(</span><span class="tok-n">order</span> <span class="tok-o">!=</span> <span class="tok-kc">null</span><span class="tok-o">)</span> <span class="tok-o">{</span>
        <span class="tok-n">orderState</span><span class="tok-o">.</span><span class="tok-n">clear</span><span class="tok-o">()</span>
        <span class="tok-n">out</span><span class="tok-o">.</span><span class="tok-n">collect</span><span class="tok-o">((</span><span class="tok-n">order</span><span class="tok-o">,</span> <span class="tok-n">pay</span><span class="tok-o">))</span>
      <span class="tok-o">}</span> <span class="tok-k">else</span> <span class="tok-o">{</span>
        <span class="tok-n">payState</span><span class="tok-o">.</span><span class="tok-n">update</span><span class="tok-o">(</span><span class="tok-n">pay</span><span class="tok-o">)</span>
        <span class="tok-n">context</span><span class="tok-o">.</span><span class="tok-n">timerService</span><span class="tok-o">.</span><span class="tok-n">registerEventTimeTimer</span><span class="tok-o">(</span><span class="tok-n">pay</span><span class="tok-o">.</span><span class="tok-n">eventTime</span><span class="tok-o">.</span><span class="tok-n">toLong</span> <span class="tok-o">*</span> <span class="tok-mi">1000</span><span class="tok-o">)</span>
      <span class="tok-o">}</span>
    <span class="tok-o">}</span>

    <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">onTimer</span><span class="tok-o">(</span><span class="tok-n">timestamp</span><span class="tok-k">:</span> <span class="tok-kt">Long</span><span class="tok-o">,</span>
                         <span class="tok-n">ctx</span><span class="tok-k">:</span> <span class="tok-kt">CoProcessFunction</span><span class="tok-o">[</span><span class="tok-kt">OrderEvent</span>,
                           <span class="tok-kt">PayEvent</span>, <span class="tok-o">(</span><span class="tok-kt">OrderEvent</span>, <span class="tok-kt">PayEvent</span><span class="tok-o">)]</span><span class="tok-k">#</span><span class="tok-nc">OnTimerContext</span><span class="tok-o">,</span>
                         <span class="tok-n">out</span><span class="tok-k">:</span> <span class="tok-kt">Collector</span><span class="tok-o">[(</span><span class="tok-kt">OrderEvent</span>, <span class="tok-kt">PayEvent</span><span class="tok-o">)])</span><span class="tok-k">:</span> <span class="tok-kt">Unit</span> <span class="tok-o">=</span> <span class="tok-o">{</span>
      <span class="tok-k">if</span> <span class="tok-o">(</span><span class="tok-n">payState</span><span class="tok-o">.</span><span class="tok-n">value</span> <span class="tok-o">!=</span> <span class="tok-kc">null</span><span class="tok-o">)</span> <span class="tok-o">{</span>
        <span class="tok-n">ctx</span><span class="tok-o">.</span><span class="tok-n">output</span><span class="tok-o">(</span><span class="tok-n">unmatchedPays</span><span class="tok-o">,</span> <span class="tok-n">payState</span><span class="tok-o">.</span><span class="tok-n">value</span><span class="tok-o">)</span>
        <span class="tok-n">payState</span><span class="tok-o">.</span><span class="tok-n">clear</span><span class="tok-o">()</span>
      <span class="tok-o">}</span>

      <span class="tok-k">if</span> <span class="tok-o">(</span><span class="tok-n">orderState</span><span class="tok-o">.</span><span class="tok-n">value</span> <span class="tok-o">!=</span> <span class="tok-kc">null</span><span class="tok-o">)</span> <span class="tok-o">{</span>
        <span class="tok-n">ctx</span><span class="tok-o">.</span><span class="tok-n">output</span><span class="tok-o">(</span><span class="tok-n">unmatchedOrders</span><span class="tok-o">,</span> <span class="tok-n">orderState</span><span class="tok-o">.</span><span class="tok-n">value</span><span class="tok-o">)</span>
        <span class="tok-n">orderState</span><span class="tok-o">.</span><span class="tok-n">clear</span><span class="tok-o">()</span>
      <span class="tok-o">}</span>
    <span class="tok-o">}</span>
  <span class="tok-o">}</span>
<span class="tok-o">}</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_dataflow模型">13. Dataflow模型</h2>
<div class="sectionbody">
<div class="paragraph">
<p>一种能平衡准确性，延迟程度，处理成本的大规模无边界乱序数据处理实践方法</p>
</div>
<div class="sect2">
<h3 id="_摘要">13.1. 摘要</h3>
<div class="paragraph">
<p>在日常商业运营中，无边界、乱序、大规模数据集越来越普遍了。(例如，网站日志，手机应用统计，传感器网络)。同时，对这些数据的消费需求也越来越复杂。比如说按事件发生时间序列处理数据，按数据本身的特征进行窗口计算等等。同时人们也越来越苛求立刻得到数据分析结果。然而，实践表明，我们永远无法同时优化数据处理的准确性、延迟程度和处理成本等各个维度。因此，数据工作者面临如何协调这些几乎相互冲突的数据处理技术指标的窘境，设计出来各种纷繁的数据处理系统和实践方法。</p>
</div>
<div class="paragraph">
<p>我们建议数据处理的方法必须进行根本性的改进。作为数据工作者，我们不能把无边界数据集(数据流)切分成有边界的数据，等待一个批次完整后处理。相反地，我们应该假设我们永远无法知道数据流是否终结，何时数据会变完整。唯一应该确信的是，新的数据会源源不断而来，老的数据可能会被撤销或更新。而能够让数据工作者应对这个挑战的唯一可行的方法是通过一个遵守原则的抽象来平衡折衷取舍数据处理的准确性、延迟程度和处理成本。在这篇论文中，我们提出了Dataflow模型，并详细地阐述了它的语义，设计的核心原则，以及在实践开发过程中对模型的检验。</p>
</div>
</div>
<div class="sect2">
<h3 id="_简介">13.2. 简介</h3>
<div class="paragraph">
<p>现代数据处理是一个复杂而又令人兴奋的领域。MapReduce和它的衍生系统(如Hadoop, Pig, Hive, Spark等)解决了处理数据的"量"上的问题。流处理SQL上社区也做了很多的工作(如查询系统，窗口，数据流，时间维度，语义模型)。在低延时处理上Spark Streaming, MillWheel, Storm等做了很多尝试。数据工作者现在拥有了很多强有力的工具把大规模无序的数据加工成结构化的数据，而结构化的数据拥有远大于原始数据的价值。但是我们仍然认为现存的模型和方法在处理一些常见的场景时有心无力。</p>
</div>
<div class="paragraph">
<p>考虑一个例子：一家流媒体平台提供商通过视频广告，向广告商收费把视频内容进行商业变现。收费标准按广告收看次数、时长来计费。这家流媒体的平台支持在线和离线播放。流媒体平台提供商希望知道每天向广告商收费的金额，希望按视频和广告进行汇总统计。另外，他们想在大量的历史离线数据上进行历史数据分析，进行各种实验。</p>
</div>
<div class="paragraph">
<p>广告商和内容提供者想知道视频被观看了多少次，观看了多长时间，视频被播放时投放了哪个广告，或者广告播放是投放在哪个视频内容中，观看的人群统计分布是什么。广告商也很想知道需要付多少钱，而内容提供者想知道赚到了多少钱。而他们需要尽快得到这些信息，以便调整预算/调整报价，改变受众，修正促销方案，调整未来方向。所有这些越实时越好，因涉及到金额，准确性是至关重要的。</p>
</div>
<div class="paragraph">
<p>尽管数据处理系统天生就是复杂的，视频平台还是希望一个简单而灵活的编程模型。最后，由于他们基于互联网的业务遍布全球，他们需要的系统要能够处理分散在全球的数据。</p>
</div>
<div class="paragraph">
<p>上述场景需要计算的指标包括每个视频观看的时间和时长，观看者、视频内容和广告是如何组合的(即按用户，按视频的观看"会话")。概念上这些指标都非常直观，但是现有的模型和系统并无法完美地满足上述的技术要求。</p>
</div>
<div class="paragraph">
<p>批处理系统如MapReduce(包括Hadoop的变种，如Pig，Hive)，FlumeJava, Spark等无法满足时延的要求，因为批处理系统需要等待收集所有的数据成一个批次后才开始处理。对有些流处理系统来说，目前不了解它们在大规模使用的情况下是否还能保持容错性(如(Aurora, TelegraphCQ, Niagara, Esper)，而那些提供了可扩展性和容错性的系统则缺乏准确性或语义的表达性。很多系统缺乏“恰好处理一次”的语义(如Storm, Samza, Pulsar)影响了数据的准确性。或者提供了窗口但语义局限于基于记录数或基于数据处理时间的窗口(Spark Streamming, Sonora, Trident)。而大多数提供了基于事件发生时间窗口的，或者依赖于消息必须有序(SQLStream)或者缺乏按事件发生时间触发窗口计算的语义(Stratosphere/Flink)。CEDR和Trill可能值得一提，它们不仅提供了有用的标记触发语义，而且提供了一种增量模型，这一点上和我们这篇论文一致，但它们的窗口语义无法有效地表达基于会话的窗口。它们基于标记的触发语义也无法有效处理3.3节中的某些场景。MillWheel和Spark Streaming的可扩展性良好，容错性不错，低延时，是一种合理的方案，但是对于会话窗口缺乏一种直观的高层编程模型。我们发现只有Pulsar系统对非对齐窗口(译者注：指只有部分记录进入某一特定窗口，会话窗口就是一种非对齐窗口)提供了高层次语义抽象，但是它缺乏对数据准确性的保证。Lambda架构能够达到上述的大部分要求，但是系统体系太过复杂，必须构建和维护两套系统(译者注：指离线和在线系统)。Summingbird改善了Lambda体系的复杂性，提供了针对批处理和流处理系统的一个统一封装抽象，但是这种抽象限制了能支持的计算的种类，并且仍然需要维护两套系统，运维复杂性仍然存在。</p>
</div>
<div class="paragraph">
<p>上述的问题并非无药可救，这些系统在活跃的发展中终究会解决这些问题。但是我们认为所有这些模型和系统(除了CEDR和Trill)存在一个比较大的问题。这个问题是他们假设输入数据(不管是无边界或者有边界的)在某个时间点后会变完整。我们认为这种假设是有根本性的问题。我们面临的一方面是庞大无序的数据，另一方面是数据消费者复杂的语义和时间线上的各种需求。对于当下如此多样化和多变的数据使用用例(更别说那些浮现在地平线上的, 译者注：应该是指新的，AI时代的到来带来的对数据使用的新玩法)，我们认为任何一种有广泛实用价值的方法必须提供简单，强有力的工具，可以为手上某个具体的使用案例平衡数据的准确性、延迟程度和处理成本(译者注：意指对某些用例可能需要低延迟更多，某些用例需要准确性更多。而一个好的工具需要能够动态根据用户的使用场景、配置进行适应，具体的技术细节由工具本身消化)。最后，我们认为需要摆脱目前一个主流的观点，认为执行引擎负责描述系统的语义。合理设计和构建的批，微批次，流处理系统能够保证同样程度的准确性。而这三种系统在处理无边界数据流时都非常常见。如果我们抽象出一个具有足够普遍性，灵活性的模型，那么执行引擎的选择就只是延迟程度和处理成本之间的选择。</p>
</div>
<div class="paragraph">
<p>从这个方面来说，这篇论文的概念性贡献在于提出了一个统一的模型能够</p>
</div>
<div class="ulist">
<ul>
<li>
<p>对无边界，无序的数据源，允许按数据本身的特征进行窗口计算，得到基于事件发生时间的有序结果，并能在准确性、延迟程度和处理成本之间调整。</p>
</li>
<li>
<p>解构数据处理管道的四个相关维度，使得它们透明地，灵活地进行组合。</p>
<div class="ulist">
<ul>
<li>
<p>计算什么结果</p>
</li>
<li>
<p>按事件发生时间计算</p>
</li>
<li>
<p>在流计算处理时间时被真正触发计算</p>
</li>
<li>
<p>早期的计算结果如何在后期被修正</p>
</li>
</ul>
</div>
</li>
<li>
<p>分离数据处理的计算逻辑表示和对逻辑的物理实现，使得对批处理，微批处理，流计算引擎的选择成为简单的对准确性、延迟程度和处理成本之间的选择。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>具体来说，上述的贡献包含：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>一个支持非对齐事件发生时间窗口的模型，一组简单的窗口创建和使用的API。（参考2.2）</p>
</li>
<li>
<p>一个根据数据处理管道特征来决定计算结果输出次数的触发模型。一组强有力而灵活的描述触发语义的声明式API。</p>
</li>
<li>
<p>能把数据的更新和撤回和上述窗口、触发模型集成的增量处理模型。（2.3）</p>
</li>
<li>
<p>基于MillWheel流处理引擎和FlumeJava批处理引擎的可扩展实现。为Google Cloud Dataflow重写了外部实现，并提供了一个开源的运行引擎不特定的SDK。（3.1）</p>
</li>
<li>
<p>指导模型设计的一组核心设计原则。</p>
</li>
<li>
<p>Google在处理大规模无边界乱序数据流的处理经验，这也是驱动我们开发这套模型的原因。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>最后，不足为奇地，这个模型没有任何魔术效果。那些现有的强一致性批处理系统，微批处理系统，流处理系统，Lambda系统所无法计算的东西仍然无法解决。CPU, RAM, Disk的内在约束依然存在。我们所提供的是一个能够简单地定义表达并行计算的通用框架。这种表达的方式和底层的执行引擎无关，同时针对任何特定的问题域，提供了根据手上数据和资源的情况来精确地调整延时程度和准确性的能力。从这一点上来说，这个模型的目标是简化大规模数据处理管道的构建。</p>
</div>
<div class="sect3">
<h4 id="_无边界有边界与流处理批处理">13.2.1. 无边界、有边界与流处理、批处理</h4>
<div class="paragraph">
<p>(本论文中)当描述无限/有限数据集时，我们更愿意使用有边界/无边界这组词汇，而不是流/批。因为流/批可能意味着使用某种特定的执行引擎。在现实中，无边界数据集可以用批处理系统反复调度来处理，而良好设计的流处理系统也可以完美地处理有边界数据集。从这个模型的角度来看，区分流/批的意义是不大的，因此我们保留这组词汇(流、批)用来专指执行引擎。</p>
</div>
</div>
<div class="sect3">
<h4 id="_窗口">13.2.2. 窗口</h4>
<div class="paragraph">
<p>窗口操作把一个数据集切分为有限的数据片以便于聚合处理。当面对无边界的数据时，有些操作需要窗口(以定义大多数聚合操作需要的边界：汇总，外链接，以时间区域定义的操作；如最近5分钟xx等)。另一些则不需要(如过滤，映射，内链接等)。对有边界的数据，窗口是可选的，不过很多情况下仍然是一种有效的语义概念(如回填一大批的更新数据到之前读取无边界数据源处理过的数据, 译者注：类似于Lambda架构)。窗口基本上都是基于时间的；不过也有些系统支持基于记录数的窗口。这种窗口可以认为是基于一个逻辑上的时间域，该时间域中的元素包含顺序递增的逻辑时间戳。窗口可以是对齐的，也就是说窗口应用于所有落在窗口时间范围内的数据。也可以是非对齐的，也就是应用于部分特定的数据子集(如按某个键值筛选的数据子集)。图一列出了处理无边界数据时常见的三种窗口。</p>
</div>
<div class="paragraph">
<p>固定窗口(有时叫翻滚窗口)是按固定窗口大小定义的，比如说小时窗口或天窗口。它们一般是对齐窗口，也就是说，每个窗口都包含了对应时间段范围内的所有数据。有时为了把窗口计算的负荷均匀分摊到整个时间范围内，有时固定窗口会做成把窗口的边界的时间加上一个随机数，这样的固定窗口则变成了不对齐窗口。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/windowpattern.png" alt="windowpattern">
</div>
</div>
<div class="paragraph">
<p>滑动窗口按窗口大小和滑动周期大小来定义，比如说小时窗口，每一分钟滑动一次。这个滑动周期一般比窗口大小小，也就是说窗口有相互重合之处。滑动窗口一般也是对齐的；尽管上面的图为了画出滑动的效果窗口没有遮盖到所有的键，但其实五个滑动窗口其实是包含了所有的3个键，而不仅仅是窗口3包含了所有的3个键。固定窗口可以看做是滑动窗口的一个特例，即窗口大小和滑动周期大小相等。</p>
</div>
<div class="paragraph">
<p>会话是在数据的子集上捕捉一段时间内的活动。一般来说会话按超时时间来定义，任何发生在超时时间以内的事件认为属于同一个会话。会话是非对齐窗口。如上图，窗口2只包含key 1，窗口3则只包含key 2。而窗口1和4都包含了key 3。(译者注：假设key是用户id，那么两次活动之间间隔超过了超时时间，因此系统需要重新定义一个会话窗口。)</p>
</div>
</div>
<div class="sect3">
<h4 id="_时间域">13.2.3. 时间域</h4>
<div class="paragraph">
<p>当处理包含事件发生时间的数据时，有两个时间域需要考虑。尽管已经有很多文献提到(特别是时间管理，语义模型，窗口，乱序处理，标记，心跳，水位标记，帧)，这里仍然重复一下，因为这个概念清晰之后2.3节会更易于理解。这两个时间域是：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>事件发生时间。事件发生时间是指当该事件发生时，该事件所在的系统记录下来的系统时间。</p>
</li>
<li>
<p>处理时间。处理时间是指在数据处理管道中处理数据时，一个事件被数据处理系统观察到的时间，是数据处理系统的时间。注意我们这里不假设在分布式系统中时钟是同步的。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>一个事件的事件发生时间是永远不变的，但是一个事件的处理时间随着它在数据管道中一步步被处理时持续变化的。这个区别是非常重要的，特别是我们需要根据事件的发生时间进行分析的时候。</p>
</div>
<div class="paragraph">
<p>在数据处理过程中，由于系统本身的一些现实影响(通信延迟，调度算法，处理时长，管道中间数据序列化等)会导致这两个时间存在差值且动态波动(见图2)。使用记录全局数据处理进度的标记、或水位标记，是一种很好的方式来可视化这个差值。在本论文中，我们采用一种类似MillWheel的水位标记，它是一个时间戳，代表小于这个时间戳的数据已经完全被系统处理了(通常用启发式方法建立)。我们之前曾经说过，数据已经被完全处理的标记经常和数据的准确性是相互冲突的，因此，我们不会太过于依赖于水位标记。不过，它确实是一种有用的手段。系统可以用它猜测所有事件发生时间早于水位标记的数据已经完全被观察到。应用可以用它来可视化处理时间差，也用它来监控系统总体的健康状况和总体处理进展，也可以用它来做一些不影响数据准确性的决策，比如基本垃圾回收策略等。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/timedomainskew.png" alt="timedomainskew">
</div>
</div>
<div class="paragraph">
<p>(译者注：假设事件发生系统和数据处理系统的时钟完全同步)在理想的情况下，两个时间的差值应该永远为零；事件一旦发生，我们就马上处理掉。现实则更像图2那样。从12点开始，由于数据处理管道的延迟，水位标记开始偏离真实时间，12:02时则靠近回来，而12:03的时候延迟变得更大。在分布式数据处理系统里，这种偏差波动非常普遍，在考虑数据处理系统如何提供一个正确的，可重复的结果时，把这种情况纳入考虑很关键。</p>
</div>
<div class="paragraph">
<p>水位标记的建立</p>
</div>
<div class="paragraph">
<p>对大多数现实世界中分布式数据集，系统缺乏足够的信息来建立一个100%准确的水位标记。举例来说，在视频观看"会话"的例子中，考虑离线观看。如果有人把他们的移动设备带到野外，系统根本没有办法知道他们何时会回到有网络连接的地带，然后开始上传他们在没有网络连接时观看视频的数据。因此，大多数的水位定义是基于有限的信息启发式地定义。对于带有未处理数据的元数据的结构化输入源，比如说日志文件(译者注：可能应该不是泛指一般的日志文件)，水位标记的猜测明显要准确些，因此大多数情况下可以作为一个处理完成的估计。另外，很重要的一点，一旦水位标记建立之后，它可以被传递到数据处理管道的下游(就像标记(Punctuation)那样, 译者注：类似于Flink的checkpoint barrier)。当然下游要明确知道这个水位标记仍然是一个猜测。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_dataflow模型_2">13.3. DataFlow模型</h3>
<div class="paragraph">
<p>在这一个小节中，我们将定义正式的系统模型。我们还会解释为什么它的语义足够泛化，能涵盖标准的批处理，微批次处理，流处理，以及混合了流批语义的Lambda架构。代码示例是基于Dataflow的Java SDK的一个简化版本，是从FlumeJava API演化而来。</p>
</div>
<div class="sect3">
<h4 id="_核心编程模型">13.3.1. 核心编程模型</h4>
<div class="paragraph">
<p>我们先从经典的批处理模型开始来考虑我们的核心编程模型。Dataflow SDK把所有的数据抽象为键值对，对键值对有两个核心的数据转换操作：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>ParDo 用来进行通用的并行化处理。每个输入元素(这个元素本身有可能是一个有限的集合)都会使用一个UDF进行处理(在Dataflow中叫做DoFn)，输出是0或多个输出元素。这个例子是把键的前缀进行展开，然后把值复制到展开后的键构成新的键值对并输出。</p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="images/pardo.png" alt="pardo">
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>GroupByKey用来按键值把元素重新分组</p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="images/groupbykey.png" alt="groupbykey">
</div>
</div>
<div class="paragraph">
<p>ParDo操作因为是对每个输入的元素进行处理，因此很自然地就可以适用于无边界的数据。而GroupByKey操作，在把数据发送到下游进行汇总前，需要收集到指定的键对应的所有数据。如果输入源是无边界的，那么我们不知道何时才能收集到所有的数据。所以通常的解决方案是对数据使用窗口操作。</p>
</div>
</div>
<div class="sect3">
<h4 id="_窗口_2">13.3.2. 窗口</h4>
<div class="paragraph">
<p>支持聚合操作的系统经常把GroupByKey操作重新定义成为GroupByKeyAndWindow操作。我们在这一点上的主要贡献是支持非对齐窗口。这个贡献包含两个关键性的洞见：第一是从模型简化的角度上，把所有的窗口策略都当做非对齐窗口，而底层实现来负责把对齐窗口作为一个特例进行优化。第二点是窗口操作可以被分隔为两个互相相关的操作：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>set&lt;Window&gt; AssignWindows(T datum)即窗口分配操作。这个操作把元素分配到0或多个窗口中去。这个也就是Li在[22]中提到的桶操作符。</p>
</li>
<li>
<p>set&lt;window&gt; MergeWindows(Set&lt;Window&gt;  windows)即窗口合并操作，这个操作在汇总时合并窗口。这使得数据驱动的窗口在随着数据到达的过程中逐渐建立起来并进行汇总操作。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>对于任何一种窗口策略，这两种操作都是密切相关的。滑动窗口分配需要滑动窗口合并，而会话窗口分配需要会话窗口合并。</p>
</div>
<div class="paragraph">
<p>注意，为了原生地支持事件发生时间窗口，我们现在定义系统中传递的数据不再仅仅是键值对(key, value)，而是一个四元组(key, value, event_time, window)。数据进入系统时需要自带事件发生时间戳(后期在管道处理过程中也可以修改)，然后初始化分配一个默认的覆盖所有事件发生时间的全局窗口。而全局窗口语义默认等同于标准的批处理模型。</p>
</div>
<div class="sect4">
<h5 id="_窗口分配">窗口分配</h5>
<div class="paragraph">
<p>从模型角度来说，把一条数据分配给某几个窗口意味着把这条数据复制给了这些窗口。以图3为例，它是把两条记录分配给一个2分钟宽，每一分钟滑动一次的窗口。(简单起见，时间戳用HH:MM的格式给出)</p>
</div>
<div class="paragraph">
<p>在这个例子中，两条数据在两个窗口中冗余存在，因而最后变成了四条记录。另外注意一点，窗口是直接关联到数据元素本身的，因此，窗口的分配可以在处理管道的聚合发生前的任何一处进行。这一点很重要，因为聚合操作有可能是下游复杂组合数据转换的一个子操作。(如Sum.integersPerKey, 译者注：下文会提到，这个转换是指键值对中的值为整形，把整形值按键进行求和)。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/windowassignment.png" alt="windowassignment">
</div>
</div>
</div>
<div class="sect4">
<h5 id="_窗口合并">窗口合并</h5>
<div class="paragraph">
<p>窗口合并作为GroupByKeyAndWindow的一部分出现，要解释清楚的话，我们最好拿例子来阐述。我们拿会话窗口来作为例子，因为会话窗口正是我们想要解决的用例之一。图4展示了例子数据4条，3条包含的键是k1，一条是k2，窗口按会话窗口组织，会话的过期时间是30分钟。所有4条记录初始时都属于默认的全局窗口。AssignWindows的会话窗口实现把每个元素都放入一个30分钟长的单个窗口，这个窗口的时间段如果和另外一个窗口的时间段相互重合，则意味着这两个窗口应该属于同一个会话。AssignWindows后是GroupByKeyAndWindow的操作，这个操作其实由五个部分组成：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>DropTimestamps – 删除数据上的时间戳，因为窗口合并后，后续的计算只关心窗口。</p>
</li>
<li>
<p>GroupByKey – 把(值, 窗口)二元组按键进行分组</p>
</li>
<li>
<p>MergeWindows – 窗口合并。把同一个键的(值, 窗口)进行窗口合并。具体的合并方式取决于窗口策略。在这个例子中，窗口v1和v4重叠，因此会话窗口策略把这两个窗口合并为一个新的，更长的会话窗口。(如粗体所示)</p>
</li>
<li>
<p>GroupAlsoByWindow – 对每个键，把值按合并后的窗口进行进一步分组。在本例中，由于v1和v4已经合并进了同一个窗口，因此这一步里面v1和v4被分到了同一组。</p>
</li>
<li>
<p>ExpandToElements – 把已经按键，按窗口分好组的元素扩展成(键, 值, 事件发生时间, 窗口)四元组。这里的时间戳是新的按窗口的时间戳。在这个例子里我们取窗口的结束时间作为这条记录的时间戳，但任何大于或等于窗口中最老的那条记录的时间戳都认为是符合水位标记正确性的。</p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="images/windowmerging.png" alt="windowmerging">
</div>
</div>
</div>
<div class="sect4">
<h5 id="_api">API</h5>
<div class="paragraph">
<p>下面我们使用Cloud Dataflow SDK来展示使用窗口操作的例子。</p>
</div>
<div class="paragraph">
<p>下面是计算对同一个键的整型数值求和</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="java"><span></span><span class="tok-n">PCollection</span><span class="tok-o">&lt;</span><span class="tok-n">KV</span><span class="tok-o">&lt;</span><span class="tok-n">String</span><span class="tok-o">,</span> <span class="tok-n">Integer</span><span class="tok-o">&gt;&gt;</span> <span class="tok-n">input</span> <span class="tok-o">=</span> <span class="tok-n">IO</span><span class="tok-o">.</span><span class="tok-na">read</span><span class="tok-o">(...);</span>
<span class="tok-n">PCollection</span><span class="tok-o">&lt;</span><span class="tok-n">KV</span><span class="tok-o">&lt;</span><span class="tok-n">String</span><span class="tok-o">,</span> <span class="tok-n">Integer</span><span class="tok-o">&gt;&gt;</span> <span class="tok-n">output</span> <span class="tok-o">=</span> <span class="tok-n">input</span><span class="tok-o">.</span><span class="tok-na">apply</span><span class="tok-o">(</span><span class="tok-n">Sum</span><span class="tok-o">.</span><span class="tok-na">integersPerKey</span><span class="tok-o">());</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>假如说要对30分钟长的会话窗口进行同样的计算，那么只要在求和前增加一个window.into调用就可以了</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="java"><span></span><span class="tok-n">PCollection</span><span class="tok-o">&lt;</span><span class="tok-n">KV</span><span class="tok-o">&lt;</span><span class="tok-n">String</span><span class="tok-o">,</span> <span class="tok-n">Integer</span><span class="tok-o">&gt;&gt;</span> <span class="tok-n">input</span> <span class="tok-o">=</span> <span class="tok-n">IO</span><span class="tok-o">.</span><span class="tok-na">read</span><span class="tok-o">(...);</span>
<span class="tok-n">PCollection</span><span class="tok-o">&lt;</span><span class="tok-n">KV</span><span class="tok-o">&lt;</span><span class="tok-n">String</span><span class="tok-o">,</span> <span class="tok-n">Integer</span><span class="tok-o">&gt;&gt;</span> <span class="tok-n">output</span> <span class="tok-o">=</span> <span class="tok-n">input</span>
  <span class="tok-o">.</span><span class="tok-na">apply</span><span class="tok-o">(</span><span class="tok-n">Window</span><span class="tok-o">.</span><span class="tok-na">into</span><span class="tok-o">(</span><span class="tok-n">Sessions</span><span class="tok-o">.</span><span class="tok-na">withGapDuration</span><span class="tok-o">(</span> <span class="tok-n">Duration</span><span class="tok-o">.</span><span class="tok-na">standardMinutes</span><span class="tok-o">(</span><span class="tok-mi">30</span><span class="tok-o">))))</span>
  <span class="tok-o">.</span><span class="tok-na">apply</span><span class="tok-o">(</span><span class="tok-n">Sum</span><span class="tok-o">.</span><span class="tok-na">integersPerKey</span><span class="tok-o">());</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_触发器和增量处理">13.3.3. 触发器和增量处理</h4>
<div class="paragraph">
<p>构建非对齐的事件发生时间窗口是一个进步，不过我们还有两个问题需要解决</p>
</div>
<div class="ulist">
<ul>
<li>
<p>我们需要提供基于记录和基于处理时间的窗口。否则我们会和现有的其他系统的窗口语义不兼容。</p>
</li>
<li>
<p>我们需要知道何时把窗口计算结果发往下游。由于数据事件发生时间的无序性，我们需要某种其他的信号机制来明确窗口已经完结(译者注：就是说，窗口所应该包含的数据已经完全到达并且被窗口观察到，包含到)。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>关于第一点，基于记录数和基于处理时间的窗口，我们会在2.4里解决。而眼下需要讨论建立一个保证窗口完整性的方法。提到窗口完整性，一个最开始的想法是使用某种全局事件发生时间进展机制，比如水位标记来解决。然而，水位标记本身对数据处理的准确性有两个主要的影响:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>水位标记可能设置的过短，因此在水位标记达到后仍然有记录到达。对于分布式的数据源头来说，很难去推断出一个完全完美的事件发生时间水位标记，因此无法完全依赖于水位标记，否则我们无法达到100%的准确性。</p>
</li>
<li>
<p>水位标记可能设置的过长。因为水位标记是全局性的进度指标，只要一个迟到的数据项就能影响到整个数据处理管道的水位标记。就算是一个正常工作的数据处理管道，它的处理延迟波动很小，受输入源的影响，这种延迟的基准仍然可能有几分钟甚至更高。因此，使用水位标记作为窗口完整信号并触发窗口计算结果很可能导致整个处理结果比Lambda架构有更高的延迟。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>由于上述的原因，我们认为光使用水位标记是不够的。从Lambda架构中我们获得了规避完整性问题的启发：它不是尽快地提供完全准确的答案，而是说，它先是尽快通过流式处理管道提供一个最佳的低延迟估计，同时承诺最终会通过批处理管道提供正确的和一致的答案(当然前提条件是批处理作业启动时，需要的数据应该已经全部到达了；如果数据后期发生了变化，那么批处理要重新执行以获得准确答案)。如果我们要在一个单一的数据处理管道里做到同样的事情(不管采用哪种执行引擎)，那么我们需要一种对任一窗口能够提供多种答案(或者可以叫做窗格, 译者注：对窗口这个比喻的引申)的方式。我们把这种功能叫做“触发器”。这种"触发器"可以选择在何时触发指定窗口的输出结果。</p>
</div>
<div class="paragraph">
<p>简单来说，触发器是一种受内部或者外信号激励的激发GroupByKeyAndWindow执行并输出执行结果的机制。他们对窗口模型是互补的，各自从不同的时间维度上影响系统的行为：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>窗口 决定哪些事件发生时间段(where)的数据被分组到一起来进行聚合操作</p>
</li>
<li>
<p>触发 决定在什么处理时间(when)窗口的聚合结果被处理输出成一个窗格</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>我们的系统提供了基于窗口的完成度估计的预定义触发器。(完成度估计基于水位标记。完成度估计也包括水位标记完成百分位。它提供了一种有效的处理迟到记录的语义，而且在批处理和流处理引擎中都适用。允许使用者处理少量的一部分的记录来快速获得结果，而不是痴痴地等待最后的一点点数据到来)。触发器也有基于处理时间的，基于数据抵达状况的(如记录数，字节数，数据到达标记(punctuations)，模式匹配等)。我们也支持对基础触发器进行逻辑组合(与，或)，循环，序列和其他一些复合构造方法。另外，用户可以基于执行引擎的元素(如水位计时器，处理时间计时器，数据到达，复合构造)和任意的外部相关信号(如数据注入请求，外部数据进展指标，RPC完成回调等)自定义触发器。在2.4里我们会更详细地看一些具体的例子。</p>
</div>
<div class="paragraph">
<p>除了控制窗口结果计算何时触发，触发器还提供了三种不同的模式来控制不同的窗格(计算结果)之间是如何相互关联的。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>抛弃 窗口触发后，窗口内容被抛弃，而之后窗口计算的结果和之前的结果不存在相关性。当下游的数据消费者(不管是数据处理管道的内部还是外部)希望触发计算结果之间相互独立(比如对插入的数据进行求和的场景)，那么这种情况就比较适用。另外，抛弃因为不需要缓存历史数据，因此对比其他两种模式，抛弃模式在状态缓存上是最高效的。不过累积性的操作可以建模成Dataflow的Combiner，对窗口状态管理可以用增量的方式处理。对我们视频观看会话的用例来说，抛弃模式是不够的，因为要求下游消费者只关心会话的部分数据是不合理的。</p>
</li>
<li>
<p>累积：触发后，窗口内容被完整保留住持久化的状态中，而后期的计算结果成为对上一次结果的一个修正的版本。这种情况下，当下游的消费者收到同一个窗口的多次计算结果时，会用新的计算结果覆盖掉老的计算结果。这也是Lambda架构使用的方式，流处理管道产出低延迟的结果，之后被批处理管道的结果覆盖掉。对视频会话的用例来说，如果我们把会话窗口的内容进行计算然后把结果直接写入到支持更新的输出源(如数据库或者键值存储)，这种方案是足够的了。</p>
</li>
<li>
<p>累积和撤回：触发后，在进行累积语义的基础上，计算结果的一份复制也被保留到持久化状态中。当窗口将来再次触发时，上一次的结果值先下发做撤回处理，然后新的结果作为正常数据下发。如果数据处理管道有多个串行的GroupByKeyAndWindow操作时，撤回是必要的，因为同一个窗口的不同触发计算结果可能在下游会被分组到不同键中去。在这种情况下，除非我们通过一个撤回操作，撤回上一次聚合操作的结果，否则下游的第二次聚合操作会产生错误的结果。Dataflow的combiner操作是支持撤回的，只要调用uncombine方法就可以进行撤回。而对于视频会话用例来说，这种模型是非常理想的。比如说，如果我们在下游从会话创建一开始，我们就基于会话的某些属性进行汇总统计，例如检查不受欢迎的广告(比如说在很多会话中这个广告的被观察时长不长于5秒)。早期的计算结果随着输入的增加(比如说原来在野外观看视频的用户已经回来了并上传了他们的日志)可能变得无效。对于包含多个阶段的聚合操作的复杂数据处理管道，撤回方式帮助我们应对源头数据的变化，得到正确的数据处理结果。(简单的撤回实现只能支持确定性的计算，而非确定性计算的支持需要更复杂，代价也更高。我们已经看到这样的使用场景，比如说概率模型, 译者注：比如说基于布隆过滤器的UV统计)。</p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="images/eventtime.png" alt="eventtime">
</div>
</div>
<div class="paragraph">
<p>很多例子都要考虑水位线，因此我们的图当中也包括了理想的水位线，也包括了实际的水位线。直的虚线代表了理想的水位线，即，事件发生时间和数据处理时间不存在任何延迟，所有的数据一产生就马上消费了。不过考虑到分布式系统的不确定性，这两个时间之间有偏差是非常普遍的。在图5中，实际的水位线(黑色弯曲虚线)很好的说明了这一点。另外注意由于实际的水位线是猜测获得的，因此有一个迟到比较明显的数据点落在了水位线的后面。</p>
</div>
<div class="paragraph">
<p>如果我们在传统的批处理系统中构建上述的对数据进行求和的数据处理管道，那么我们会等待所有的数据到达，然后聚合成一个批次(因为我们现在假设所有的数据拥有同样的键)，再进行求和，得到了结果51。如图6所示黑色的长方形是这个运算的示意图。长方形的区域代表求和运算涵盖的处理时间和参与运算的数据的事件发生时间区间。长方形的上沿代表计算发生，获得结果的管道处理时间点。因为传统的批处理系统不关心数据的事件发生时间，所有的数据被涵盖在一个大的全局性窗口中，因此包含了所有事件发生时间内的数据。而且因为管道的输出在收到所有数据后只计算一次，因此这个输出包含了所有处理时间的数据(译者注：处理时间是数据系统观察到数据的时间，而不是运算发生时的时间。)</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/batchexecution.png" alt="batchexecution">
</div>
</div>
<div class="paragraph">
<p>注意上图中包含了水位线。尽管在传统批处理系统中不存在水位线的概念，但是在语义上我们仍然可以引入它。批处理的水位线刚开始时一直停留不动。直到系统收到了所有数据并开始处理，水位线近似平行于事件发生时间轴开始平移，然后一直延伸到无穷远处。我们之所以讨论这一点，是因为如果让流处理引擎在收到所有数据之后启动来处理数据，那么水位线进展和传统批处理系统是一模一样的。(译者注：这提示我们其实水位线的概念可以同样适用于批处理)</p>
</div>
<div class="paragraph">
<p>现在假设我们要把上述的数据处理管道改造成能够接入无边界数据源的管道。在Dataflow模型中，默认的窗口触发方式是当水位线移过窗口时吐出窗口的执行结果。但如果对一个无边界数据源我们使用了全局性窗口，那么窗口就永远不会触发(译者注：因为窗口的大小在不停地扩大)。因此，我们要么用其他的触发器触发计算(而不是默认触发器)，或者按某种别的方式开窗，而不是一个唯一的全局性窗口。否则，我们永远不会获得计算结果输出。</p>
</div>
<div class="paragraph">
<p>我们先来尝试改变窗口触发方式，因为这会帮助我们产生概念上一致的输出(一个全局的包含所有时间的按键进行求和)，周期性地输出更新的结果。在这个例子中，我们使用了Window.trigger操作，按处理时间每分钟周期性重复触发窗口的计算。我们使用累积的方式对窗口结果进行修正(假设结果输出到一个数据库或者KV数据库，因而新的结果会持续地覆盖之前的计算结果)。这样，如图7所示，我们每分钟(处理时间)产生更新的全局求和结果。注意图中半透明的输出长方形是相互重叠的，这是因为累积窗格处理机制计算时包含了之前的窗口内容。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="java"><span></span><span class="tok-n">PCollection</span><span class="tok-o">&lt;</span><span class="tok-n">KV</span><span class="tok-o">&lt;</span><span class="tok-n">String</span><span class="tok-o">,</span> <span class="tok-n">Integer</span><span class="tok-o">&gt;&gt;</span> <span class="tok-n">output</span> <span class="tok-o">=</span> <span class="tok-n">input</span>
    <span class="tok-o">.</span><span class="tok-na">apply</span><span class="tok-o">(</span><span class="tok-n">Window</span><span class="tok-o">.</span><span class="tok-na">trigger</span><span class="tok-o">(</span><span class="tok-n">Repeat</span><span class="tok-o">(</span><span class="tok-n">AtPeriod</span><span class="tok-o">(</span><span class="tok-mi">1</span><span class="tok-o">,</span> <span class="tok-n">MINUTE</span><span class="tok-o">)))</span>
    <span class="tok-o">.</span><span class="tok-na">accumulating</span><span class="tok-o">())</span>
    <span class="tok-o">.</span><span class="tok-na">apply</span><span class="tok-o">(</span><span class="tok-n">Sum</span><span class="tok-o">.</span><span class="tok-na">integersPerKey</span><span class="tok-o">());</span></code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="images/globalwindows.png" alt="globalwindows">
</div>
</div>
<div class="paragraph">
<p>如果我们想要求出每分钟的和的增量，那么我们可以使用窗格的抛弃模式，如图8所示。注意这是很多流处理引擎的处理时间窗口的窗口计算模式。窗格不再相互重合，因此窗口的结果包含了相互独立的时间区域内的数据。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="java"><span></span><span class="tok-n">PCollection</span><span class="tok-o">&lt;</span><span class="tok-n">KV</span><span class="tok-o">&lt;</span><span class="tok-n">String</span><span class="tok-o">,</span> <span class="tok-n">Integer</span><span class="tok-o">&gt;&gt;</span> <span class="tok-n">output</span> <span class="tok-o">=</span> <span class="tok-n">input</span>
    <span class="tok-o">.</span><span class="tok-na">apply</span><span class="tok-o">(</span><span class="tok-n">Window</span><span class="tok-o">.</span><span class="tok-na">trigger</span><span class="tok-o">(</span><span class="tok-n">Repeat</span><span class="tok-o">(</span><span class="tok-n">AtPeriod</span><span class="tok-o">(</span><span class="tok-mi">1</span><span class="tok-o">,</span> <span class="tok-n">MINUTE</span><span class="tok-o">)))</span>
    <span class="tok-o">.</span><span class="tok-na">discarding</span><span class="tok-o">())</span>
    <span class="tok-o">.</span><span class="tok-na">apply</span><span class="tok-o">(</span><span class="tok-n">Sum</span><span class="tok-o">.</span><span class="tok-na">integersPerKey</span><span class="tok-o">());</span></code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="images/discarding.png" alt="discarding">
</div>
</div>
<div class="paragraph">
<p>另外一种更健壮的处理时间窗口的实现方式，是把数据摄入时的数据到达时间作为数据的事件发生时间，然后使用事件发生时间窗口。这样的另一个效果是系统对流入系统的数据的事件发生时间非常清楚，因而能够生成完美的水位线，不会存在迟到的数据。如果数据处理场景中不关心真正的事件发生时间，或者无法获得真正的事件发生时间，那么采用这种方式生成事件发生时间是一种非常低成本且有效的方式。</p>
</div>
<div class="paragraph">
<p>在我们讨论其他类型的窗口前，我们先来考虑下另外一种触发器。一种常见的窗口模式是基于记录数的窗口。我们可以通过改变触发器为每多少条记录到达触发一次的方式来实现基于记录数的窗口。图9是一个以两条记录为窗口大小的例子。输出是窗口内相邻的两条记录之和。更复杂的记录数窗口(比如说滑动记录数窗口)可以通过定制化的窗口触发器来支持。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="java"><span></span><span class="tok-n">PCollection</span><span class="tok-o">&lt;</span><span class="tok-n">KV</span><span class="tok-o">&lt;</span><span class="tok-n">String</span><span class="tok-o">,</span> <span class="tok-n">Integer</span><span class="tok-o">&gt;&gt;</span> <span class="tok-n">output</span> <span class="tok-o">=</span> <span class="tok-n">input</span>
    <span class="tok-o">.</span><span class="tok-na">apply</span><span class="tok-o">(</span><span class="tok-n">Window</span><span class="tok-o">.</span><span class="tok-na">trigger</span><span class="tok-o">(</span><span class="tok-n">Repeat</span><span class="tok-o">(</span><span class="tok-n">AtCount</span><span class="tok-o">(</span><span class="tok-mi">2</span><span class="tok-o">)))</span>
    <span class="tok-o">.</span><span class="tok-na">discarding</span><span class="tok-o">())</span>
    <span class="tok-o">.</span><span class="tok-na">apply</span><span class="tok-o">(</span><span class="tok-n">Sum</span><span class="tok-o">.</span><span class="tok-na">integersPerKey</span><span class="tok-o">());</span></code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="images/atcount.png" alt="atcount">
</div>
</div>
<div class="paragraph">
<p>我们接下来考虑支持无边界数据源的其他选项，不再仅仅考虑全局窗口。一开始，我们来观察固定的2分钟窗口，累积窗格。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="java"><span></span><span class="tok-n">PCollection</span><span class="tok-o">&lt;</span><span class="tok-n">KV</span><span class="tok-o">&lt;</span><span class="tok-n">String</span><span class="tok-o">,</span> <span class="tok-n">Integer</span><span class="tok-o">&gt;&gt;</span> <span class="tok-n">output</span> <span class="tok-o">=</span> <span class="tok-n">input</span>
    <span class="tok-o">.</span><span class="tok-na">apply</span><span class="tok-o">(</span><span class="tok-n">Window</span><span class="tok-o">.</span><span class="tok-na">into</span><span class="tok-o">(</span><span class="tok-n">FixedWindows</span><span class="tok-o">.</span><span class="tok-na">of</span><span class="tok-o">(</span><span class="tok-mi">2</span><span class="tok-o">,</span> <span class="tok-n">MINUTES</span><span class="tok-o">)</span>
    <span class="tok-o">.</span><span class="tok-na">accumulating</span><span class="tok-o">())</span>
    <span class="tok-o">.</span><span class="tok-na">apply</span><span class="tok-o">(</span><span class="tok-n">Sum</span><span class="tok-o">.</span><span class="tok-na">integersPerKey</span><span class="tok-o">());</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这里没有定义触发器，那么系统采用的是默认触发器。相当于</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="java"><span></span><span class="tok-n">PCollection</span><span class="tok-o">&lt;</span><span class="tok-n">KV</span><span class="tok-o">&lt;</span><span class="tok-n">String</span><span class="tok-o">,</span> <span class="tok-n">Integer</span><span class="tok-o">&gt;&gt;</span> <span class="tok-n">output</span> <span class="tok-o">=</span> <span class="tok-n">input</span>
    <span class="tok-o">.</span><span class="tok-na">apply</span><span class="tok-o">(</span><span class="tok-n">Window</span><span class="tok-o">.</span><span class="tok-na">into</span><span class="tok-o">(</span><span class="tok-n">FixedWindows</span><span class="tok-o">.</span><span class="tok-na">of</span><span class="tok-o">(</span><span class="tok-mi">2</span><span class="tok-o">,</span> <span class="tok-n">MINUTES</span><span class="tok-o">))</span>
    <span class="tok-o">.</span><span class="tok-na">trigger</span><span class="tok-o">(</span><span class="tok-n">Repeat</span><span class="tok-o">(</span><span class="tok-n">AtWatermark</span><span class="tok-o">())))</span>
    <span class="tok-o">.</span><span class="tok-na">accumulating</span><span class="tok-o">())</span>
    <span class="tok-o">.</span><span class="tok-na">apply</span><span class="tok-o">(</span><span class="tok-n">Sum</span><span class="tok-o">.</span><span class="tok-na">integersPerKey</span><span class="tok-o">());</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>水位线触发器是指当水位线越过窗口底线时窗口被触发。我们这里假设批处理和流处理系统都实现了水位线(详见3.1)。Repeat代表的含义是如何处理迟到的数据。在这里Repeat意味着当有迟于水位线的记录到达时，窗口都会立即触发再次进行计算，因为按定义，此时水位线早已经越过窗口底线了。</p>
</div>
<div class="paragraph">
<p>图10-12描述了上述窗口在三种不同的数据处理引擎上运行的情况。首先我们来观察下批处理引擎上这个数据处理管道如何执行的。受限于我们当前的实现，我们认为数据源现在是有边界的数据源，而传统的批处理引擎会等待所有的数据到来。之后，我们会根据数据的事件发生时间处理，在模拟的水位线到达后窗口计算触发吐出计算结果。整个过程如图10所示：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/fixedwindowsbatch.png" alt="fixedwindowsbatch">
</div>
</div>
<div class="paragraph">
<p>然后来考虑一下微批次引擎，每分钟做一次批次处理。系统会每分钟收集输入的数据进行处理，反复重复进行。每个批次开始后，水位线会从批次的开始时间迅速上升到批次的结束时间(技术上来看基本上是即刻完成的，取决于一分钟内积压的数据量和数据处理管道的吞吐能力)。这样每轮微批次完成后系统会达到一个新的水位线，窗口的内容每次都可能会不同(因为有迟到的数据加入进来)，输出结果也会被更新。这种方案很好的兼顾了低延迟和结果的最终准确性。如图11所示：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/fixedwindowsmicrobatch.png" alt="fixedwindowsmicrobatch">
</div>
</div>
<div class="paragraph">
<p>接下来考虑数据管道在流处理引擎上的执行情况，如图12所示。大多数窗口在水位线越过它们之后触发执行。注意值为9的那个数据点在水位线之后到达。不管什么原因(移动设备离线，网络故障分区等)，系统并没有意识到那一条数据并没有到达，仍然提升了水位线并触发了窗口计算。当值为9的那条记录到达后，窗口会重新触发，计算出一个新的结果值。</p>
</div>
<div class="paragraph">
<p>如果说我们一个窗口只有一个输出，而且针对迟到的数据仅做一次的修正，那么这个计算方式还是不错的。不过因为窗口要等待水位线进展，整体上的延迟比起微批次系统可能要更糟糕，这就是我们之前在2.3里所说的，单纯依赖水位线可能引起的问题(水位线可能太慢)</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/fixedwindowsstreaming.png" alt="fixedwindowsstreaming">
</div>
</div>
<div class="paragraph">
<p>如果我们想降低整体的延迟，那么我们可以提供按数据处理时间的触发器进行周期性的触发，这样我们能够尽早得到窗口的计算结果，并且在随后得到周期性的更新，直到水位线越过窗口边界。参见图13。这样我们能够得到比微批次系统更低的延迟，因为数据一到达就进入了窗口随后就可能被触发，而不像在微批次系统里必须等待一个批次数据完全到达。假设微批次系统和流处理系统都是强一致的，那么我们选择哪种引擎，就是在能接受的延迟程度和计算成本之间的选择(对微批次系统也是批大小的选择)。这就是我们这个模型想要达到的目标之一。参见图13：固定窗口，流处理，部分窗格</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="java"><span></span><span class="tok-n">PCollection</span><span class="tok-o">&lt;</span><span class="tok-n">KV</span><span class="tok-o">&lt;</span><span class="tok-n">String</span><span class="tok-o">,</span> <span class="tok-n">Integer</span><span class="tok-o">&gt;&gt;</span> <span class="tok-n">output</span> <span class="tok-o">=</span> <span class="tok-n">input</span>
    <span class="tok-o">.</span><span class="tok-na">apply</span><span class="tok-o">(</span><span class="tok-n">Window</span><span class="tok-o">.</span><span class="tok-na">into</span><span class="tok-o">(</span><span class="tok-n">FixedWindows</span><span class="tok-o">.</span><span class="tok-na">of</span><span class="tok-o">(</span><span class="tok-mi">2</span><span class="tok-o">,</span> <span class="tok-n">MINUTES</span><span class="tok-o">))</span>
        <span class="tok-o">.</span><span class="tok-na">trigger</span><span class="tok-o">(</span><span class="tok-n">SequenceOf</span><span class="tok-o">(</span>
            <span class="tok-n">RepeatUntil</span><span class="tok-o">(</span>
                <span class="tok-n">AtPeriod</span><span class="tok-o">(</span><span class="tok-mi">1</span><span class="tok-o">,</span> <span class="tok-n">MINUTE</span><span class="tok-o">),</span>
                <span class="tok-n">AtWatermark</span><span class="tok-o">()),</span>
            <span class="tok-n">Repeat</span><span class="tok-o">(</span><span class="tok-n">AtWatermark</span><span class="tok-o">())))</span>
        <span class="tok-o">.</span><span class="tok-na">accumulating</span><span class="tok-o">())</span>
    <span class="tok-o">.</span><span class="tok-na">apply</span><span class="tok-o">(</span><span class="tok-n">Sum</span><span class="tok-o">.</span><span class="tok-na">integersPerKey</span><span class="tok-o">());</span></code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="images/fixedwindowsstreamingpartial.png" alt="fixedwindowsstreamingpartial">
</div>
</div>
<div class="paragraph">
<p>作为最后一个例子，我们来看一下如何支持之前提到的视频会话需求(为了保持例子之间的一致性，我们继续把求和作为我们的计算内容。改变成其他的聚合函数也是很容易的)。我们把窗口定义为会话窗口，会话超时时间为1分钟，并且支持回撤操作。这个例子也体现了我们把模型的四个维度拆开之后带来的灵活的可组合性(计算什么，在哪段事件发生时间里计算，在哪段处理时间里真正触发计算，计算产生的结果后期如何进行修正)。也演示了对之前的计算结果可以进行撤回是一个非常强力的工具，否则可能会让下游之前接收到的数据无法得到修正。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="java"><span></span><span class="tok-n">PCollection</span><span class="tok-o">&lt;</span><span class="tok-n">KV</span><span class="tok-o">&lt;</span><span class="tok-n">String</span><span class="tok-o">,</span> <span class="tok-n">Integer</span><span class="tok-o">&gt;&gt;</span> <span class="tok-n">output</span> <span class="tok-o">=</span> <span class="tok-n">input</span>
    <span class="tok-o">.</span><span class="tok-na">apply</span><span class="tok-o">(</span><span class="tok-n">Window</span><span class="tok-o">.</span><span class="tok-na">into</span><span class="tok-o">(</span><span class="tok-n">Sessions</span><span class="tok-o">.</span><span class="tok-na">withGapDuration</span><span class="tok-o">(</span><span class="tok-mi">1</span><span class="tok-o">,</span> <span class="tok-n">MINUTE</span><span class="tok-o">))</span>
        <span class="tok-o">.</span><span class="tok-na">trigger</span><span class="tok-o">(</span><span class="tok-n">SequenceOf</span><span class="tok-o">(</span>
            <span class="tok-n">RepeatUntil</span><span class="tok-o">(</span>
                <span class="tok-n">AtPeriod</span><span class="tok-o">(</span><span class="tok-mi">1</span><span class="tok-o">,</span> <span class="tok-n">MINUTE</span><span class="tok-o">),</span>
                <span class="tok-n">AtWatermark</span><span class="tok-o">()),</span>
            <span class="tok-n">Repeat</span><span class="tok-o">(</span><span class="tok-n">AtWatermark</span><span class="tok-o">())))</span>
        <span class="tok-o">.</span><span class="tok-na">accumulatingAndRetracting</span><span class="tok-o">())</span>
    <span class="tok-o">.</span><span class="tok-na">apply</span><span class="tok-o">(</span><span class="tok-n">Sum</span><span class="tok-o">.</span><span class="tok-na">integersPerKey</span><span class="tok-o">());</span></code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="images/sessionsretract.png" alt="sessionsretract">
</div>
</div>
<div class="paragraph">
<p>在这个例子中，我们首先接收到了数据5和数据7。由于5和7之间事件发生时间大于1分钟，因此被当做了两个会话。在第一次窗口被触发时，产生了两条计算结果，和分别为5和7。在第二个因处理时间引起的窗口触发时，我们接收到了数据3,4,3，并且第一个3和上一个7之间时间大于1分钟，因此被分组到一个新的会话窗口，窗口触发计算并输出了计算结果10。紧接着，数据8到达了。数据8的到达使得数据7,3,4,3,8合并成了一个大窗口。当水位线越过数据点8后，新窗口计算被触发。触发后需要先撤回之前两个小窗口的计算结果，撤回方式是往下游发送两条键为之前的两个会话标记，值为-7和-10的记录，然后发送一个新的值为25的新窗口计算结果。同样，当值为9的记录迟于水位线到达后，之前的所有7条记录都合并成了一个会话，因此要对之前的会话再次进行撤回。值为-5和-25的记录又被发送往下游，新的值为39的会话记录随后也被发往下游。</p>
</div>
<div class="paragraph">
<p>同样的操作在处理最后3条值为3,8,1的记录时也会发生，先是输出了结果值3，随后回撤了这个计算结果，输出了合并会话后的结果值12。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_实现和设计">13.4. 实现和设计</h3>
<div class="sect3">
<h4 id="_实现">13.4.1. 实现</h4>
<div class="paragraph">
<p>我们已经用FlumeJava实现了这个模型，使用MillWheel作为底层的流执行引擎；在本文写作的时候，针对公有云服务Cloud Dataflow的重新实现也接近完成。由于这些系统要么是谷歌的内部系统，要么是共有云服务，因此为简洁起见，实现的细节我们略掉了。可以提及的让人感兴趣的一点是，核心的窗口机制代码，触发机制代码是非常通用的，绝大部分都同时适用于批处理引擎实现和流处理引擎实现。这个实现本身也值得在将来进行更进一步的分析。</p>
</div>
</div>
<div class="sect3">
<h4 id="_设计原则">13.4.2. 设计原则</h4>
<div class="paragraph">
<p>尽管我们很多的设计其实是受到3.3节所描述的真实业务场景启发，我们在设计中也遵从了一系列的核心原则。这些原则我们认为是这个模型必须要遵循的。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>永远不要依赖任何的数据完整性标记(译者注：如水位标记)</p>
</li>
<li>
<p>灵活性，要能覆盖已知的多样化的使用用例，并且覆盖将来可能的使用用例</p>
</li>
<li>
<p>对于每个预期中的执行引擎，(模型抽象)不但要正确合理，而且要有额外的附加价值</p>
</li>
<li>
<p>鼓励实现的透明性</p>
</li>
<li>
<p>支持对数据在它们产生的上下文中进行健壮的分析。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>可以这么说，下述的使用案例决定了模型的具体功能，而这些设计原则决定了模型整体的特征和框架。我们认为这两者是我们设计的模型具有完全性，普遍性的根本原因。</p>
</div>
</div>
<div class="sect3">
<h4 id="_业务场景">13.4.3. 业务场景</h4>
<div class="paragraph">
<p>在我们设计Dataflow模型的过程中，我们考虑了FlumeJava和MillWheel系统在这些年遇到的各种真实场景。那些良好工作的设计，我们保留到了模型中，而那些工作不那么良好的设计激励我们采用新的方法重新设计。下面我们简单介绍一些影响过我们设计的场景。</p>
</div>
<div class="sect4">
<h5 id="_大规模数据回写和lambda架构统一模型">大规模数据回写和Lambda架构；统一模型</h5>
<div class="paragraph">
<p>有一些团队在MillWheel上跑日志链接作业。这其中有一个特别大的日志链接处理作业在MillWheel上按流模式运行，而另外一个单独的FlumeJava批处理作业用来对流处理作业的结果进行大规模的回写。一个更好的设计是使用一个统一的模型，对数据处理逻辑只实现一次，但是能够在流处理引擎和批处理引擎不经修改而同时运行。这是第一个激发我们思考去针对批处理，微批次处理和流处理建立一个统一模型的业务场景。这也是图10-12所展示的。</p>
</div>
<div class="paragraph">
<p>另外一个激发我们设计统一模型的场景是Lambda架构的使用。尽管谷歌大多数数据处理的场景是由批处理系统和流处理系统分别单独承担的，不过有一个MillWheel的内部客户在弱一致性的模式下运行他们的流处理作业，用一个夜间的MR作业来生产正确的结果。他们发现他们的客户不信任弱一致性的实时结果，被迫重新实现了一个系统来支持强一致性，这样他们就能提供可靠的，低延时的数据处理结果。这个场景进一步激励我们能支持灵活地选择不同的执行引擎。</p>
</div>
</div>
<div class="sect4">
<h5 id="_非对齐窗口会话">非对齐窗口：会话</h5>
<div class="paragraph">
<p>从一开始我们就知道我们需要支持会话；事实上这是我们窗口模型对现有模型而言一个重大的贡献。会话对谷歌来说是一个非常重要的使用场景(也是MillWheel创建的原因之一)。会话窗口在一系列的产品域中都有应用，如搜索，广告，分析，社交和YouTube。基本上任何关心把用户的分散活动记录进行相互关联分析都需要通过会话来进行处理。因此，支持会话成为我们设计中的最重要考虑。如图14所示，支持会话在Dataflow中是非常简单的。</p>
</div>
</div>
<div class="sect4">
<h5 id="_支付触发器累加和撤回">支付：触发器，累加和撤回</h5>
<div class="paragraph">
<p>有两个在MillWheel上跑支付作业的团队遇到的问题对模型的一部分也有启发作用。当时我们的设计实践是使用水位线作为数据完全到达的指标。然后写额外的逻辑代码来处理迟到的数据或者更改源头数据。由于缺乏一个支持更新和撤回的系统，负责资源利用率方案的团队最终放弃了我们的平台，构建了自己独立的解决方案(他们最后使用的模型和我们同时设计开发的模型事实上非常类似)。另一个支付团队的数据源头有少部分缓慢到达的数据，造成了水位线延迟，这给他们带来了大问题。这些系统上的缺陷成为我们对现有系统需要进行改良设计的重要动因，并且把我们的考虑点从保证数据的完整性转移到了对迟到数据的可适应性。对于这个场景的思考总结带来了两个方面：一个方面是能够精确，灵活地确定何时将窗口内容物化的触发器(如图7～图14所示)，对同样的输入数据集也可以使用多种多样地结果输出模式进行处理。另外一方面是通过累积和撤回能够支持增量处理。(图14)</p>
</div>
</div>
<div class="sect4">
<h5 id="_统计计算水位线触发器">统计计算：水位线触发器</h5>
<div class="paragraph">
<p>很多MillWheel作业用来进行汇总统计(如平均延迟)。对这些作业来说，100%的准确性不是必须的，但是在合理的时间范围内得到一个接近完整的统计是必须的。考虑到对于结构化的输入(如日志文件)，使用水位线就能达到很高程度的准确度。这些客户发现使用单次的的基于水位线的触发器就可以获得高度准确的统计。水位线触发器如图12所示。</p>
</div>
<div class="paragraph">
<p>我们有一些滥用检测的作业运行在MillWheel中。滥用检测是另外一种快速处理大部分数据比缓慢处理掉所有数据要远远更有价值的场景。因此，他们会大量地使用水位线百分位触发器。这个场景促使我们在模型中加入了对水位线百分位触发器的支持。</p>
</div>
<div class="paragraph">
<p>与此相关的，批处理作业中的一个痛点是部分处理节点的缓慢进度会成为执行时间中的长尾，拖慢整个进度。除了可以通过动态平衡作业来缓解这个问题，FlumeJava也支持基于整体完成百分度来选择是否终止长尾节点。用统一模型来描述批处理中遇到的这个场景的时候，水位线百分位触发器可以很自然地进行表达，不需要在引入额外的定制功能、定制接口。</p>
</div>
</div>
<div class="sect4">
<h5 id="_推荐处理时间触发器">推荐：处理时间触发器</h5>
<div class="paragraph">
<p>另外一种我们考虑过的场景是从大量的谷歌数据资产中构建用户活动树(本质上是会话树)。这些树用来根据用户的兴趣来做推荐。在这些作业中我们使用处理时间作为触发器。这是因为，对于用户推荐来说，周期性更新的，即便是基于不完备数据的用户活动树比起持续等待水位线越过会话窗口边界(即会话结束)获得完全的数据要有意义的多。这也意味着由于部分少量数据引起的水位线进展延迟不影响基于其他已经到达的数据进行计算并获得有效的用户活动树。考虑到这种场景，我们包含了基于处理时间的触发器(如图7和图8所示)</p>
</div>
</div>
<div class="sect4">
<h5 id="_异常探测数据驱动和组合触发器">异常探测：数据驱动和组合触发器</h5>
<div class="paragraph">
<p>在MillWheel的论文中，我们描述了一种用来检测谷歌网站搜索查询趋势的微分异常探测数据处理管道。当我们为模型设计触发器的时候，这种微分异常探测系统启发我们设计了数据驱动触发器。这种微分探测器检测网站检索流，通过统计学估计来计算搜索查询请求量是否存在一个毛刺。如果系统认为一个毛刺即将产生，系统将发出一个启动型号。当他们认为毛刺已经消除，那么他们会发出一个停止信号(译者注：可能会对接系统自动对系统扩容或缩容)。尽管我们可以采用别的方式来触发计算，比如说Trill的标点符(Punctuations)，但是对于异常探测你可能希望一旦系统确认有异常即将发生，系统应该立即输出这个判断。标点符的使用事实上把流处理系统转换成了微批次处理系统，引入了额外的延迟。在调查过一些用户场景后，我们认为标点符不完全适合我们。因此我们在模型中引入了可定制化数据驱动触发器。同时这个场景也驱使我们支持触发器组合，因为在现实场景中，一个系统可能在处理多种微分计算，需要根据定义的一组逻辑来支持多种多样的输出。图9中的AtCount触发器是数据驱动触发器的例子，而图10-14使用了组合触发器。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_总结">13.5. 总结</h3>
<div class="paragraph">
<p>数据处理的未来是无边界数据处理。 尽管有边界数据的处理永远都有着重要地位并且有用武之地，但是语义上它会被无边界数据处理模型所涵盖。一方面，无边界数据处理技术发展上步履蹒跚，另一方面对于数据进行处理并消费的要求在不断提高，比如说，需要对按事件发生时间对数据处理，或者支持非对齐窗口等。要发展能够支撑未来业务需要的数据处理系统，当前存在的系统和模型是一个非常好的基础，但我们坚持相信如果要完善地解决用户对无边界数据处理的需求，我们必须根本地改变我们的思维。</p>
</div>
<div class="paragraph">
<p>根据我们多年在谷歌处理大规模无边界数据的实践经验，我们相信我们提出的模型一个非常好的进展。它支持非对齐，事件发生时间窗口。这些都是当前用户所需要的。它提供了灵活的窗口触发机制，支持窗口累积和撤回，把关注点从寻求等待数据的完整性变为自动适应现实世界中持续变更的数据源。它对批处理，微批次，流处理提供了统一的抽象，允许数据开发人员灵活从三者中选择。同时，它避免了单一系统容易把系统本身的构建蔓延到数据处理抽象层面中去的问题。它的灵活性让数据开发者能根据使用场景恰当地平衡数据处理的准确性，成本和延迟程度。对于处理多样化的场景和需求来说，这一点很关键。最后，通过把数据处理的逻辑划分为计算什么，在哪个事件发生时间范围内计算，在什么处理时间点触发计算，如何用新的结果订正之前的数据处理结果让整个数据处理逻辑透明清晰。我们希望其他人能够认同这个模型并且和我们一起推进这个复杂而又令人着迷的领域的发展。</p>
</div>
<div class="paragraph">
<p>incude::chap12.adoc[]</p>
</div>
</div>
</div>
</div>
</div>
<div id="footnotes">
<hr>
<div class="footnote" id="_footnotedef_1">
<a href="#_footnoteref_1">1</a>. Java异步IO库
</div>
</div>
<div id="footer">
<div id="footer-text">
Version 1.0<br>
Last updated 2019-09-04 15:05:37 +0800
</div>
</div>
<style>
pre.pygments .hll { background-color: #ffffcc }
pre.pygments  { background: #f8f8f8; }
pre.pygments .tok-c { color: #408080; font-style: italic } /* Comment */
pre.pygments .tok-err { border: 1px solid #FF0000 } /* Error */
pre.pygments .tok-k { color: #008000; font-weight: bold } /* Keyword */
pre.pygments .tok-o { color: #666666 } /* Operator */
pre.pygments .tok-ch { color: #408080; font-style: italic } /* Comment.Hashbang */
pre.pygments .tok-cm { color: #408080; font-style: italic } /* Comment.Multiline */
pre.pygments .tok-cp { color: #BC7A00 } /* Comment.Preproc */
pre.pygments .tok-cpf { color: #408080; font-style: italic } /* Comment.PreprocFile */
pre.pygments .tok-c1 { color: #408080; font-style: italic } /* Comment.Single */
pre.pygments .tok-cs { color: #408080; font-style: italic } /* Comment.Special */
pre.pygments .tok-gd { color: #A00000 } /* Generic.Deleted */
pre.pygments .tok-ge { font-style: italic } /* Generic.Emph */
pre.pygments .tok-gr { color: #FF0000 } /* Generic.Error */
pre.pygments .tok-gh { color: #000080; font-weight: bold } /* Generic.Heading */
pre.pygments .tok-gi { color: #00A000 } /* Generic.Inserted */
pre.pygments .tok-go { color: #888888 } /* Generic.Output */
pre.pygments .tok-gp { color: #000080; font-weight: bold } /* Generic.Prompt */
pre.pygments .tok-gs { font-weight: bold } /* Generic.Strong */
pre.pygments .tok-gu { color: #800080; font-weight: bold } /* Generic.Subheading */
pre.pygments .tok-gt { color: #0044DD } /* Generic.Traceback */
pre.pygments .tok-kc { color: #008000; font-weight: bold } /* Keyword.Constant */
pre.pygments .tok-kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
pre.pygments .tok-kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
pre.pygments .tok-kp { color: #008000 } /* Keyword.Pseudo */
pre.pygments .tok-kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
pre.pygments .tok-kt { color: #B00040 } /* Keyword.Type */
pre.pygments .tok-m { color: #666666 } /* Literal.Number */
pre.pygments .tok-s { color: #BA2121 } /* Literal.String */
pre.pygments .tok-na { color: #7D9029 } /* Name.Attribute */
pre.pygments .tok-nb { color: #008000 } /* Name.Builtin */
pre.pygments .tok-nc { color: #0000FF; font-weight: bold } /* Name.Class */
pre.pygments .tok-no { color: #880000 } /* Name.Constant */
pre.pygments .tok-nd { color: #AA22FF } /* Name.Decorator */
pre.pygments .tok-ni { color: #999999; font-weight: bold } /* Name.Entity */
pre.pygments .tok-ne { color: #D2413A; font-weight: bold } /* Name.Exception */
pre.pygments .tok-nf { color: #0000FF } /* Name.Function */
pre.pygments .tok-nl { color: #A0A000 } /* Name.Label */
pre.pygments .tok-nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
pre.pygments .tok-nt { color: #008000; font-weight: bold } /* Name.Tag */
pre.pygments .tok-nv { color: #19177C } /* Name.Variable */
pre.pygments .tok-ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
pre.pygments .tok-w { color: #bbbbbb } /* Text.Whitespace */
pre.pygments .tok-mb { color: #666666 } /* Literal.Number.Bin */
pre.pygments .tok-mf { color: #666666 } /* Literal.Number.Float */
pre.pygments .tok-mh { color: #666666 } /* Literal.Number.Hex */
pre.pygments .tok-mi { color: #666666 } /* Literal.Number.Integer */
pre.pygments .tok-mo { color: #666666 } /* Literal.Number.Oct */
pre.pygments .tok-sa { color: #BA2121 } /* Literal.String.Affix */
pre.pygments .tok-sb { color: #BA2121 } /* Literal.String.Backtick */
pre.pygments .tok-sc { color: #BA2121 } /* Literal.String.Char */
pre.pygments .tok-dl { color: #BA2121 } /* Literal.String.Delimiter */
pre.pygments .tok-sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
pre.pygments .tok-s2 { color: #BA2121 } /* Literal.String.Double */
pre.pygments .tok-se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
pre.pygments .tok-sh { color: #BA2121 } /* Literal.String.Heredoc */
pre.pygments .tok-si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
pre.pygments .tok-sx { color: #008000 } /* Literal.String.Other */
pre.pygments .tok-sr { color: #BB6688 } /* Literal.String.Regex */
pre.pygments .tok-s1 { color: #BA2121 } /* Literal.String.Single */
pre.pygments .tok-ss { color: #19177C } /* Literal.String.Symbol */
pre.pygments .tok-bp { color: #008000 } /* Name.Builtin.Pseudo */
pre.pygments .tok-fm { color: #0000FF } /* Name.Function.Magic */
pre.pygments .tok-vc { color: #19177C } /* Name.Variable.Class */
pre.pygments .tok-vg { color: #19177C } /* Name.Variable.Global */
pre.pygments .tok-vi { color: #19177C } /* Name.Variable.Instance */
pre.pygments .tok-vm { color: #19177C } /* Name.Variable.Magic */
pre.pygments .tok-il { color: #666666 } /* Literal.Number.Integer.Long */
</style>
</body>
</html>